{"componentChunkName":"component---src-templates-article-jsx","path":"/blog/development/os-semaphores","result":{"data":{"datoCmsMiscTextString":{"locale":"ko-KR","updatedAtText":"업데이트됨","nextReadText":"관련있는 게시물"},"datoCmsBlogPost":{"locale":"ko-KR","originalId":"199715237","title":"[운영체제][OSTEP] 세마포어","seo":{"seoTitle":"[운영체제][OSTEP] 세마포어","seoDescription":"세마포어가 무엇인지, 락과 컨디션 변수 대신 세마포어를 사용하는 방법은 무엇인지에 대해 공부해봅니다.","seoImage":{"seoImageUrl":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format"}},"subtitle":"세마포어가 무엇인지, 락과 컨디션 변수 대신 세마포어를 사용하는 방법은 무엇인지에 대해 공부해봅니다.","coverImage":{"coverImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&w=860","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.25&w=860 215w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.5&w=860 430w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&w=860 860w","sizes":"(min-width: 860px) 860px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgLCgoLDhMVDhcNDh0VDxUSGhYdHSIVFhUaKysjGh0oHSEWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLCgUFEBAOEC8oIhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIAAwAGAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAFAQQGAP/EAB0QAAEEAgMAAAAAAAAAAAAAAAEAAgMEESEFEjL/xAAWAQADAAAAAAAAAAAAAAAAAAAAAQP/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwDD1KM1uPLjpIRUI4GZc4aRXH25hTOHqqbth7yDIVIiXI2IQzqCoREhL/RyuQH/2Q=="},"width":860,"height":430}},"meta":{"updatedAt":"2023-09-20T12:20:48.165+09:00","firstPublishedAt":"2023-09-17T22:42:41.578+09:00"},"categoryLink":{"title":"개발 공부","id":"4743072"},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorPictureData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 60px) 60px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgWEQ8LDhgYDhUNDhgNDw8NFxUdGBYfFhUaHysjGikoHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OHBANHDUcIig7NS81NS81MjUvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAFAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAABQYHAv/EAB4QAAICAgMBAQAAAAAAAAAAAAABAgMFBgQRQXEi/8QAFQEBAQAAAAAAAAAAAAAAAAAABAP/xAAaEQACAwEBAAAAAAAAAAAAAAAAAQIDEhMR/9oADAMBAAIRAxEAPwDT8/1LHSK/r67scevSfz99VXBkm/Cva/zKle/pCc/JoRXWsFujxvygcLI1pAXqQTmjONm2RzpceyCwmwxpsbbADWJdBFbeCfe2wXoAGpIL6z//2Q=="},"width":60,"height":60}}},"relatedPosts":[{"id":"199240150","meta":{"updatedAt":"2023-09-20T12:21:19.484+09:00"},"categoryLink":{"title":"개발 공부"},"coverImage":{"gatsbyImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.09&w=860 75w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.18&w=860 150w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860 300w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.7&w=860 600w","sizes":"(min-width: 300px) 300px, 100vw"}},"layout":"constrained","width":300,"height":120},"squaredImage":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.06&fit=crop&fp-x=0.5&fp-y=0.5&w=430 25w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.12&fit=crop&fp-x=0.5&fp-y=0.5&w=430 50w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430 100w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.47&fit=crop&fp-x=0.5&fp-y=0.5&w=430 200w","sizes":"(min-width: 100px) 100px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBhINEBAQCggUDg0IDgcHFh0JFhEYFxUZGCIVFhUaHysjGh0oHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OEg4REC8dFhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAGAMBIgACEQEDEQH/xAAaAAEBAAIDAAAAAAAAAAAAAAAABAUGAQID/8QAHRAAAgICAwEAAAAAAAAAAAAAAAIDBAEREhQVBf/EABYBAQEBAAAAAAAAAAAAAAAAAAADAf/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/ANASs2WLoaraMl1o0O241wSYlSHjgHM9hVAEFr6bKSemzAAeclpnAAH/2Q=="},"width":100,"height":100}},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.11&w=77 8w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 30px) 30px, 100vw"}},"layout":"constrained","width":30,"height":30}}},"subtitle":"멀티 쓰레드 프로그램에서 쓰레드가 진행을 위해 컨디션 변수를 통해 특정 조건을 기다리는 방법에 대해 공부해봅니다.","title":"[운영체제][OSTEP] 컨디션 변수"},{"id":"200585869","meta":{"updatedAt":"2023-09-20T12:19:39.295+09:00"},"categoryLink":{"title":"개발 공부"},"coverImage":{"gatsbyImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.09&w=860 75w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.18&w=860 150w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860 300w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.7&w=860 600w","sizes":"(min-width: 300px) 300px, 100vw"}},"layout":"constrained","width":300,"height":120},"squaredImage":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.06&fit=crop&fp-x=0.5&fp-y=0.5&w=430 25w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.12&fit=crop&fp-x=0.5&fp-y=0.5&w=430 50w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430 100w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.47&fit=crop&fp-x=0.5&fp-y=0.5&w=430 200w","sizes":"(min-width: 100px) 100px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBhINEBAQCggUDg0IDgcHFh0JFhEYFxUZGCIVFhUaHysjGh0oHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OEg4REC8dFhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAGAMBIgACEQEDEQH/xAAaAAEBAAIDAAAAAAAAAAAAAAAABAUGAQID/8QAHRAAAgICAwEAAAAAAAAAAAAAAAIDBAEREhQVBf/EABYBAQEBAAAAAAAAAAAAAAAAAAADAf/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/ANASs2WLoaraMl1o0O241wSYlSHjgHM9hVAEFr6bKSemzAAeclpnAAH/2Q=="},"width":100,"height":100}},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.11&w=77 8w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 30px) 30px, 100vw"}},"layout":"constrained","width":30,"height":30}}},"subtitle":"일반적인 병행성 관련 오류들을 어떻게 처리하는지 공부해봅니다.","title":"[운영체제][OSTEP] 병행성 관련 오류"}],"structuredBody":{"blocks":[{"__typename":"DatoCmsArticleBodyImage","id":"199729890","image":{"gatsbyImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1694974899-dining_philosopher.png?auto=format&w=860","srcSet":"https://www.datocms-assets.com/66479/1694974899-dining_philosopher.png?auto=format&dpr=0.25&w=860 215w,\nhttps://www.datocms-assets.com/66479/1694974899-dining_philosopher.png?auto=format&dpr=0.5&w=860 430w,\nhttps://www.datocms-assets.com/66479/1694974899-dining_philosopher.png?auto=format&w=860 860w","sizes":"(min-width: 860px) 860px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAANCAIAAAA4++m6AAAAAXNSR0IArs4c6QAAAT9JREFUOE+tk72OwjAQhMdOcPgXFwlyoj4KOt6/oEQ8AU2gQITEkCISJhApjvcKpJOOxKmYdvyNvJ41IyJ8TrzFK8uSiKqqej6fAKSU+/1ea92CWOPSNF2v18fjsSzLPM+11mEY7nY7pZQNAeDaDGOMMUZXlRBiOBy6rrtcLh+Px2g0siEAmO3tjDFFUXS7Xc7/TZBl2WAwEEI0Us3DElGapgDesowxnHPHcRop2OIYY+PxuNPpvJ/m3HGc0+lUFEUj2BynlEqSpLHE8/m82WziOK5bsMVFUbTdbqWUdSsIgtVqNZvN6hZsVdxuNynlfD4H4Hnea2oiiuPY9/1er1dHXrI2C4CI5OXyNZlkWXa9Xn8WCwYIIVzXul5tv4Ix9h0EnuclSXI4HO5K9fv9liy03+5P9zy/KzWdTltW5KVfzw6fcPALz9wAAAAASUVORK5CYII="},"width":860,"height":430},"alt":"dining philosopher"}},{"__typename":"DatoCmsArticleBodyImage","id":"199729922","image":{"gatsbyImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1694975848-dining_philosopher2.png?auto=format&w=860","srcSet":"https://www.datocms-assets.com/66479/1694975848-dining_philosopher2.png?auto=format&dpr=0.25&w=860 215w,\nhttps://www.datocms-assets.com/66479/1694975848-dining_philosopher2.png?auto=format&dpr=0.5&w=860 430w,\nhttps://www.datocms-assets.com/66479/1694975848-dining_philosopher2.png?auto=format&w=860 860w","sizes":"(min-width: 860px) 860px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAANCAIAAAA4++m6AAAAAXNSR0IArs4c6QAAAUVJREFUOE+tk71vwjAQxc+Ok6CUj6RVaJWJgaFILP3/Z9ROtDvNgKiDcZAQwSiRYnwdkJBK4kx969P76fzuTBAR/k+0w6vrGgEul0tZlgAghPhOU611R4TZjDzPl8vl62QyjmOlteu6q9XquN8/RVH0+GhLWXHGGGOMptQfjUhdM8Zms1l5PPYdxxYBAGLrziBWZdnr9Sj9U8hByocw9DyvNdXeHSLmUgLAHcsYQ33fsQ/YjiOEDBhz2X0VlFLHcTabTVVVrcF23KkodjupjWlaPMveF4ssy5oW2HA/nH98fYrttmk9DwZv83k8HjctsK2iKAohRJIkQIjv+9dXI2LGedTvB2HYjFxl3SwAIKLgPBoOD+ezlHI6nRJCPM9jjU5v6voVhJCXJPEo3a3XaZoqpYIg6GBB93Q3nZU6KRXHcceJXPULfKuTbZ4GVEoAAAAASUVORK5CYII="},"width":860,"height":430},"alt":"dining philosopher 2"}}],"links":[],"value":{"schema":"dast","document":{"type":"root","children":[{"type":"heading","level":2,"children":[{"type":"span","value":"1️⃣ 세마포어: 정의"}]},{"type":"paragraph","children":[{"type":"span","value":"세마포어는 정수 값을 갖는 객체로서 두 개의 루틴으로 조작할 수 있다.\n➡️ POSIX 표준에서 "},{"type":"span","marks":["code"],"value":"sem_wait()"},{"type":"span","value":"와 "},{"type":"span","marks":["code"],"value":"sem_post()"},{"type":"span","value":"임."}]},{"type":"paragraph","children":[{"type":"span","value":"🌱 세마포어는 초기값에 의해 동작이 결정\n➡️ 사용하기 전 \"제일 먼저\" 값을 초기화해야 함."}]},{"type":"paragraph","children":[{"type":"span","value":"다음은 세마포어를 초기화하는 코드이다."}]},{"code":"#include <semaphore.h>\nsem_t s; // 세마포어 선언\nsem_init(&s, 0, 1); // 세마포어의 값을 1로 초기화","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"sem_init()"},{"type":"span","value":"의 두 번째 인자는 같은 프로세스 내의 쓰레드 간에 세마포어를 공유한다는 것을 의미한다."}]},{"type":"paragraph","children":[{"type":"span","value":"위 에서 제시한 두 루틴은 다음과 같이 나타낼 수 있다."}]},{"code":"int sem_wait(sem_t *s) {\n  decrement the value of semaphore s by one;\n  wait if value of semaphore s is negative;\n}\n\nint sem_post(sem_t *s) {\n  increment the value of semaphore s by one;\n  if there are one or more threads waiting, wake one;\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"이 루틴들은 다수 쓰레드들에 의해 동시에 호출되는 것을 가정한다.\n➡️ 임계 영역은 적절히 보호되어야 함."}]},{"type":"paragraph","children":[{"type":"span","value":"위 루틴들의 핵심적인 성질을 살펴보자."}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":" "},{"type":"span","marks":["code"],"value":"sem_wait()"},{"type":"span","value":" 함수는 "},{"type":"span","marks":["highlight"],"value":"즉시 리턴하거나(세마포어의 값 ≥ 1), 해당 세마포어 값이 1이상이 될 때까지 호출자를 대기"},{"type":"span","value":"시킴."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"다수의 쓰레드들이  "},{"type":"span","marks":["code"],"value":"sem_wait()"},{"type":"span","value":"를 호출할 수 있으므로 "},{"type":"span","marks":["highlight"],"value":"대기큐에는 다수의 쓰레드가 존재할 수 있음."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":" "},{"type":"span","marks":["code"],"value":"sem_wait()"},{"type":"span","value":" 함수와 달리 "},{"type":"span","marks":["code"],"value":"sem_post()"},{"type":"span","value":" 함수는 "},{"type":"span","marks":["highlight"],"value":"대기하지 않고 세마포어 값을 증가시키고 대기 중인 쓰레드 중 하나를 깨움."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"세마포어가 음수라면 그 값은 현재 대기 중인 쓰레드의 개수와 같음."}]},{"type":"paragraph","children":[{"type":"span","value":"➡️ 일반적으로 세마포어 사용자는 이 값을 알 수 없음."}]}]}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"2️⃣ 이진 세마포어(락)"}]},{"type":"paragraph","children":[{"type":"span","value":"다음에서 \"락\"에 세마포어를 적용하는 모습을 살펴보자."}]},{"code":"sem_t m;\nsem_init(&m, 0, X); // X로 세마포어를 초기화하기. 이때 X가 가져야 할 값은?\nsem_wait(&m);\n// 임계 영역 부분은 여기에 배치\nsem_post(&m);","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"sem_wait()"},{"type":"span","value":"/"},{"type":"span","marks":["code"],"value":"sem_post()"},{"type":"span","value":" 쌍으로 임계 영역 부분을 둘러싼 것을 확인할 수 있다."}]},{"type":"paragraph","children":[{"type":"span","value":"이때, "},{"type":"span","marks":["highlight"],"value":"위 코드가 동작하기 위한 핵심은 세마포어 "},{"type":"span","marks":["code","highlight"],"value":"m"},{"type":"span","marks":["highlight"],"value":"의 초기값"},{"type":"span","value":"(위의 코드에서 X)임."}]},{"type":"paragraph","children":[{"type":"span","value":"💡 두 루틴의 정의에 따라 초기값은 1이 되어야 한다는 것을 알 수 있음."}]},{"type":"paragraph","children":[{"type":"span","value":"다음과 같이 쓰레드가 두 개인 경우를 가정하여 이를 살펴보자."}]},{"type":"paragraph","children":[{"type":"span","value":"[1] 한 쓰레드가 임계 영역 내에 있을 때 다른 쓰레드가 "},{"type":"span","marks":["highlight"],"value":"락을 획득하려고 하지 않는 경우"}]},{"code":"Value of Semaphore     Thread 0             Thread 1\n────────────────────────────────────────────────────\n         1    \n         1             call sem_wait()\n         0             sem_wait() returns\n         0             (crit sect)\n         0             call sem_post()\n         1             sem_post() returns","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"[2] 한 쓰레드가 임계 영역 내에 있을 때 다른 쓰레드가 "},{"type":"span","marks":["highlight"],"value":"락을 획득하려고 하는 경우"}]},{"code":"Val │ Thread 0                State │ Thread 1           State\n────┼───────────────────────────────┼─────────────────────────\n 1  │                          Run  │                    Ready\n 1  │ call sem_wait()          Run  │                    Ready\n 0  │ sem_wait() returns       Run  │                    Ready\n 0  │ (crit sect begin)        Run  │                    Ready\n 0  │ Interrupt; Switch → T1  Ready │                     Run\n 0  │                         Ready │ call sem_wait()     Run\n -1 │                         Ready │ decr sem            Run\n -1 │                         Ready │ (sem<0) → sleep    Sleep\n -1 │                          Run  │ Switch → T0        Sleep\n -1 │ (crit sect end)          Run  │                    Sleep\n -1 │ call sem_post()          Run  │                    Sleep\n 0  │ incr sem                 Run  │                    Sleep\n 0  │ wake(T1)                 Run  │                    Ready\n 0  │ sem_post() returns       Run  │                    Ready\n 0  │ Interrupt; Switch → T1  Ready │                     Run\n 0  │                         Ready │ sem_wait() returns  Run\n 0  │                         Ready │ (crit sect)         Run\n 0  │                         Ready │ call sem_post()     Run\n 1  │                         Ready │ sem_post() returns  Run","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"락은 두 개의 상태(사용 가능, 사용 중)만 존재하므로 "},{"type":"span","marks":["highlight"],"value":"이진 세마포어(binary semaphore)"},{"type":"span","value":"라고도 불림."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"3️⃣ 컨디션 변수로서의 세마포어"}]},{"type":"paragraph","children":[{"type":"span","value":"대기 중인 쓰레드(들)가 프로그램에서의 어떤 "},{"type":"span","marks":["highlight"],"value":"조건(condition)"},{"type":"span","value":"이 만족되기를 대기하기 때문에, "},{"type":"span","marks":["highlight"],"value":"세마포어를 컨디션 변수처럼 사용할 수 있음."}]},{"type":"paragraph","children":[{"type":"span","value":"다음과 같이 부모 쓰레드가 자식 쓰레드를 생성한 후 자식 쓰레드의 종료를 대기하고자 하는 예시를 살펴보자."}]},{"code":"parent: begin\nchild\nparent: end","type":"code"},{"code":"sem_t s;\n\nvoid *child(void *arg) {\n    printf(\"child\\n\");\n    sem_post(&s); // 시그널 전달: 자식의 동작이 끝남\n    return NULL;\n}\n\nint main(int argc, char *argv[]) {\n    sem_init(&s, 0, X); // x의 값은 무엇이 되어야 할까?\n    printf(\"parent: begin\\n\");\n    pthread_t c;\n    Pthread_create(c, NULL, child, NULL);\n    sem_wait(&s); //자식을 여기서 대기\n    printf(\"parent: end\\n\");\n    return 0;\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"부모 프로세스는 자식 프로세스 생성 후  "},{"type":"span","marks":["code"],"value":"sem_wait()"},{"type":"span","value":"를 호출하여 자식의 종료를 대기함."}]},{"type":"paragraph","children":[{"type":"span","value":"자식은  "},{"type":"span","marks":["code"],"value":"sem_post()"},{"type":"span","value":"를 호출하여 종료되었음을 알림."}]},{"type":"paragraph","children":[{"type":"span","value":"💡 이때 세마포어의 초기값은 0이 되어야 한다."}]},{"type":"paragraph","children":[{"type":"span","value":"다음에서 발생할 수 있는 두 가지 상황을 통해 그 이유를 알아보자."}]},{"type":"paragraph","children":[{"type":"span","value":"[1] 자식 프로세스 생성 후, 아직 "},{"type":"span","marks":["highlight"],"value":"자식 프로세스가 실행을 시작하지 않은 경우"}]},{"code":"Val │ Thread 0            State │ Thread 1                   State\n────┼───────────────────────────┼─────────────────────────────────\n 0  │ create(Child)        Run  │ (Child exists, can run)    Ready\n 0  │ call sem_wait()      Run  │                            Ready\n -1 │ decr sem             Run  │                            Ready\n -1 │ (sem<0) → sleep     Sleep │                            Ready\n -1 │ Switch → Child      Sleep │ child runs                  Run\n -1 │                     Sleep │ call sem_post()             Run\n 0  │                     Sleep │ incr sem                    Run\n 0  │                     Ready │ wake(Parent)                Run\n 0  │                     Ready │ sem_post() returns          Run\n 0  │                     Ready │ Interrupt → Parent         Ready\n 0  │ sem_wait() returns   Run  │                            Ready","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"[2]  부모 프로세스가 "},{"type":"span","marks":["code"],"value":"sem_wait()"},{"type":"span","value":"를 호출하기 전에 "},{"type":"span","marks":["highlight"],"value":"자식 프로세스의 실행이 종료된 경우"}]},{"code":"Val │ Thread 0            State │ Thread 1                   State\n────┼───────────────────────────┼─────────────────────────────────\n 0  │ create(Child)        Run  │ (Child exists, can run)    Ready\n 0  │ Interrupt → Child   Ready │ child runs                  Run\n 0  │                     Ready │ call sem_post()             Run\n 1  │                     Ready │ inc sem                     Run\n 1  │                     Ready │ wake(nobody)                Run\n 1  │                     Ready │ sem_post() returns          Run\n 1  │ parent runs          Run  │ Interrupt → Parent         Ready\n 1  │ call sem_wait()      Run  │                            Ready\n 0  │ decr sem             Run  │                            Ready\n 0  │ (sem≥0) → awake      Run  │                            Ready\n 0  │ sem_wait() returns   Run  │                            Ready","type":"code"},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"4️⃣ 생산자/소비자(유한 버퍼) 문제"}]},{"type":"heading","level":3,"children":[{"type":"span","value":"첫 번째 시도"}]},{"type":"paragraph","children":[{"type":"span","value":"먼저, "},{"type":"span","marks":["code"],"value":"empty"},{"type":"span","value":"와 "},{"type":"span","marks":["code"],"value":"full"},{"type":"span","value":"이라는 두 개의 세마포어를 사용하여 문제 해결을 시도해보자."}]},{"type":"paragraph","children":[{"type":"span","value":"쓰레드는 "},{"type":"span","marks":["code"],"value":"empty"},{"type":"span","value":"와 "},{"type":"span","marks":["code"],"value":"full"},{"type":"span","value":"을 사용하여 버퍼 공간이 비었는지 채워졌는지를 표시한다."}]},{"type":"paragraph","children":[{"type":"span","value":"다음과 같은 상황을 가정한 예시를 살펴보자."}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"MAX=1"},{"type":"span","value":"인 상황(버퍼의 크기가 1인 경우)"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"생산자와 소비자 쓰레드가 각 하나씩 존재"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"CPU도 한 개 존재"}]}]}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"put()"},{"type":"span","value":"과 "},{"type":"span","marks":["code"],"value":"get()"},{"type":"span","value":" 코드는 다음과 같다."}]},{"code":"int buffer[MAX];\nint fill = 0;\nint use = 0;\n\nvoid put(int value) {\n  buffer[fill] = value;    // f1 라인\n  fill = (fill + 1) % MAX; // f2 라인\n}\n\nint get() {\n  int tmp = buffer[use];   // g1 라인\n  use = (use + 1) % MAX;   // g2 라인\n  return tmp;\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"다음은 해결을 위해 시도한 코드이다."}]},{"code":"sem_t empty;\nsem_t full;\n\nvoid *producer(void *arg) {\n    int i;\n    for (i = 0; i < loops; i++) {\n        sem_wait(&empty);          // P1 라인\n        put(i);                    // P2 라인\n        sem_post(&full);           // P3 라인\n    }\n}\n\nvoid *consumer(void *arg) {\n    int i, tmp = 0;\n    while (tmp != −1) {\n        sem_wait(&full);           // C1 라인\n        tmp = get();               // C2 라인\n        sem_post(&empty);          // C3 라인\n        printf(\"%d\\n\", tmp);\n    }\n}\n\nint main(int argc, char *argv[]) {\n    // ...\n    sem_init(&empty, 0, MAX);  // MAX 버퍼는 비어 있는 상태로 시작...\n    sem_init(&full, 0, 0);     // ... 그리고 0이 가득 참\n    // ...\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"소비자가 먼저 실행"},{"type":"span","value":"한다면, 소비자 쓰레드는 "},{"type":"span","marks":["code"],"value":"sem_wait(&full)"},{"type":"span","value":"을 호출(C1)한다.\n➡️ 변수 "},{"type":"span","marks":["code"],"value":"full"},{"type":"span","value":"의 값은 0으로 초기화되었으므로 "},{"type":"span","marks":["code"],"value":"full"},{"type":"span","value":"의 값은 -1이 되고, "},{"type":"span","marks":["highlight"],"value":"소비자는 대기"},{"type":"span","value":"한다."}]},{"type":"paragraph","children":[{"type":"span","value":"이후 "},{"type":"span","marks":["highlight"],"value":"생산자 쓰레드가 실행"},{"type":"span","value":"하여 "},{"type":"span","marks":["code"],"value":"sem_wait(&empty)"},{"type":"span","value":" 루틴을 호출(P1)한다.\n➡️ "},{"type":"span","marks":["code"],"value":"empty"},{"type":"span","value":" 변수가 MAX(이 예시에서는 1)로 설정되었으므로 "},{"type":"span","marks":["highlight"],"value":"대기하지 않고 계속 실행"},{"type":"span","value":"한다."}]},{"type":"paragraph","children":[{"type":"span","value":"empty 변수는 0이 되고 "},{"type":"span","marks":["highlight"],"value":"생산자가 데이터 값을 버퍼의 첫 번째 공간에 넣는다."},{"type":"span","value":"(P2)"}]},{"type":"paragraph","children":[{"type":"span","value":"그 후 생산자는 "},{"type":"span","marks":["code"],"value":"sem_post(&full)"},{"type":"span","value":"를 호출(P3)하여 "},{"type":"span","marks":["code"],"value":"full"},{"type":"span","value":"의 값을 -1에서 0으로 변경하고 "},{"type":"span","marks":["highlight"],"value":"소비자 쓰레드를 깨운다.\n"},{"type":"span","value":"➡️ 소비자 쓰레드는 대기 상태에서 준비 상태로 바뀜."}]},{"type":"paragraph","children":[{"type":"span","value":"💡 이제 둘 중 하나의 상황이 발생할 수 있다."}]},{"type":"paragraph","children":[{"type":"span","value":"[1] "},{"type":"span","marks":["highlight"],"value":"생산자가 계속 실행"},{"type":"span","value":"하는 상황"}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"empty"},{"type":"span","value":" 세마포어의 값이 0이므로 "},{"type":"span","marks":["highlight"],"value":"대기 상태"},{"type":"span","value":"로 들어간다.(P1)"}]},{"type":"paragraph","children":[{"type":"span","value":"[2] 생산자 쓰레드가 인터럽트에 걸리고 "},{"type":"span","marks":["highlight"],"value":"소비자 쓰레드가 실행"},{"type":"span","value":"하는 상황"}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"sem_wait(&full)"},{"type":"span","value":" 문(C1)을 호출하여 버퍼가 찼다는 것을 발견하고 데이터를 소비한다."}]},{"type":"paragraph","children":[{"type":"span","value":"🤔 그렇다면 MAX 값이 1보다 크고, 생산자와 소비자 쓰레드들이 여러 개 있다면 어떨까?"}]},{"type":"paragraph","children":[{"type":"span","value":"이때는 "},{"type":"span","marks":["highlight"],"value":"경쟁 조건이 발생"},{"type":"span","value":"한다."}]},{"type":"paragraph","children":[{"type":"span","value":"두 개의 생산자 Pa, Pb가 "},{"type":"span","marks":["code"],"value":"put()"},{"type":"span","value":"을 거의 동시에 호출하고 Pa가 먼저 실행된 경우"}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Pa가 버퍼의 첫 공간에 값을 넣기 시작(f1 라인에서"},{"type":"span","marks":["code"],"value":" fill=0"},{"type":"span","value":")"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Pa 쓰레드가 "},{"type":"span","marks":["code"],"value":"fill"},{"type":"span","value":" 카운터 변수를 1로 변경하기 전에 인터럽트에 걸림."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Pb가 실행되어 f1 라인에서 마찬가지로 버퍼의 첫 번째 공간에 데이터를 삽입한다."}]},{"type":"paragraph","children":[{"type":"span","value":"➡️ ⚠️ "},{"type":"span","marks":["highlight"],"value":"Pa가 기록한 이전의 값은 새로운 값으로 대체됨."}]}]}]},{"type":"heading","level":3,"children":[{"type":"span","value":"상호 배제의 추가 but, ..."}]},{"type":"paragraph","children":[{"type":"span","value":"위에서는 상호 배제를 고려하지 않았다.\n➡️ 이진 세마포어와 몇 개의 락을 추가하여 해결해보자."}]},{"code":"sem_t empty;\nsem_t full;\nsem_t mutex;\n\nvoid *producer(void *arg) {\n    int i;\n    for (i = 0; i < loops; i++) {\n        sem_wait(&mutex);          // p0 라인(추가됨)\n        sem_wait(&empty);          // p1 라인\n        put(i);                    // p2 라인\n        sem_post(&full);           // p3 라인\n        sem_post(&mutex);          // p4 라인(추가됨)\n    }\n}\n\nvoid *consumer(void *arg) {\n    int i;\n    for (i = 0; i < loops; i++) {\n        sem_wait(&mutex);          // c0 라인(추가됨)\n        sem_wait(&full);           // c1 라인\n        int tmp = get();           // c2 라인\n        sem_post(&empty);          // c3 라인\n        sem_post(&mutex);          // c4 라인(추가됨)\n        printf(\"%d\\n\", tmp);\n    }\n}\n\nint main(int argc, char *argv[]) {\n    // ...\n    sem_init(&empty, 0, MAX);  // MAX 버퍼는 비어 있는 상태로 시작...\n    sem_init(&full, 0, 0);     // ... 그리고 0이 가득 참\n    sem_init(&mutex, 0, 1);    // 락이기 때문에 mutex=1 (추가됨)\n    // ...\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 하지만 이 코드는 "},{"type":"span","marks":["highlight"],"value":"교착 상태가 발생"},{"type":"span","value":"할 수 있으므로 동작하지 않는다."}]},{"type":"paragraph","children":[{"type":"span","value":"생산자와 소비자 쓰레드가 각 하나씩 있을 때, 소비자가 먼저 실행하는 경우"}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"mutex"},{"type":"span","value":"(c0)를 획득하고 "},{"type":"span","marks":["code"],"value":"full"},{"type":"span","value":" 변수에 대하여 "},{"type":"span","marks":["code"],"value":"sem_wait()"},{"type":"span","value":"(c1)를 호출"}]},{"type":"paragraph","children":[{"type":"span","value":"➡️ 아직 데이터가 없으므로 소비자는 대기해야 하고 CPU를 양보함."}]},{"type":"paragraph","children":[{"type":"span","value":"➡️ ⭐ "},{"type":"span","marks":["highlight"],"value":"소비자가 여전히 락을 획득하고 있음."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"생산자가 실행하여 mutex 세마포어에 대해 "},{"type":"span","marks":["code"],"value":"sem_wait()"},{"type":"span","value":"(p0)를 호출"}]},{"type":"paragraph","children":[{"type":"span","value":"➡️ 이미 락은 소비자가 획득한 상태이므로 생산자 역시 대기 상태에 진입함."}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"소비자: "},{"type":"span","marks":["code"],"value":"mutex"},{"type":"span","value":"를 갖고 다른 "},{"type":"span","marks":["code"],"value":"full"},{"type":"span","value":" 시그널 발생 대기\n🆚\n생산자: "},{"type":"span","marks":["code"],"value":"full"},{"type":"span","value":" 시그널을 발생시켜야 하지만 "},{"type":"span","marks":["code"],"value":"mutex"},{"type":"span","value":"에서 대기\n➡️ 전형적인 교착 상태의 모습"}]},{"type":"heading","level":3,"children":[{"type":"span","value":"최종, 제대로 된 해법"}]},{"type":"paragraph","children":[{"type":"span","value":"이 문제를 해결하기 위해서는 락의 범위(scope)를 줄여야 함."}]},{"code":"sem_t empty;\nsem_t full;\nsem_t mutex;\n\nvoid *producer(void *arg) {\n    int i;\n    for (i = 0; i < loops; i++) {\n        sem_wait(&empty);          // p1 라인\n        sem_wait(&mutex);          // p1.5 라인(여기로 MUTEX 이동)\n        put(i);                    // p2 라인\n        sem_post(&mutex);          // p2.5 라인(... 그리고 여기)\n        sem_post(&full);           // p3 라인\n    }\n}\n\nvoid *consumer(void *arg) {\n    int i;\n    for (i = 0; i < loops; i++) {\n        sem_wait(&full);           // c1 라인\n        sem_wait(&mutex);          // c1.5 라인(여기로 MUTEX 이동)\n        int tmp = get();           // c2 라인\n        sem_post(&mutex);          // c2.5 라인(... 그리고 여기)\n        sem_post(&empty);          // c3 라인\n        printf(\"%d\\n\", tmp);\n    }\n}\n\nint main(int argc, char *argv[]) {\n    // ...\n    sem_init(&empty, 0, MAX);  // MAX 버퍼는 비어 있는 상태로 시작...\n    sem_init(&full, 0, 0);     // ... 그리고 0이 가득 참\n    sem_init(&mutex, 0, 1);    // 락이기 때문에 mutex=1\n    // ...\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"mutex"},{"type":"span","value":"를 획득하고 해제하는 코드를 "},{"type":"span","marks":["highlight"],"value":"임계 영역 바로 이전과 이후로 이동"},{"type":"span","value":"하였다.\n➡️ 드디어 멀티 쓰레드 프로그램에서 사용 가능한 유한 버퍼"}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"5️⃣ Reader-Writer 락"}]},{"type":"paragraph","children":[{"type":"span","value":"다양한 자료 구조를 접근하는 데 여러 종류의 락 기법이 필요"}]},{"type":"paragraph","children":[{"type":"span","value":"리스트에 삽입하고 간단한 검색을 하는 것과 같은 병행 연산이 여러 개 있다고 가정하자."}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"삽입 연산: 리스트의 상태를 변경(전통적인 임계 영역 보호 방식으로 해결 가능)"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"검색 연산: 자료 구조를 단순히 읽음."}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"💡 삽입 연산이 없다는 보장만 된다면 다수의 검색 작업을 동시에 수행할 수 있음.\n➡️ 이와 같은 경우를 위해 만들어진 락: "},{"type":"span","marks":["highlight"],"value":"reader-writer 락"}]},{"type":"paragraph","children":[{"type":"span","value":"코드는 다음과 같다."}]},{"code":"typedef struct _rwlock_t {\n    sem_t lock; // 이진 세마포어(기본 락)\n    sem_t writelock; // 하나의 쓰기 또는 다수의 읽기 락을 위한 락\n    int readers; // 임계 영역 내에 읽기를 수행 중인 reader의 수\n} rwlock_t;\n\nvoid rwlock_init(rwlock_t *rw) {\n    rw−>readers = 0;\n    sem_init(&rw−>lock, 0, 1);\n    sem_init(&rw−>writelock, 0, 1);\n}\n\nvoid rwlock_acquire_readlock(rwlock_t *rw) {\n    sem_wait(&rw−>lock);\n    rw−>readers++;\n    if (rw−>readers == 1)\n        sem_wait(&rw−>writelock); // 읽기용 락이 writelock을 획득\n    sem_post(&rw−>lock);\n}\n\nvoid rwlock_release_readlock(rwlock_t *rw) {\n    sem_wait(&rw−>lock);\n    rw−>readers−−;\n    if (rw−>readers == 0)\n        sem_post(&rw−>writelock); // 마지막으로 읽기용 락이 writelock 해제\n    sem_post(&rw−>lock);\n}\n\nvoid rwlock_acquire_writelock(rwlock_t *rw) {\n    sem_wait(&rw−>writelock);\n}\n\nvoid rwlock_release_writelock(rwlock_t *rw) {\n    sem_post(&rw−>writelock);\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"자료 구조를 \"갱신\"하려면 동기화 연산 쌍을 사용한다."}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"락을 획득하기 위해서 "},{"type":"span","marks":["code"],"value":"rwlock_acquire_writelock()"},{"type":"span","value":"을 사용"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"락을 해제하기 위해서 "},{"type":"span","marks":["code"],"value":"rwlock_release_writelock()"},{"type":"span","value":"을 사용"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"내부적으로는 writelock 세마포어를 사용하여 "},{"type":"span","marks":["highlight"],"value":"하나의 쓰기 쓰레드만이 락을 획득"},{"type":"span","value":"할 수 있도록 함."}]},{"type":"paragraph","children":[{"type":"span","value":"⭐ 읽기 락(reader lock)의 획득과 해제 과정을 조금 더 살펴보자."}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"읽기 락 획득 시 읽기 쓰레드가 먼저 락을 획득"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"읽기 중인 쓰레드의 수를 표현하는 reader 변수를 증가시킴."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"writelock 세마포어에 대해 "},{"type":"span","marks":["code"],"value":"sem_wait()"},{"type":"span","value":"을 호출하여 "},{"type":"span","marks":["highlight"],"value":"쓰기 락을 함께 획득"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"읽기 락을 해제할 때 "},{"type":"span","marks":["code"],"value":"sem_post()"},{"type":"span","value":"로 쓰기 락을 다시 해제"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"이 과정을 통해서 "},{"type":"span","marks":["highlight"],"value":"읽기 락을 획득한 후, 다른 읽기 쓰레드들이 읽기 락을 획득"},{"type":"span","value":"할 수 있도록 함."}]},{"type":"paragraph","children":[{"type":"span","value":"반면, "},{"type":"span","marks":["highlight"],"value":"쓰기 락을 획득하려는 쓰기 쓰레드들은 모든 읽기 쓰레드가 끝날 때까지 대기"},{"type":"span","value":"해야 함."}]},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 하지만 이 방식은 공정성에 문제가 있음.\n➡️ 상대적으로 쓰기 쓰레드가 불리"}]},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 또한 이 방식은 오버헤드가 큼.\n➡️ 기법이 정교하기 때문"}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"6️⃣ 식사하는 철학자(Dining Philosopher)"}]},{"item":"199729890","type":"block"},{"type":"paragraph","children":[{"type":"span","value":"식사하는 철학자 문제는 다음과 같은 상황을 나타낸다."}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"다섯 명의 \"철학자\"가 식탁 주위를 둘러앉았다."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"총 다섯 개의 포크가 철학자와 철학자 사이에 하나씩 놓여 있다."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"철학자는 식사하는 때가 있고 생각하는 때가 있다."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"생각 중일 때는 포크가 필요없다."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"식사를 위해서는 자신의 왼쪽과 오른쪽에 있는 포크를 들어야 한다."}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"💡 이 포크를 잡기 위한 경쟁과 그에 따른 동기화 문제가 병행 프로그래밍에서 다루려는 식사하는 철학자 문제이다."}]},{"type":"paragraph","children":[{"type":"span","value":"다음은 각 철학자의 동작을 나타낸 기본 반복문이다."}]},{"code":"while (1) {\n  think();\n  getforks();\n  eat();\n  putforks();\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"주요 쟁점은 "},{"type":"span","marks":["code"],"value":"getfork()"},{"type":"span","value":"와 "},{"type":"span","marks":["code"],"value":"putfork()"},{"type":"span","value":"의 루틴을 작성하되,\n[1] 교착 상태의 발생을 방지해야 하고,\n[2] 어떤 철학자도 못 먹어서 굶주리면 안되며\n[3] 병행성이 높아야 한다.\n➡️ 즉, 가능한 많은 철학자가 동시에 식사를 할 수 있어야 함."}]},{"type":"paragraph","children":[{"type":"span","value":"문제 해결을 위해서는 Downey의 해법과 같이 몇 가지 함수를 사용함."}]},{"code":"int left(int p) { return p; } // 철학자 p가 자신의 왼쪽 포크를 잡기 위해 호출\nint right(int p) { return (p + 1) % 5; } // 철학자 p가 자신의 오른쪽 포크를 잡기 위해 호출","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"이 "},{"type":"span","marks":["highlight"],"value":"문제를 해결하기 위해 세마포어가 필요"},{"type":"span","value":"하므로, 각 포크마다 한 개씩하여 "},{"type":"span","marks":["code"],"value":"sem_t fork[5]"},{"type":"span","value":"로 정의한다."}]},{"type":"paragraph","children":[{"type":"span","value":"[첫 번째 시도 - 불완전한 해답]"}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"forks"},{"type":"span","value":" 배열에 있는 각 포크에 대한 세마포어를 1로 초기화하고 각 철학자는 자신의 순번("},{"type":"span","marks":["code"],"value":"p"},{"type":"span","value":")을 알고 있다고 가정하자."}]},{"code":"void getforks() {\n  sem_wait(forks[left(p)]);\n  sem_wait(forks[right(p)]);\n}\n\nvoid putforks() {\n  sem_post(forks[left(p)]);\n  sem_post(forks[right(p)]);\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"원리는 다음과 같다."}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"포크가 필요할 때 단순히 하나의 \"락\"을 획득"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"먼저 왼쪽의 것을 잡고 그 다음에 오른쪽의 것을 잡음."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"식사가 끝나면 잡은 순서대로 놓음."}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"🚫 문제는 교착 상태이다.\n➡️ 만약 각 철학자가 자신의 왼쪽 포크를 다른 철학자가 자신의 오른쪽 포크를 잡기 전에 먼저 잡았다면, 각 철학자는 하나의 포크만 들고서 다른 포크를 잡기를 평생 기다림."}]},{"type":"paragraph","children":[{"type":"span","value":"다음의 그림을 통해 이러한 상황을 이해해보자."}]},{"item":"199729922","type":"block"},{"type":"paragraph","children":[{"type":"span","value":"[두 번째 시도 - 의존성 제거]"}]},{"type":"paragraph","children":[{"type":"span","value":"위 문제를 해결하는 가장 간단한 방법은 최소한 하나의 철학자가 다른 순서로 포크를 집도록 하는 것이다."}]},{"type":"paragraph","children":[{"type":"span","value":"가장 높은 순번의 철학자 4가 포크를 다른 순서로 획득한다고 가정하자. 그때의 코드는 다음과 같다."}]},{"code":"void getforks() {\n  if (p == 4) {\n    sem_wait(forks[right(p)]);\n    sem_wait(forks[left(p)]);\n  } else {\n    sem_wait(forks[left(p)]);\n    sem_wait(forks[right(p)]);\n  }\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"💡 마지막 철학자가 오른쪽 포크를 먼저 잡기 때문에 각 철학자가 하나의 포크를 든 채 다른 포크를 기다리는 대기 상황은 발생하지 않는다.\n➡️ 환형 대기 상태가 끊어짐."}]},{"type":"paragraph","children":[{"type":"span","value":"이와 비슷한 \"유명한\" 문제들은 다음과 같다."}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"url":"https://en.wikipedia.org/wiki/Cigarette_smokers_problem","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"흡연가의 문제(Cigarette Smoker Problem)"}]}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"url":"https://en.wikipedia.org/wiki/Sleeping_barber_problem","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"잠자는 이발사의 문제(Sleeping Barber Problem)"}]}]}]}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"7️⃣ 쓰레드 쓰로틀링"}]},{"type":"paragraph","children":[{"type":"span","value":"세마포어의 또 다른 간단한 사용 사례가 때때로 발생함.\n➡️ 프로그래머가 \"너무 많은\" 쓰레드들이 동시에 작업을 수행하여 시스템이 중단되는 것을 어떻게 방지할 수 있을까?"}]},{"type":"paragraph","children":[{"type":"span","value":"💡 \"너무 많은\"에 대한 임계 값을 결정한 후 세마포어를 사용하여 동시에 실행하는 쓰레드 수를 제한한다.\n➡️ 이러한 접근 방식을 "},{"type":"span","marks":["highlight"],"value":"쓰로틀링(throttling)"},{"type":"span","value":"이라고 부름.\n➡️ "},{"type":"span","marks":["highlight"],"value":"승인 제어(admission control)"},{"type":"span","value":"의 한 형태라고 여김."}]},{"type":"paragraph","children":[{"type":"span","value":"어떤 문제를 병렬로 처리하기 위해 수백 개의 쓰레드를 생성하는 상황을 가정하자."}]},{"type":"paragraph","children":[{"type":"span","value":"이때, 코드의 특정 부분에서 각 쓰레드는 계산의 일부를 수행하기 위해 많은 양의 메모리를 확보함.\n➡️ 이 부분을 메모리 집약 영역(memory-intensive region)이라고 부르자."}]},{"type":"paragraph","children":[{"type":"span","value":"⚠️ "},{"type":"span","marks":["highlight"],"value":"모든 쓰레드가 동시에 메모리 집약 영역에 진입"},{"type":"span","value":"하면 "},{"type":"span","marks":["highlight"],"value":"모든 메모리 할당 요청의 합계가 시스템의 실제 메모리 양을 초과"},{"type":"span","value":"하게 됨.\n➡️ 결과적으로 컴퓨터는 쓰레싱(thrashing)(즉, 디스크에서 페이지 교환)을 시작하고 전체 계산이 매우 느려짐.\n🔖 쓰레싱: 지속적인 페이징 및 페이지 폴트(page fault) 상태로 이어져 CPU 이용률이 급격히 떨어지는 현상"}]},{"type":"paragraph","children":[{"type":"span","value":"✅ 간단한 세마포어가 이 문제를 해결할 수 있음."}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"세마포어의 값을 메모리 집약 영역에 한 번에 진입시키려는 최대 쓰레드 수로 초기화"},{"type":"span","value":"한 후 해당 영역 주위에 "},{"type":"span","marks":["code"],"value":"sem_wait()"},{"type":"span","value":"과 "},{"type":"span","marks":["code"],"value":"sem_post()"},{"type":"span","value":"를 배치하여 세마포어가 자연스럽게 쓰레드 수를 조절할 수 있도록 함."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"8️⃣ 세마포어 구현"}]},{"type":"paragraph","children":[{"type":"span","value":"저수준 동기화 기법인 락과 컨디션 변수를 사용하여 우리만의 세마포어인 \"제마포어(Zemaphore)\"를 만들어 보자."}]},{"code":"typedef struct __Zem_t {\n    int value;\n    pthread_cond_t cond;\n    pthread_mutex_t lock;\n} Zem_t;\n\n// 오직 하나의 쓰레드만 이 문장을 호출할 수 있음\nvoid Zem_init(Zem_t *s, int value) {\n    s−>value = value;\n    Cond_init(&s−>cond);\n    Mutex_init(&s−>lock);\n}\n\nvoid Zem_wait(Zem_t *s) {\n    Mutex_lock(&s−>lock);\n    while (s−>value <= 0)\n        Cond_wait(&s−>cond, &s−>lock);\n    s−>value−−;\n    Mutex_unlock(&s−>lock);\n}\n\nvoid Zem_post(Zem_t *s) {\n    Mutex_lock(&s−>lock);\n    s−>value++;\n    Cond_signal(&s−>cond);\n    Mutex_unlock(&s−>lock);\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"하나의 락과 하나의 컨디션 변수를 사용하고 세마포어의 값을 나타내는 상태 변수 하나를 사용하고 있다."}]},{"type":"paragraph","children":[{"type":"span","value":"💡 Dijkstra가 정의한 세마포어와 여기서 정의한 제마포어 간의 중요한 차이가 있다.\n➡️ 세마포어는 음수 값이 대기 중인 쓰레드의 수를 나타낸다는 것\n➡️ 제마포어에서는 이 값이 0보다 작을 수가 없음."}]},{"type":"paragraph","children":[{"type":"span","value":"이 방식이 구현하기도 쉽고 "},{"type":"span","marks":["highlight"],"value":"현재 Linux에 구현된 방식"},{"type":"span","value":"이기도 함."}]},{"type":"paragraph","children":[{"type":"span","value":"세마포어를 사용하여 락과 컨디션 변수를 만드는 것은 까다로운 문제"}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"📚 참고 문헌"}]},{"type":"paragraph","children":[{"url":"https://pages.cs.wisc.edu/~remzi/OSTEP/Korean/31_threads-sema.pdf","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"Operating Systems: Three Easy Pieces ― 31: Semaphores"}]}]},{"type":"paragraph","children":[{"url":"https://pages.cs.wisc.edu/~remzi/OSTEP/Korean/31_threads-sema.pdf","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"운영체제 아주 쉬운 세 가지 이야기 ― 34: 세마포어"}]}]}]}}}}},"pageContext":{"id":"199715237","locale":"ko-KR"}},"staticQueryHashes":["1034768456","1118752904","2342916782","2757196681","3415878905","3879866231","4195094990"]}