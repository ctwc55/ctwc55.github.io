{"componentChunkName":"component---src-templates-article-jsx","path":"/blog/development/os-concurrency-bugs","result":{"data":{"datoCmsMiscTextString":{"locale":"ko-KR","updatedAtText":"업데이트됨","nextReadText":"관련있는 게시물"},"datoCmsBlogPost":{"locale":"ko-KR","originalId":"200585869","title":"[운영체제][OSTEP] 병행성 관련 오류","seo":{"seoTitle":"[운영체제][OSTEP] 병행성 관련 오류","seoDescription":"일반적인 병행성 관련 오류들을 어떻게 처리하는지 공부해봅니다.","seoImage":{"seoImageUrl":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format"}},"subtitle":"일반적인 병행성 관련 오류들을 어떻게 처리하는지 공부해봅니다.","coverImage":{"coverImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&w=860","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.25&w=860 215w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.5&w=860 430w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&w=860 860w","sizes":"(min-width: 860px) 860px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgLCgoLDhMVDhcNDh0VDxUSGhYdHSIVFhUaKysjGh0oHSEWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLCgUFEBAOEC8oIhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIAAwAGAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAFAQQGAP/EAB0QAAEEAgMAAAAAAAAAAAAAAAEAAgMEESEFEjL/xAAWAQADAAAAAAAAAAAAAAAAAAAAAQP/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwDD1KM1uPLjpIRUI4GZc4aRXH25hTOHqqbth7yDIVIiXI2IQzqCoREhL/RyuQH/2Q=="},"width":860,"height":430}},"meta":{"updatedAt":"2023-09-21T17:11:46.561+09:00","firstPublishedAt":"2023-09-20T12:17:46.893+09:00"},"categoryLink":{"title":"개발 공부","id":"4743072"},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorPictureData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 60px) 60px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgWEQ8LDhgYDhUNDhgNDw8NFxUdGBYfFhUaHysjGikoHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OHBANHDUcIig7NS81NS81MjUvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAFAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAABQYHAv/EAB4QAAICAgMBAQAAAAAAAAAAAAABAgMFBgQRQXEi/8QAFQEBAQAAAAAAAAAAAAAAAAAABAP/xAAaEQACAwEBAAAAAAAAAAAAAAAAAQIDEhMR/9oADAMBAAIRAxEAPwDT8/1LHSK/r67scevSfz99VXBkm/Cva/zKle/pCc/JoRXWsFujxvygcLI1pAXqQTmjONm2RzpceyCwmwxpsbbADWJdBFbeCfe2wXoAGpIL6z//2Q=="},"width":60,"height":60}}},"relatedPosts":[{"id":"199715237","meta":{"updatedAt":"2023-09-20T12:20:48.165+09:00"},"categoryLink":{"title":"개발 공부"},"coverImage":{"gatsbyImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.09&w=860 75w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.18&w=860 150w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860 300w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.7&w=860 600w","sizes":"(min-width: 300px) 300px, 100vw"}},"layout":"constrained","width":300,"height":120},"squaredImage":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.06&fit=crop&fp-x=0.5&fp-y=0.5&w=430 25w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.12&fit=crop&fp-x=0.5&fp-y=0.5&w=430 50w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430 100w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.47&fit=crop&fp-x=0.5&fp-y=0.5&w=430 200w","sizes":"(min-width: 100px) 100px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBhINEBAQCggUDg0IDgcHFh0JFhEYFxUZGCIVFhUaHysjGh0oHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OEg4REC8dFhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAGAMBIgACEQEDEQH/xAAaAAEBAAIDAAAAAAAAAAAAAAAABAUGAQID/8QAHRAAAgICAwEAAAAAAAAAAAAAAAIDBAEREhQVBf/EABYBAQEBAAAAAAAAAAAAAAAAAAADAf/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/ANASs2WLoaraMl1o0O241wSYlSHjgHM9hVAEFr6bKSemzAAeclpnAAH/2Q=="},"width":100,"height":100}},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.11&w=77 8w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 30px) 30px, 100vw"}},"layout":"constrained","width":30,"height":30}}},"subtitle":"세마포어가 무엇인지, 락과 컨디션 변수 대신 세마포어를 사용하는 방법은 무엇인지에 대해 공부해봅니다.","title":"[운영체제][OSTEP] 세마포어"}],"structuredBody":{"blocks":[{"__typename":"DatoCmsArticleBodyImage","id":"200997452","image":{"gatsbyImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1695280268-deadlock.png?auto=format&w=860","srcSet":"https://www.datocms-assets.com/66479/1695280268-deadlock.png?auto=format&dpr=0.25&w=860 215w,\nhttps://www.datocms-assets.com/66479/1695280268-deadlock.png?auto=format&dpr=0.5&w=860 430w,\nhttps://www.datocms-assets.com/66479/1695280268-deadlock.png?auto=format&w=860 860w","sizes":"(min-width: 860px) 860px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAANCAYAAAC3mX7tAAAAAXNSR0IArs4c6QAAAYJJREFUOE+FlMGu4yAMRY8Dgaiqoi7f/3/dSO0iqtQUQrBnUTVPo0LnSGzw1TXGGDGzP8BEA1Ul54z3nnEcWxJUFTNDRI7VIImZZSC0os/nk2maKKUgIozjSFXFVPHeA7CuK957VBXnXO9Amwe0Gdk2VJVlWQghMAwDqsrtdqOUwuVyYZ5nVJVt24gxUmvtJVLf2gUYhgER4Xw+o6qoKiEEfn5+PnQhBMys4/Sim8h7j5mRc8Y5xzRNiAjOuX90zjlSSjjniDF23GDoRgAR4Xq9Mo5jr8nEGEkpkVJiGPp23YoA9n0/XtQ3aq2UUr5qvlb0v+t4U2slhObDPRAze9KZIzOjlIJz7qM3b1SVdV2JMXZnDUjdilSVx+OBmbFtGznnpialxOl0otbKtm0NpxdfeyQi5JyP60spcb/fERFOp9NR5bIsxBiPEWjhgWanRYRhGIgxYmaoKjFGYozs+34kL6UwzzO11pbNr52ZLbx69DFx798BOH6HlqbWehyqgQDpL0C5ywffjezxAAAAAElFTkSuQmCC"},"width":860,"height":430},"alt":"deadlock graph"}}],"links":[],"value":{"schema":"dast","document":{"type":"root","children":[{"type":"heading","level":2,"children":[{"type":"span","value":"1️⃣ 오류의 종류"}]},{"type":"paragraph","children":[{"type":"span","value":"복잡한 병행 프로그램에서 발생하는 병행성 오류들은 어떤 것들이 있을까?\n➡️ 대표적인 오픈소스 프로그램 4개(MySQL, Apache, Mozilla, OpenOffice)를 분석한 결과를 살펴보자."}]},{"type":"paragraph","children":[{"type":"span","value":"105개의 오류 중 대부분(74개)의 오류는 교착 상태와 무관한 오류였음."}]},{"code":"Application     What it does     Non-Deadlock     Deadlock\n──────────────────────────────────────────────────────────\nMySQL           Database Server            14            9\nApache          Web Server                 13            4\nMozilla         Web Browser                41           16\nOpenOffice      Office Suite                6            2\nTotal                                      74           31","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"이제 비 교착 상태와 교착 상태 관련 오류들에 대해 조금 더 자세히 알아보자."}]},{"type":"paragraph","children":[{"type":"span","value":"교착 상태 오류들을 다룰 때에는 예방(prevention), 회피(avoidence), 또는 교착 상태를 해결/관리하는 연구들을 논의해보자."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"2️⃣ 비 교착 상태 오류"}]},{"type":"paragraph","children":[{"type":"span","value":"Lu의 연구 결과에 따르면 "},{"type":"span","marks":["highlight"],"value":"비 교착 상태 오류는 병행성 관련 오류의 과반수"},{"type":"span","value":"를 차지"}]},{"type":"paragraph","children":[{"type":"span","value":"다음에서 비 교착 상태 오류 중 대표적인 두 종류를 살펴보자."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"원자성 위반 오류"}]},{"type":"paragraph","children":[{"type":"span","value":"MySQL에서 발견한 간단한 예시를 살펴보자."}]},{"code":"Thread 1::\nif (thd−>proc_info) {\n  ...\n  fputs(thd−>proc_info, ...) ;\n  ...\n}\n\nThread 2::\nthd−>proc_info = NULL;","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"thd"},{"type":"span","value":" 자료 구조의 "},{"type":"span","marks":["code"],"value":"proc_info"},{"type":"span","value":" 필드를 두 개의 다른 쓰레드가 접근하고 있다."}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Thread 1: "},{"type":"span","marks":["code"],"value":"chd->proc_info"},{"type":"span","value":" 값이 "},{"type":"span","marks":["code"],"value":"NULL"},{"type":"span","value":"인지 검사하고 값을 출력"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Thread 2: "},{"type":"span","marks":["code"],"value":"chd->proc_info"},{"type":"span","value":" 값을 "},{"type":"span","marks":["code"],"value":"NULL"},{"type":"span","value":"로  설정"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"Thread 1이 검사 완료 후 "},{"type":"span","marks":["code"],"value":"fputs"},{"type":"span","value":"를 호출하기 전 인터럽트로 인해 Thread 2가 실행되는 경우\n➡️ 🚫 "},{"type":"span","marks":["code"],"value":"fputs"},{"type":"span","value":" 함수가 "},{"type":"span","marks":["code"],"value":"NULL"},{"type":"span","value":" 포인터 역참조를 하게 되어 프로그램이 크래시됨."}]},{"type":"paragraph","children":[{"type":"span","value":"Lu 등이 기술한 원자성 위반에 대한 정의는 다음과 같다."}]},{"code":"\"다수의 메모리 참조 연산들 간에 있어 예상했던\n직렬성(serializability)이 보장되지 않았다.\"","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 즉, 코드의 일부에 원자성이 요구되었으나, 실행 시 그 원자성이 위반되었다."}]},{"type":"paragraph","children":[{"type":"span","value":"그렇다면 코드를 어떻게 수정하면 될까?\n➡️ 🔒 "},{"type":"span","marks":["highlight"],"value":"락을 추가"},{"type":"span","value":"하여 어느 쓰레드든 "},{"type":"span","marks":["code"],"value":"proc_info"},{"type":"span","value":" 필드 접근 시, "},{"type":"span","marks":["code"],"value":"proc_info_lock"},{"type":"span","value":" 이라는 락 변수를 획득하도록 함."}]},{"code":"pthread_mutex_t proc_info_lock = PTHREAD_MUTEX_INITIALIZER;\n\nThread 1::\npthread_mutex_lock(&proc_info_lock);\nif (thd−>proc_info) {\n  ...\n  fputs(thd−>proc_info, ...) ;\n  ...\n}\npthread_mutex_unlock(&proc_info_lock);\n\nThread 2::\npthread_mutex_lock(&proc_info_lock);\nthd−>proc_info = NULL;\npthread_mutex_unlock(&proc_info_lock);","type":"code","language":"c"},{"type":"heading","level":3,"children":[{"type":"span","value":"순서 위반 오류"}]},{"type":"paragraph","children":[{"type":"span","value":"다음 예시를 살펴보자."}]},{"code":"Thread 1::\nvoid init() {\n  ...\n  mThread = PR_CreateThread(mMain, ...) ;\n  ...\n}\n\nThread 2::\nvoid mMain (...) {\n  ...\n  mState = mThread−>State;\n  ...\n}","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"위 코드에서 Thread 2는 "},{"type":"span","marks":["code"],"value":"mThread"},{"type":"span","value":" 변수가 이미 초기화되고 "},{"type":"span","marks":["code"],"value":"NULL"},{"type":"span","value":"이 아닌 것을 가정하고 있다."}]},{"type":"paragraph","children":[{"type":"span","value":"Thread 1이 먼저 실행되지 않는 경우\n➡️ 🚫 Thread 2는 "},{"type":"span","marks":["code"],"value":"NULL"},{"type":"span","value":" 포인터를 사용하기 때문에 크래시됨."}]},{"type":"paragraph","children":[{"type":"span","value":"순서 위반의 정의는 다음과 같다."}]},{"code":"\"두 개의(그룹의) 메모리 참조 간의 순서가 바뀌었다.\"","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 즉, A가 항상 B보다 먼저 실행되어야 하지만 실행 중에 그 순서가 지켜지지 않았다."}]},{"type":"paragraph","children":[{"type":"span","value":"그렇다면 코드를 어떻게 수정하면 될까?\n➡️ 🚦 "},{"type":"span","marks":["highlight"],"value":"컨디션 변수(또는 세마포어)를 사용"},{"type":"span","value":"하여 순서를 강제한다."}]},{"code":"pthread_mutex_t mtLock = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t mtCond = PTHREAD_COND_INITIALIZER;\nint mtInit = 0;\n\nThread 1::\nvoid init() {\n  ...\n  mThread = PR_CreateThread(mMain, ...) ;\n  \n  // 쓰레드가 생성되었다는 것을 알리는 시그널 전달...\n  pthread_mutex_lock(&mtLock);\n  mtInit = 1;\n  pthread_cond_signal(&mtCond);\n  pthread_mutex_unlock(&mtLock);\n  ...\n}\n\nThread 2::\nvoid mMain (...) {\n  ...\n  // 쓰레드가 초기화되기를 대기...\n  pthread_mutex_lock(&mtLock);\n  while (mtInit == 0)\n    pthread_cond_wait(&mtCond, &mtLock);\n  pthread_mutex_unlock(&mtLock);\n  \n  mState = mThread−>State;\n  ...\n}","type":"code","language":"cpp"},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"3️⃣ 교착 상태 오류"}]},{"type":"paragraph","children":[{"type":"span","value":"복잡한 락 프로토콜을 사용하는 다수의 병행 시스템에서 교착 상태("},{"type":"span","marks":["code"],"value":"deadlock"},{"type":"span","value":")라는 고전적 문제가 발생"}]},{"type":"paragraph","children":[{"type":"span","value":"다음 그림과 같이 그래프에서 "},{"type":"span","marks":["highlight"],"value":"사이클(cycle)의 존재는 교착 상태 발생 가능성을 의미"},{"type":"span","value":"한다."}]},{"item":"200997452","type":"block"},{"type":"paragraph","children":[{"type":"span","value":"그렇다면 교착 상태는 왜 발생하는 것일까?"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"코드의 증가에 따른 구성 요소 간 "},{"type":"span","marks":["highlight"],"value":"복잡한 의존성"},{"type":"span","value":" 발생"}]},{"type":"paragraph","children":[{"type":"span","value":"➡️ 대형 시스템의 락 사용 전략의 설계는 매우 신중해야 함."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"캡슐화(encapsulation)"},{"type":"span","value":"의 성질 때문"}]},{"type":"paragraph","children":[{"type":"span","value":"➡️ 모듈화와 락은 잘 조화되지 않음."}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"위의 상황을 예시를 통해 조금 더 이해해보자."}]},{"type":"paragraph","children":[{"type":"span","value":"[복잡한 의존성]"}]},{"code":"< 운영체제 >\n1. 가상 메모리 시스템이 디스크 블럭을 가져오기 위해 파일 시스템 접근\n2. 파일 시스템은 디스크 블럭을 메모리에 탑재하기 위해 메모리 페이지 확보\n3. 이를 위해 파일 시스템은 가상 메모리 시스템에 접근","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"[캡슐화]"}]},{"code":"Vector v1, v2;\nv1.AddAll(v2); // 어떤 쓰레드가 v2.AddAll(v1)을 거의 동시에 호출하는 경우","type":"code","language":"java"},{"type":"heading","level":3,"children":[{"type":"span","value":"교착 상태 발생 조건"}]},{"type":"paragraph","children":[{"type":"span","value":"교착 상태가 발생하기 위해서는 "},{"type":"span","marks":["highlight"],"value":"네 가지 조건이 충족"},{"type":"span","value":"되어야 함."}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"상호 배제(Mutual Exclusion)"}]},{"type":"paragraph","children":[{"type":"span","value":"➡️ 쓰레드가 자신이 필요로 하는 자원에 대한 독자적인 제어권을 주장"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"점유 및 대기(Hold-and-wait)"}]},{"type":"paragraph","children":[{"type":"span","value":"➡️ 쓰레드가 자신에게 할당된 자원을 점유한 채로 다른 자원을 대기"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"비 선점(No preemption)"}]},{"type":"paragraph","children":[{"type":"span","value":"➡️ 자원(락)을 점유하고 있는 쓰레드로부터 자원을 강제적으로 빼앗을 수 없음."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"환형 대기(Circular wait)"}]},{"type":"paragraph","children":[{"type":"span","value":"➡️ 각 쓰레드는 다음 쓰레드가 요청한 하나 또는 그 이상의 자원(락)을 갖고 있는 쓰레드들의 순환 고리가 있음."}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"위 네 조건 중 하나라도 만족시키지 않는다면 교착 상태는 발생하지 않음."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"교착 상태의 예방 - 순환 대기(Circular Wait)"}]},{"type":"paragraph","children":[{"type":"span","value":"가장 간단한 방법: 락 획득을 하는 "},{"type":"span","marks":["highlight"],"value":"전체 순서(total ordering)"},{"type":"span","value":"를 정하기"}]},{"type":"paragraph","children":[{"type":"span","value":"복잡한 시스템(두 개 이상의 락 존재)의 경우 전체 락의 요청 순서를 정의하는 것이 어렵거나 불필요할 수 있음.\n➡️ "},{"type":"span","marks":["highlight"],"value":"부분 순서(partial ordering)"},{"type":"span","value":"를 제공하는 것이 락 획득 구조를 만드는 데 유용"}]},{"type":"paragraph","children":[{"type":"span","value":"전체 또는 부분 순서를 제공하기 위해서는 세심하게 락 획득 전략을 설계해야 함."}]},{"type":"paragraph","children":[{"type":"span","value":"순서라는 것은 단순히 관례이므로 숙련되지 않은 개발자들이 이 관례를 무시하고 코드를 개발할 경우, 교착 상태가 발생할 수 있음."}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"락의 순서를 정의하기 위해서는 코드와 다양한 루틴 간의 상호 호출 관계를 이해"},{"type":"span","value":"해야 함."}]},{"type":"paragraph","children":[{"type":"span","value":"💡 락 주소를 사용하여 락 요청 순서 강제하기"}]},{"code":"do_something(mutex_t *m1, mutex_t *m2)\n// 와 같이 호출되는 함수가 있을 때\n\n// 한 쓰레드가 다음과 같이 호출\ndo_something(L1, L2)\n// 다른 쓰레드가 다음과 같이 호출\ndo_something(L2, L1)\n// 이 경우 교착 상태가 될 수 있음.","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"위와 같은 경우를 피하기 위해 주소의 값을 사용하여 락 획득의 순서를 정하기도 함.\n➡️ "},{"type":"span","marks":["code"],"value":"do_something()"},{"type":"span","value":" 문장에 인자를 어떤 순서로 넣어 호출하든 락의 획득 순서는 동일"}]},{"code":"if (m1 > m2) { // 락을 주소의 내림차순으로 획득하기\n  pthread_mutex_lock(m1);\n  pthread_mutex_lock(m2);\n} else {\n  pthread_mutex_lock(m2);\n  pthread_mutex_lock(m1);\n}\n// 코드는 m1 != m2를 가정함(서로 같은 락이 아님)","type":"code","language":"cpp"},{"type":"paragraph","children":[{"type":"span","value":"이 간단한 기법을 사용하여 개발자는 멀티 락 획득 상황에서 간단하고 효율적으로 교착 상태를 방지할 수 있음."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"교착 상태의 예방 - 점유 및 대기(Hold-and-Wait)"}]},{"type":"paragraph","children":[{"type":"span","value":"💡 원자적으로 모든 락을 단번에 획득하도록 하면 예방할 수 있음."}]},{"code":"lock(prevention);\nlock(L1);\nlock(L2);\n...\nunlock(prevention);","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"위 코드에서는 제일 먼저 prevention 락을 획득하여, "},{"type":"span","marks":["highlight"],"value":"락을 획득하는 과정 중에 쓰레드의 문맥 교환이 발생하는 것을 방지"},{"type":"span","value":"\n➡️ 교착 상태의 발생 가능성을 차단"}]},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 이 해법은 문제점이 많음."}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"필요한 락들을 정확히 파악해야 함."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"그 락들을 미리 획득해야 함."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"락이 실제 필요할 때 요청하는 것이 아니라 미리 모든 락을 획득하므로 병행성이 저하됨."}]}]}]},{"type":"heading","level":3,"children":[{"type":"span","value":"교착 상태의 예방 - 비선점(No Preemption)"}]},{"type":"paragraph","children":[{"type":"span","value":"일반적으로 락을 해제하기 전까지는 락을 보유하고 있는 것으로 봄.\n➡️ 락을 이미 보유한 채로 다른 락을 대기하므로 여러 락 획득 시 문제의 소지가 있음.\n➡️ 많은 쓰레드 라이브러리들은 이러한 상황을 피할 수 있도록 유연한 인터페이스 집합 제공"}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"trylock()"},{"type":"span","value":" 루틴"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"락이 획득한 경우: 락 획득"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"락이 점유된 경우: -1 리턴"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"이를 이용하면 교착 상태 가능성이 없고 획득 순서에 영향을 받지 않는 락 획득 방법을 만들 수 있음."}]},{"code":"top:\n  lock(L1);\n  if (trylock(L2) == −1) {\n    unlock(L1);\n    goto top;\n  }","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"⚠️ "},{"type":"span","marks":["highlight"],"value":"무한반복(livelock)"},{"type":"span","value":" 문제가 발생할 수 있음."}]},{"type":"paragraph","children":[{"type":"span","value":""}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"📚 참고 문헌"}]},{"type":"paragraph","children":[{"url":"https://pages.cs.wisc.edu/~remzi/OSTEP/threads-bugs.pdf","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"Operating Systems: Three Easy Pieces ― 32: Common Concurrency Problems"}]}]},{"type":"paragraph","children":[{"url":"https://pages.cs.wisc.edu/~remzi/OSTEP/Korean/32_threads-bugs.pdf","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"운영체제 아주 쉬운 세 가지 이야기 ― 35: 병행성 관련 오류"}]}]}]}}}}},"pageContext":{"id":"200585869","locale":"ko-KR"}},"staticQueryHashes":["1034768456","1118752904","2342916782","2757196681","3415878905","3879866231","4195094990"]}