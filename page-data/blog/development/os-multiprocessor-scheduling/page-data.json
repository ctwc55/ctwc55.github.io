{
    "componentChunkName": "component---src-templates-article-jsx",
    "path": "/blog/development/os-multiprocessor-scheduling",
    "result": {"data":{"datoCmsMiscTextString":{"locale":"ko-KR","updatedAtText":"업데이트됨","nextReadText":"관련있는 게시물"},"datoCmsBlogPost":{"locale":"ko-KR","originalId":"144619099","title":"[운영체제][OSTEP] 멀티프로세서 스케줄링","seo":{"seoTitle":"[운영체제][OSTEP] 멀티프로세서 스케줄링","seoDescription":"운영체제가 작업을 여러 CPU에 스케줄하는 방법에 대해 공부해봅니다.","seoImage":{"seoImageUrl":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format"}},"subtitle":"운영체제가 작업을 여러 CPU에 스케줄하는 방법에 대해 공부해봅니다.","coverImage":{"coverImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&w=860","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.25&w=860 215w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.5&w=860 430w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&w=860 860w","sizes":"(min-width: 860px) 860px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgLCgoLDhMVDhcNDh0VDxUSGhYdHSIVFhUaKysjGh0oHSEWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLCgUFEBAOEC8oIhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIAAwAGAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAFAQQGAP/EAB0QAAEEAgMAAAAAAAAAAAAAAAEAAgMEESEFEjL/xAAWAQADAAAAAAAAAAAAAAAAAAAAAQP/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwDD1KM1uPLjpIRUI4GZc4aRXH25hTOHqqbth7yDIVIiXI2IQzqCoREhL/RyuQH/2Q=="},"width":860,"height":430}},"meta":{"updatedAt":"2023-07-04T20:55:22.636+09:00","firstPublishedAt":"2023-07-01T20:22:36.301+09:00"},"categoryLink":{"title":"개발 공부","id":"4743072"},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorPictureData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 60px) 60px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgWEQ8LDhgYDhUNDhgNDw8NFxUdGBYfFhUaHysjGikoHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OHBANHDUcIig7NS81NS81MjUvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAFAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAABQYHAv/EAB4QAAICAgMBAQAAAAAAAAAAAAABAgMFBgQRQXEi/8QAFQEBAQAAAAAAAAAAAAAAAAAABAP/xAAaEQACAwEBAAAAAAAAAAAAAAAAAQIDEhMR/9oADAMBAAIRAxEAPwDT8/1LHSK/r67scevSfz99VXBkm/Cva/zKle/pCc/JoRXWsFujxvygcLI1pAXqQTmjONm2RzpceyCwmwxpsbbADWJdBFbeCfe2wXoAGpIL6z//2Q=="},"width":60,"height":60}}},"relatedPosts":[{"id":"143121405","meta":{"updatedAt":"2023-07-04T14:16:23.873+09:00"},"categoryLink":{"title":"개발 공부"},"coverImage":{"gatsbyImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.09&w=860 75w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.18&w=860 150w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860 300w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.7&w=860 600w","sizes":"(min-width: 300px) 300px, 100vw"}},"layout":"constrained","width":300,"height":120},"squaredImage":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.06&fit=crop&fp-x=0.5&fp-y=0.5&w=430 25w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.12&fit=crop&fp-x=0.5&fp-y=0.5&w=430 50w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430 100w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.47&fit=crop&fp-x=0.5&fp-y=0.5&w=430 200w","sizes":"(min-width: 100px) 100px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBhINEBAQCggUDg0IDgcHFh0JFhEYFxUZGCIVFhUaHysjGh0oHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OEg4REC8dFhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAGAMBIgACEQEDEQH/xAAaAAEBAAIDAAAAAAAAAAAAAAAABAUGAQID/8QAHRAAAgICAwEAAAAAAAAAAAAAAAIDBAEREhQVBf/EABYBAQEBAAAAAAAAAAAAAAAAAAADAf/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/ANASs2WLoaraMl1o0O241wSYlSHjgHM9hVAEFr6bKSemzAAeclpnAAH/2Q=="},"width":100,"height":100}},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.11&w=77 8w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 30px) 30px, 100vw"}},"layout":"constrained","width":30,"height":30}}},"subtitle":"특정 비율로 CPU를 배분하는 스케줄링 방법에 대해 공부해봅니다.","title":"[운영체제][OSTEP] 스케줄링: 비례 배분"}],"structuredBody":{"blocks":[],"links":[],"value":{"schema":"dast","document":{"type":"root","children":[{"type":"heading","level":2,"children":[{"type":"span","value":"🚪 들어가며"}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"멀티코어(multicore) 프로세서"},{"type":"span","value":": 여러 개의 CPU 코어가 하나의 칩에 내장된 프로세서"}]},{"type":"paragraph","children":[{"type":"span","value":"다중 CPU 시대가 오면서 발생한 문제\n➡️ 전통적인 응용 프로그램은 오직 하나의 CPU만 사용\n➡️ 문제 해결을 위해 응용 프로그램을 "},{"type":"span","marks":["highlight"],"value":"병렬(parallel)"},{"type":"span","value":"로 실행되도록 재작성"}]},{"type":"paragraph","children":[{"type":"span","value":"이를 위해 보통 "},{"type":"span","marks":["highlight"],"value":"쓰레드"},{"type":"span","value":"를 이용함."}]},{"type":"paragraph","children":[{"type":"span","value":"멀티 쓰레드 응용 프로그램 ➡️ 작업을 여러 CPU에 할당\n➡️ 더 많은 수의 CPU = 더 빠른 실행"}]},{"type":"paragraph","children":[{"type":"span","value":"따라서 멀티프로세서 스케줄링 방법에 대하여 고민해보아야 함."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"1️⃣ 배경: 멀티프로세서 구조"}]},{"type":"heading","level":3,"children":[{"type":"span","value":"캐시 사용 방식의 차이(단일 CPU 하드웨어 vs. 멀티 CPU 하드웨어)"}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"캐시"},{"type":"span","value":": 메인 메모리에서 "},{"type":"span","marks":["highlight"],"value":"자주 사용되는 데이터"},{"type":"span","value":"의 복사본을 저장하는 작고 빠른 메모리"}]},{"type":"paragraph","children":[{"type":"span","value":"단일 CPU 시스템에는 "},{"type":"span","marks":["highlight"],"value":"하드웨어 캐시"},{"type":"span","value":" 계층이 존재 ➡️ 프로그램의 빠른 실행을 위해"}]},{"type":"paragraph","children":[{"type":"span","value":"예를 들어, "},{"type":"span","marks":["code"],"value":"load"},{"type":"span","value":" 명령어를 수행하는 프로그램과 하나의 CPU만 있는 간단한 시스템을 가정\nCPU는 작은 크기의 캐시(64KB)와 큰 메인 메모리를 갖고 있음. 다음을 통해 캐시의 동작을 살펴보자."}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"프로그램이 처음 "},{"type":"span","marks":["code"],"value":"load"},{"type":"span","value":" 명령어를 실행"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"데이터가 메인 메모리에 존재하므로 데이터를 가져오는 데 긴 시간 소모(약 수십/수백 나노 초)"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"데이터가 다시 사용될 것으로 예상되는 경우 프로세스는 해당 데이터의 복사본을 CPU 캐시에 저장"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"프로그램이 다시 같은 데이터를 가져오려고 시도"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"CPU는 해당 데이터가 캐시에 존재하는지 검사"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"데이터가 캐시에 존재하므로 훨씬 빨리 접근(수 나노 초)되고 프로그램은 빨리 실행"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"캐시는 "},{"type":"span","marks":["highlight"],"value":"지역성(locality)"},{"type":"span","value":"에 기반"}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"시간 지역성(temporal locality)"},{"type":"span","value":": 데이터가 한 번 접근되면 가까운 미래에 다시 접근되기 쉽다는 것\n예시) 반복문 안에 있는 변수"}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"공간 지역성(spatial locality)"},{"type":"span","value":": 프로그램이 주소 x의 데이터를 접근하면 x 주변의 데이터가 접근되기 쉽다는 것\n예시) 배열에 차례대로 접근"}]},{"type":"paragraph","children":[{"type":"span","value":"하드웨어 시스템은 캐시에 어떤 데이터를 저장할지 비교적 정확하게 추측할 수 있고, 캐시는 잘 작동함."}]},{"type":"paragraph","children":[{"type":"span","value":"다음과 같이 "},{"type":"span","marks":["highlight"],"value":"하나의 시스템에 여러 프로세스가 존재하고 하나의 공유 메인 메모리가 있는 경우"},{"type":"span","value":"를 살펴보자."}]},{"code":"                ┌───[Cache|CPU1]\n[Main memory]───┤\n                └───[Cache|CPU2]","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"CPU1에서 실행 중인 프로그램이 주소 A의 D 값을 읽는다고 가정하자. 이때, "},{"type":"span","marks":["underline"],"value":"어떤 문제가 발생할 수 있는지"},{"type":"span","value":" 다음 과정을 통해 살펴보자."}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"데이터가 CPU1 캐시에 값 D가 존재하지 않음."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"시스템은 메인 메모리로부터 데이터를 가져오고 값 D를 얻음."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"프로그램이 주소 A의 값을 변경"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"변경은 캐시에 존재하는 값만 D*으로 변경("},{"type":"span","marks":["highlight"],"value":"메모리에 데이터를 쓰는 것은 시간이 오래 걸리므로 메인 메모리에 기록하는 것은 보통 나중에 함"},{"type":"span","value":")함."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"운영체제가 프로그램의 실행을 중단하고 CPU2로 이동하기로 결정"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"CPU2에서 실행하는 프로그램이 주소 A의 값을 다시 읽음."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"CPU2의 캐시에는 해당 데이터가 존재하지 않으므로 시스템이 메인 메모리에서 데이터를 가져옴."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["underline"],"value":"이때 D*이 아니라 갱신 전 값인 D를 가져옴!"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"위와 같은 문제를 "},{"type":"span","marks":["highlight"],"value":"캐시 일관성 문제(cache coherence)"},{"type":"span","value":"라고 부른다.\n➡️ 이에 대한 기본적인 해결책은 하드웨어에 의해 제공"}]},{"type":"paragraph","children":[{"type":"span","value":"하드웨어는 메모리 주소를 계속 감시 ➡️ 항상 \"제대로\"된 상황만 발생하도록 시스템을 관리"}]},{"type":"paragraph","children":[{"type":"span","value":"특히, 여러 개의 프로세스들이 하나의 메모리에 갱신할 때에는 항상 공유되도록 함."}]},{"type":"paragraph","children":[{"type":"span","value":"버스 기반 시스템에서는 "},{"type":"span","marks":["highlight"],"value":"버스 스누핑(bus snooping)"},{"type":"span","value":"이라는 오래된 기법을 사용\n➡️ 캐시는 자신과 메모리를 연결하는 버스의 통신 상황을 계속 모니터링\n➡️ 캐시 데이터에 대한 변경이 발생하면, 다음 중 하나의 조치를 취함.\n[조치 1: "},{"type":"span","marks":["highlight"],"value":"무효화(invalidate)"},{"type":"span","value":"] 자신의 캐시에서 복사본을 삭제\n[조치 2: "},{"type":"span","marks":["highlight"],"value":"갱신(update)"},{"type":"span","value":"] 새로운 값을 캐시에 기록"}]},{"type":"paragraph","children":[{"type":"span","value":"나중 쓰기(write-back) 캐시는 메인 메모리에 쓰기 연산이 지연되기 때문에 캐시 일관성 문제를 훨씬 복잡하게 만듦."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"2️⃣ 동기화를 잊지 말기"}]},{"type":"paragraph","children":[{"type":"span","value":"일관성 유지에 대한 모든 일을 캐시가 담당한다면, 프로그램 또는 운영체제는 공유 데이터를 접근할 때 걱정할 필요가 있을까? ➡️ YES(추후 책의 \"병행성\"에 관한 부분에서 자세히 설명)"}]},{"type":"paragraph","children":[{"type":"span","value":"CPU들이 동일한 데이터 또는 구조체에 접근 시(특히, 갱신 시)\n➡️ 올바른 연산 결과를 보장하기 위해 락과 같이 상호 배제를 보장하는 동기화 기법이 많이 사용됨."}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"락-프리(lock-free)"},{"type":"span","value":" 데이터 구조 등의 다른 방식은 특별한 경우에만 사용함(복잡함)."}]},{"type":"paragraph","children":[{"type":"span","value":"예를 들어, 여러 CPU가 동시에 사용하는 공유 큐가 있다고 가정"}]},{"type":"paragraph","children":[{"type":"span","value":"캐시의 일관성을 보장하는 프로토콜이 존재\n➡️ 락 없이는 항목의 추가나 삭제가 제대로 동작하지 않음.\n➡️ "},{"type":"span","marks":["highlight"],"value":"구조체를 원자적으로 갱신하기 위해서는 락이 필요"}]},{"type":"paragraph","children":[{"type":"span","value":"다음은 연결 리스트에서 원소 하나를 삭제하는 코드이다."}]},{"code":"typedef struct __Node_t {\n  int value;\n  struct __Node_t *next;\n} Node_t;\n\nint List_Pop() {\n  Node_t *tmp = head; // 이전 head를 기억\n  int value = head−>value; // 값도 기억\n  head = head−>next; // head를 다음 포인터로 이동 \n  free(tmp); // 이전 head 해제\n  return value; // head의 값을 반환\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"두 CPU의 쓰레드가 동시에 이 루틴으로 진입한다고 가정하자. 이때, "},{"type":"span","marks":["underline"],"value":"어떤 문제가 발생할 수 있는지"},{"type":"span","value":" 다음 과정을 통해 살펴보자."}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"쓰레드 1이 첫 번째 행을 실행하면 "},{"type":"span","marks":["code"],"value":"head"},{"type":"span","value":"의 현재 값을 tmp에 저장한다."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"그 후 쓰레드 2가 첫 번째 행을 실행하면 "},{"type":"span","marks":["code"],"value":"head"},{"type":"span","value":"의 같은 값을 tmp에 저장한다."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"tmp는 스택에 할당된다. (각 쓰레드는 자신만의 스택을 가지고 있음.)"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"각 쓰레드는 동일한 헤드 원소를 제거하려고 한다."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"제대로 된 상황에서 각 쓰레드는 리스트의 첫 번째 원소를 한 번씩 제거해야 한다."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"그러나 "},{"type":"span","marks":["underline"],"value":"헤드 원소를 두 번 삭제하고 같은 데이터 값을 두 번 반환하는 등의 문제를 야기"},{"type":"span","value":"한다. "}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"이러한 문제에 대한 해결책은 "},{"type":"span","marks":["highlight"],"value":"락(lock)"},{"type":"span","value":"을 사용하여 올바르게 동작하도록 만드는 것이다."}]},{"type":"paragraph","children":[{"type":"span","value":"위의 경우 간단한 mutex를 할당하고 루틴의 시작과 마지막에 관련 코드를 추가하여 문제를 해결할 수 있다.\n➡️ 이러한 접근 방식은 성능 측면을 비롯한 문제들이 있음.\n➡️ "},{"type":"span","marks":["highlight"],"value":"CPU의 개수가 증가할수록 동기화된 자료 구조에 접근하는 연산은 매우 느리게 됨."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"3️⃣ 마지막 문제점: 캐시 친화성"}]},{"type":"paragraph","children":[{"type":"span","value":"멀티프로세서 캐시 스케줄러의 마지막 문제점은 "},{"type":"span","marks":["highlight"],"value":"캐시 친화성(cache affinity)"},{"type":"span","value":"이다."}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"CPU에서 실행"},{"type":"span","value":"될 때 "},{"type":"span","marks":["highlight"],"value":"프로세스는 해당 CPU 캐시와 TLB(Translation Lookaside Buffer, 변환 색인 버퍼)에 상당한 양의 상태 정보"},{"type":"span","value":"를 올려 놓게 된다.\n➡️ 다음 번에 프로세스가 실행될 때 동일한 CPU에서 실행되는 것이 유리\n➡️ 해당 CPU 캐시에 일부 정보가 이미 존재하므로 더 빨리 실행"}]},{"type":"paragraph","children":[{"type":"span","value":"하드웨어의 "},{"type":"span","marks":["highlight"],"value":"캐시 일관성 프로토콜"},{"type":"span","value":" ➡️ 다른 CPU에서 실행되더라도 프로그램이 제대로 실행됨."}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"멀티프로세서 스케줄러는 스케줄링 결정을 내릴 때 캐시 친화성을 고려"},{"type":"span","value":"해야 함.\n➡️ "},{"type":"span","marks":["highlight"],"value":"가능한 한 프로세스를 동일한 CPU에서 실행"},{"type":"span","value":"하는 방향으로 결정"}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"4️⃣ 단일 큐 스케줄링"}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"단일 큐 멀티프로세서 스케줄링(single queue multiprocessor scheduling, SQMS)"}]},{"type":"paragraph","children":[{"type":"span","value":"단일 프로세서 스케줄링의 기본 프레임워크를 그대로 사용하는 것"}]},{"type":"heading","level":3,"children":[{"type":"span","value":"장점"}]},{"type":"paragraph","children":[{"type":"span","value":"단순함: 기존 정책을 다수 CPU에서 동작하도록 하는 데 많은 변경이 필요하지 않음.\n➡️ CPU가 2개라면 실행할 작업 두 개를 선택"}]},{"type":"heading","level":3,"children":[{"type":"span","value":"단점"}]},{"type":"paragraph","children":[{"type":"span","value":"1️⃣ "},{"type":"span","marks":["highlight"],"value":"확장성(scalability)"},{"type":"span","value":" 결여"}]},{"type":"paragraph","children":[{"type":"span","value":"스케줄러가 다수의 CPU에서 제대로 동작하게 하기 위해 코드에 일정 형태의 "},{"type":"span","marks":["highlight"],"value":"락"},{"type":"span","value":"을 삽입\n➡️ 락은 SQMS 코드가 실행시킬 다음 작업을 찾기 위해 단일 큐에 접근할 때 올바른 결과가 나오도록 함."}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"락은 성능을 크게 저하시킬 수 있음.(동기화 오버헤드)"},{"type":"span","value":" ➡️ 시스템의 CPU 개수가 증가할수록 심해짐."}]},{"type":"paragraph","children":[{"type":"span","value":"단일 락에 대한 경쟁이 증가할수록 시스템은 락에 점점 더 많은 시간을 소모"}]},{"type":"paragraph","children":[{"type":"span","value":"2️⃣ "},{"type":"span","marks":["highlight"],"value":"캐시 친화성"}]},{"type":"paragraph","children":[{"type":"span","value":"실행할 5개의 작업과 4개의 프로세서가 있다고 가정하자. 다음은 이때의 스케줄링 큐의 모습이다."}]},{"code":"Queue → [A] → [B] → [C] → [D] → [E] → NULL","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"다음은 작업들이 타임 슬라이스 동안 반복되며 실행될 때 작업 스케줄의 모습이다."}]},{"code":"CPU 0 | [A][E][D][C][B] ...\nCPU 1 | [B][A][E][D][C] ...\nCPU 2 | [C][B][A][E][D] ...\nCPU 3 | [D][C][B][A][E] ...\n        시간의 흐름 →","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"각 CPU는 공유 큐에서 다음 작업을 선택하므로 "},{"type":"span","marks":["underline"],"value":"각 작업은 CPU를 옮겨 다니게 됨."},{"type":"span","value":"\n➡️ "},{"type":"span","marks":["highlight"],"value":"캐시 친화성 관점에서 보면 잘못된 선택"}]},{"type":"paragraph","children":[{"type":"span","value":"이 문제의 해결을 위해 "},{"type":"span","marks":["highlight"],"value":"대부분의 SQMS 스케줄러는 가능한 한 프로세스가 동일한 CPU에서 재실행될 수 있도록 시도\n"},{"type":"span","value":"➡️ 특정 작업들에 대한 캐시 친화성을 고려하여 스케줄링 & 다른 작업들은 오버헤드 균등을 위해 분산시키는 정책"}]},{"type":"paragraph","children":[{"type":"span","value":"다음의 예시를 통해 이를 살펴보자."}]},{"code":"CPU 0 | [A][E][A][A][A] ...\nCPU 1 | [B][B][E][B][B] ...\nCPU 2 | [C][C][C][E][C] ...\nCPU 3 | [D][D][D][D][E] ...\n        시간의 흐름 →","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"E만 프로세서를 "},{"type":"span","marks":["highlight"],"value":"이동"},{"type":"span","value":"하며 실행되고 있으며, 첫 번째 작업 스케줄과 비교하여 대부분의 작업에게 친화성을 보존하고 있다."}]},{"type":"paragraph","children":[{"type":"span","value":"추후 다른 작업을 이동시킴으로써 친화성에 대한 형평성도 추구할 수 있음. ➡️ 구현이 복잡해질 수 있음."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"5️⃣ 멀티 큐 스케줄링"}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"멀티 큐 멀티프로세서 스케줄링(multi-queue multiprocessor scheduling, MQMS)"}]},{"type":"paragraph","children":[{"type":"span","value":"단일 큐 스케줄러로 인한 문제 ➡️ 일부 시스템은 CPU마다 큐를 하나씩 두는 등 멀티 큐를 마련해 둠."}]},{"type":"paragraph","children":[{"type":"span","value":"MQMS에서 "},{"type":"span","marks":["highlight"],"value":"기본적인 스케줄링 프레임워크는 여러 개의 스케줄링 큐로 구성"},{"type":"span","value":"\n➡️ 각 큐는 RR 등 특정 스케줄링 규칙을 따름"}]},{"type":"paragraph","children":[{"type":"span","value":"작업이 시스템에 들어가면 하나의 스케줄링 큐에 배치: 무작위 또는 비교적으로 작업이 적은 큐 등"}]},{"type":"paragraph","children":[{"type":"span","value":"그 후 "},{"type":"span","marks":["highlight"],"value":"각각의 큐에 담긴 작업들끼리 독립적으로 스케줄"},{"type":"span","value":"\n➡️ "},{"type":"span","marks":["highlight"],"value":"단일 큐 방식의 정보 공유 및 동기화 문제를 피할 수 있음."}]},{"type":"paragraph","children":[{"type":"span","value":"다음의 예시를 통해 이를 더 알아보자."}]},{"type":"paragraph","children":[{"type":"span","value":"2개의 CPU와 4 개의 작업이 시스템에 존재한다고 가정하자. CPU마다 스케줄링 큐를 하나씩 가지고 있으므로 다음과 같이 작업이 배치되었다고 하자."}]},{"code":"Q0 → [A] → [C]\nQ1 → [B] → [D]","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"RR의 경우 다음과 같은 스케줄이 생성될 수 있다."}]},{"code":"CPU 0 | [A][A][C][C][A][A][C][C][A][A][C][C] ...\nCPU 1 | [B][B][D][D][B][B][D][D][B][B][D][D] ...\n        시간의 흐름 →","type":"code"},{"type":"heading","level":3,"children":[{"type":"span","value":"장점"}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"SQMS에 비해 확장성이 좋다."}]},{"type":"paragraph","children":[{"type":"span","value":"CPU 개수 증가 ➡️ 큐의 개수 증가: 락과 캐시 경합(cache contention)은 더 이상 문제가 되지 않음."}]},{"type":"paragraph","children":[{"type":"span","value":"작업이 같은 CPU에서 계속 실행 = 캐시에 저장된 내용을 재사용 ➡️ MQMS는 본질적으로 "},{"type":"span","marks":["highlight"],"value":"캐시 친화적"}]},{"type":"heading","level":3,"children":[{"type":"span","value":"단점"}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"워크로드의 불균형(load imbalance)"},{"type":"span","value":" 문제"}]},{"type":"paragraph","children":[{"type":"span","value":"방금 전의 예시와 동일한 상황(4개의 작업, 2개의 CPU)에서 작업 하나(C)가 종료되었다고 가정하자."}]},{"type":"paragraph","children":[{"type":"span","value":"스케줄링 큐는 다음과 같은 모습이 된다."}]},{"code":"Q0 → [A]\nQ1 → [B] → [D]","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"RR의 경우 다음과 같은 스케줄이 생성될 수 있다."}]},{"code":"CPU 0 | [A][A][A][A][A][A][A][A][A][A][A][A] ...\nCPU 1 | [B][B][D][D][B][B][D][D][B][B][D][D] ...\n        시간의 흐름 →","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"A가 B와 D보다 "},{"type":"span","marks":["underline"],"value":"2배의 CPU를 차지"},{"type":"span","value":"하는 상태가 된다. ➡️ 워크로드 불균형 발생"}]},{"type":"paragraph","children":[{"type":"span","value":"여기서 A까지 종료하면  스케줄링 큐와 CPU 사용 타임라인은 다음과 같다."}]},{"code":"Q0 →\nQ1 → [B] → [D]","type":"code"},{"code":"CPU 0 | \nCPU 1 | [B][B][D][D][B][B][D][D][B][B][D][D] ...\n        시간의 흐름 →","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"이처럼 CPU 0은 "},{"type":"span","marks":["underline"],"value":"유휴 상태"},{"type":"span","value":"가 됨을 알 수 있다. ➡️ 워크로드 불균형 심각"}]},{"type":"paragraph","children":[{"type":"span","value":"MQMS의 조치 ➡️ "},{"type":"span","marks":["highlight"],"value":"이주(migration)"},{"type":"span","value":": 작업을 이리저리 이동시키는 것"}]},{"type":"paragraph","children":[{"type":"span","value":"두 가지 경우를 통해 이를 살펴보자."}]},{"type":"paragraph","children":[{"type":"span","value":"[경우 1]"}]},{"code":"Q0 →\nQ1 → [B] → [D]","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"이 경우 운영체제는 B 또는 D 중 하나를 CPU 0으로 이동시켜 워크로드의 균형을 이룰 수 있다."}]},{"type":"paragraph","children":[{"type":"span","value":"[경우 2]"}]},{"code":"Q0 → [A]\nQ1 → [B] → [D]","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"이 경우는 한 번 이주를 한다고 해도 동일한 상황이 반복(2개, 1개)되므로 문제가 해결되지 않는다.\n➡️ 작업들을 지속적으로 이주시켜야 함."}]},{"type":"paragraph","children":[{"type":"span","value":"예시) 작업 B가 CPU 0과 CPU 1을 몇 개의 타임 슬라이스마다 주기적으로 이주\n➡️ 이외에도 다양한 이주 패턴이 존재"}]},{"type":"paragraph","children":[{"type":"span","marks":["underline"],"value":"그렇다면 이주의 필요 여부를 어떻게 결정할 수 있을까?"}]},{"type":"paragraph","children":[{"type":"span","value":"한 가지 기본적인 접근 방식: "},{"type":"span","marks":["highlight"],"value":"작업 훔치기(work stealing)"}]},{"type":"paragraph","children":[{"type":"span","value":"방식은 다음과 같다."}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"작업의 개수가 적은 큐(source queue)가 가끔 다른 큐(target queue)에 훨씬 많은 수의 작업이 있는지를 검사"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"작업의 개수가 source queue < target queue라면 하나 이상의 source queue로 작업을 가져옴."}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"이때의 문제점: "},{"type":"span","marks":["highlight"],"value":"큐의 잦은 검사로 인해 오버헤드가 발생하고 이에 따라 확장성에 문제 발생\n"},{"type":"span","value":"➡️ 확장성은 멀티 큐 스케줄링의 가장 중요한 목적\n➡️ 그렇다고 다른 큐를 자주 검사하지 않으면 심각한 워크로드 불균형 초래"}]},{"type":"paragraph","children":[{"type":"span","value":"큐 검사에 대한 적절한 값을 찾아내는 것은 다른 주제들의 비슷한 경우와 마찬가지로 어려운 일! "}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"6️⃣ Linux 멀티프로세서 스케줄러"}]},{"type":"paragraph","children":[{"type":"span","value":"세 가지 스케줄러가 등장: O(1) 스케줄러, Completely Fair Scheduler(CFS), BF 스케줄러(BFS)"}]},{"type":"paragraph","children":[{"type":"span","value":"O(1)과 CFS는 멀티 큐, BFS는 단일 큐를 사용"}]},{"type":"paragraph","children":[{"type":"span","value":"O(1) 스케줄러는 우선순위 기반 스케줄러(MLFQ와 유사)\n➡️ 프로세스의 우선순위를 시간에 따라 변경하여 다양한 목적 달성(특히, 상호작용을 가장 우선시)"}]},{"type":"paragraph","children":[{"type":"span","value":"CFS는 결정론적(deterministic) 비례배분(proportional share) 방식(보폭 스케줄링과 유사)"}]},{"type":"paragraph","children":[{"type":"span","value":"BFS는 셋 중 유일한 단일 큐 방식이며, 비례배분 방식\n➡️ Earliest Eligible Virtual Deadline First(EEVDF)라고 알려진 더 복잡한 방식에 기반"}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"🧺 멀티프로세서 스케줄링 정리 하기"}]},{"type":"paragraph","children":[{"type":"span","value":"단일 큐 방식(SQMS)"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"구현이 용이"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"워크로드의 균형을 맞추기 용이"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"많은 개수의 프로세서에 대한 확장성과 캐시 친화성이 좋지 못함."}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"멀티 큐 방식(MQMS)"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"확장성이 좋음."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"캐시 친화성을 잘 처리함."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"워크로드 불균형에 문제가 있고 구현이 복잡"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"CPU 스케줄러는 사소한 코드 수정으로 시스템의 동작이 엄청나게 바뀜\n➡️ 모든 경우에 다 잘 동작하는 범용 스케줄러를 구현하는 것은 매우 어려움."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"📚 참고 문헌"}]},{"type":"paragraph","children":[{"url":"https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-sched-multi.pdf","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"Operating Systems: Three Easy Pieces ― 10: Multiprocessor Scheduling (Advanced)"}]}]},{"type":"paragraph","children":[{"url":"https://pages.cs.wisc.edu/~remzi/OSTEP/Korean/10-cpu-sched-multi.pdf","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"운영체제 아주 쉬운 세 가지 이야기 ― 13: 멀티프로세서 스케줄링 (고급)"}]}]}]}}}}},"pageContext":{"id":"144619099","locale":"ko-KR"}},
    "staticQueryHashes": ["1034768456","1118752904","2342916782","2757196681","3415878905","3879866231","4195094990"]}