{
    "componentChunkName": "component---src-templates-article-jsx",
    "path": "/blog/development/os-address-translation",
    "result": {"data":{"datoCmsMiscTextString":{"locale":"ko-KR","updatedAtText":"업데이트됨","nextReadText":"관련있는 게시물"},"datoCmsBlogPost":{"locale":"ko-KR","originalId":"176854321","title":"[운영체제][OSTEP] 주소 변환의 원리","seo":{"seoTitle":"[운영체제][OSTEP] 주소 변환의 원리","seoDescription":"효율적이고 유연하게 메모리를 가상화하는 방법에 대해 공부해봅니다.","seoImage":{"seoImageUrl":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format"}},"subtitle":"효율적이고 유연하게 메모리를 가상화하는 방법에 대해 공부해봅니다.","coverImage":{"coverImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&w=860","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.25&w=860 215w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.5&w=860 430w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&w=860 860w","sizes":"(min-width: 860px) 860px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgLCgoLDhMVDhcNDh0VDxUSGhYdHSIVFhUaKysjGh0oHSEWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLCgUFEBAOEC8oIhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIAAwAGAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAFAQQGAP/EAB0QAAEEAgMAAAAAAAAAAAAAAAEAAgMEESEFEjL/xAAWAQADAAAAAAAAAAAAAAAAAAAAAQP/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwDD1KM1uPLjpIRUI4GZc4aRXH25hTOHqqbth7yDIVIiXI2IQzqCoREhL/RyuQH/2Q=="},"width":860,"height":430}},"meta":{"updatedAt":"2023-07-16T01:48:36.298+09:00","firstPublishedAt":"2023-07-15T15:06:52.846+09:00"},"categoryLink":{"title":"개발 공부","id":"4743072"},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorPictureData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 60px) 60px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgWEQ8LDhgYDhUNDhgNDw8NFxUdGBYfFhUaHysjGikoHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OHBANHDUcIig7NS81NS81MjUvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAFAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAABQYHAv/EAB4QAAICAgMBAQAAAAAAAAAAAAABAgMFBgQRQXEi/8QAFQEBAQAAAAAAAAAAAAAAAAAABAP/xAAaEQACAwEBAAAAAAAAAAAAAAAAAQIDEhMR/9oADAMBAAIRAxEAPwDT8/1LHSK/r67scevSfz99VXBkm/Cva/zKle/pCc/JoRXWsFujxvygcLI1pAXqQTmjONm2RzpceyCwmwxpsbbADWJdBFbeCfe2wXoAGpIL6z//2Q=="},"width":60,"height":60}}},"relatedPosts":[{"id":"145790692","meta":{"updatedAt":"2023-07-15T15:20:04.667+09:00"},"categoryLink":{"title":"개발 공부"},"coverImage":{"gatsbyImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.09&w=860 75w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.18&w=860 150w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860 300w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.7&w=860 600w","sizes":"(min-width: 300px) 300px, 100vw"}},"layout":"constrained","width":300,"height":120},"squaredImage":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.06&fit=crop&fp-x=0.5&fp-y=0.5&w=430 25w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.12&fit=crop&fp-x=0.5&fp-y=0.5&w=430 50w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430 100w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.47&fit=crop&fp-x=0.5&fp-y=0.5&w=430 200w","sizes":"(min-width: 100px) 100px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBhINEBAQCggUDg0IDgcHFh0JFhEYFxUZGCIVFhUaHysjGh0oHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OEg4REC8dFhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAGAMBIgACEQEDEQH/xAAaAAEBAAIDAAAAAAAAAAAAAAAABAUGAQID/8QAHRAAAgICAwEAAAAAAAAAAAAAAAIDBAEREhQVBf/EABYBAQEBAAAAAAAAAAAAAAAAAAADAf/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/ANASs2WLoaraMl1o0O241wSYlSHjgHM9hVAEFr6bKSemzAAeclpnAAH/2Q=="},"width":100,"height":100}},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.11&w=77 8w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 30px) 30px, 100vw"}},"layout":"constrained","width":30,"height":30}}},"subtitle":"Unix/C 프로그램에서 메모리를 할당하고 관리하는 방법에 대해 공부해봅니다.","title":"[운영체제][OSTEP] 메모리 관리 API"}],"structuredBody":{"blocks":[],"links":[{"id":"136799565"}],"value":{"schema":"dast","document":{"type":"root","children":[{"type":"heading","level":2,"children":[{"type":"span","value":"🚪 들어가며"}]},{"type":"paragraph","children":[{"type":"span","value":"메모리 가상화 또한 CPU 가상화와 비슷한 전략을 추구\n➡️ "},{"type":"span","marks":["highlight"],"value":"가상화를 제공하는 동시에 효율성(efficiency)과 제어(control) 모두를 추구"}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"효율성"},{"type":"span","value":"을 높이려면 "},{"type":"span","marks":["highlight"],"value":"하드웨어 지원을 활용"},{"type":"span","value":"할 수 밖에 없음."}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"제어"},{"type":"span","value":"는 응용 프로그램이 "},{"type":"span","marks":["highlight"],"value":"자기자신의 메모리 이외에는 다른 메모리에 접근하지 못한다는 것을 운영체제가 보장"},{"type":"span","value":"하는 것을 의미"}]},{"type":"paragraph","children":[{"type":"span","value":"유연성(flexibility) 측면에서 VM 시스템에서 필요한 사항\n➡️ 프로그래머가 원하는 대로 주소 공간을 사용하고, 프로그래밍하기 쉬운 시스템을 만들기 원함."}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"하드웨어-기반 주소 변환(hardware-based address translation)"},{"type":"span","value":" 또는 "},{"type":"span","marks":["highlight"],"value":"주소 변환(address translation)\n"},{"type":"span","value":"➡️ "},{"item":"136799565","meta":[{"id":"target","value":"_blank"}],"type":"itemLink","children":[{"type":"span","value":"제한적 직접 실행"}]},{"type":"span","value":" 방식에 부가적으로 사용되는 기능이라고 생각할 수 있음."}]},{"type":"paragraph","children":[{"type":"span","value":"주소 변환을 통해 하드웨어는 명령어 반입, 탑재, 저장 등의 "},{"type":"span","marks":["highlight"],"value":"가상 주소를 정보가 실제 존재하는 물리 주소로 변환"},{"type":"span","value":" ➡️ 하드웨어가 주소를 변환"}]},{"type":"paragraph","children":[{"type":"span","value":"운영체제는 메모리의 빈 공간과 사용 중인 공간을 항상 알고 있어야 하고, 메모리 사용을 제어하고 관리"}]},{"type":"heading","level":3,"children":[{"type":"span","value":"🚀 이 모든 작업의 목표"}]},{"type":"paragraph","children":[{"type":"span","value":"프로그램이 자신의 전용 메모리를 소유하고 그 안에 자신의 코드와 데이터가 있다는 "},{"type":"span","marks":["highlight"],"value":"환상"},{"type":"span","value":"을 만드는 것"}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"1️⃣ 가정"}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"사용자 주소 공간은 물리 메모리에 연속적으로 배치되어야 한다고 가정"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"단순화를 위해 주소 공간의 크기가 너무 크지 않다고 가정"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"각 주소 공간의 크기는 같다고 가정"}]}]}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"2️⃣ 사례"}]},{"type":"paragraph","children":[{"type":"span","value":"다음과 같은 프로세스가 있다고 가정하자."}]},{"type":"paragraph","children":[{"type":"span","value":"메모리에 값을 탑재하고, 3을 증가시키고, 다시 메모리에 저장하는 코드이다."}]},{"type":"paragraph","children":[{"type":"span","value":"이 코드의 C 언어 표현은 다음과 같이 나타낼 수 있다."}]},{"code":"void func() {\n  int x = 3000;\n  x = x + 3; // 우리가 관심있는 코드\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"컴파일러는 이 코드를 어셈블리 코드로 변환하고, 그 결과는 x86 어셈블리로 다음과 같을 것이다."}]},{"code":"128: movl 0x0(\\%ebx), \\%eax ; 0+ebx를 eax에 저장\n132: addl \\$0x03, \\%eax     ; eax레지스터에 3을 더한다\n135: movl \\%eax, 0x0(\\%ebx) ; eax를 메모리에 다시 저장","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"다음은 위의 코드와 데이터가 프로세스 주소 공간에 어떻게 배치되어 있는지 나타내고 있다."}]},{"code":" 0 KB ┌──────────────────────┐\n   128│ movl 0x0(%ebx), %eax │\n   132│ addl 0x03, %eax      │\n   135│ movl %eax, 0x0(%ebx) │\n 1 KB │                      │\n      │     Program Code     │\n 2 KB ├──────────────────────┤\n      │                      │\n 3 KB │         Heap         │\n      │                      │\n 4 KB ├──────────────────────┤\n      │          │           │\n      │          │           │\n      │          │           │\n      │          ↓           │\n      │        (free)        │\n      │          ↑           │\n      │          │           │\n      │          │           │\n      │          │           │\n14 KB ├──────────────────────┤\n      │                      │\n15 KB │ 3000   Stack         │\n      │                      │\n16 KB └──────────────────────┘","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"세 개의 명령어 코드는 주소 128에 위치하고, 변수 x의 값은 주소 15KB에 위치한다.\n또한 x의 초기 값은 3000이다."}]},{"type":"paragraph","children":[{"type":"span","value":"이 명령어가 실행되면 프로세스의 관점에서 다음과 같은 메모리 접근이 일어난다."}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"주소 128의 명령어를 반입"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"해당 명령어 실행(주소 15KB에서 탑재)"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"주소 132의 명령어를 반입"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"해당 명령어 실행(메모리 참조 없음)"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"주소 135의 명령어를 반입"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"해당 명령어 실행(15KB에 저장)"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"[프로그램 관점]\n주소 공간: 주소 0부터 시작하여 최대 16KB까지\n➡️ 프로그램이 생성하는 모든 메모리 참조는 이 범위 내에 있어야 함."}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"메모리 가상화"},{"type":"span","value":"를 위해 운영체제가 프로세스를 물리 메모리 주소 0이 아닌 다른 곳에 위치시키고 싶을 때, "},{"type":"span","marks":["highlight"],"value":"프로세스 모르게 메모리를 다른 위치에 어떻게 "},{"type":"span","marks":["highlight","underline"],"value":"재배치"},{"type":"span","marks":["highlight"],"value":" 하느냐가 관건"}]},{"type":"paragraph","children":[{"type":"span","value":"다음은 이 프로세스의 주소 공간이 메모리에 배치되었을 때 가능한 물리 메모리 배치의 예시이다."}]},{"code":" 0 KB ┌────────────────────────────┐\n      │                            │\n      │      Operating System      │\n      │                            │\n16 KB ├────────────────────────────┤\n      │                            │\n      │        (not in use)        │\n      │                            │\n32 KB ├────────────────────────────┤ ┐\n      │            Code            │ │\n      ├────────────────────────────┤ │\n      │            Heap            │ │\n      ├────────────────────────────┤ │ Relocated\n      │              ↓             │ │ Process\n      │ (allocated but not in use) │ │\n      │              ↑             │ │ \n      ├────────────────────────────┤ │\n      │            Stack           │ │\n48 KB ├────────────────────────────┤ ┘\n      │                            │\n      │        (not in use)        │\n      │                            │\n64 KB └────────────────────────────┘","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"물리 메모리의 첫 번째 슬롯 - 운영체제 자신이 사용"}]},{"type":"paragraph","children":[{"type":"span","value":"위의 예시에서 프로세스는 물리 주소 32KB에서 시작하는 슬롯에 재배치됨."}]},{"type":"paragraph","children":[{"type":"span","value":"다른 두 슬롯(16KB-32KB와 48KB-64KB)은 비어 있음."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"3️⃣ 동적(하드웨어-기반) 재배치"}]},{"type":"paragraph","children":[{"type":"span","value":"1950년대 후반의 첫 번째 시분할 컴퓨터에서 "},{"type":"span","marks":["highlight"],"value":"베이스와 바운드(base and bound)"},{"type":"span","value":"라는 간단한 아이디어가 채택됨. ➡️ "},{"type":"span","marks":["highlight"],"value":"동적 재배치(dynamic relocation)"},{"type":"span","value":"라고도 함."}]},{"type":"paragraph","children":[{"type":"span","marks":["underline"],"value":"각 CPU마다 2개의 하드웨어 레지스터가 필요"}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"베이스(base)"},{"type":"span","value":" 레지스터"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"바운드(bound)"},{"type":"span","value":" 레지스터 또는 "},{"type":"span","marks":["highlight"],"value":"한계(limit)"},{"type":"span","value":" 레지스터"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"이러한 CPU 쌍은 우리가 원하는 위치에 주소 공간을 배치할 수 있게 함.\n➡️ 배치와 동시에 프로세스가 오직 자신의 주소 공간에만 접근한다는 것을 보장"}]},{"type":"paragraph","children":[{"type":"span","value":"이 설정에서 각 프로그램은 "},{"type":"span","marks":["highlight"],"value":"주소 0에 탑재되는 것처럼 작성되고 컴파일됨."}]},{"type":"paragraph","children":[{"type":"span","value":"프로그램 시작 시, "},{"type":"span","marks":["highlight"],"value":"운영체제가 프로그램이 탑재될 물리 메모리 위치를 결정"},{"type":"span","value":"하고 "},{"type":"span","marks":["highlight"],"value":"베이스 레지스터를 그 주소로 지정.\n"},{"type":"span","value":"➡️ 2️⃣의 재배치 예시에서 운영체제는 프로세스를 물리 주소 32KB에 저장하기로 결정하고 베이스 레지스터를 이 값으로 설정"}]},{"type":"paragraph","children":[{"type":"span","value":"프로세스에 의해 생성되는 모든 주소가 다음과 같은 방법으로 프로세서에 의해 "},{"type":"span","marks":["highlight"],"value":"변환"}]},{"type":"paragraph","children":[{"type":"span","value":"physical address = virtual address + base"}]},{"type":"paragraph","children":[{"type":"span","value":"프로세스가 생성하는 메모리 참조는 "},{"type":"span","marks":["highlight"],"value":"가상 주소\n"},{"type":"span","value":"하드웨어는 베이스 레지스터의 내용을 이 주소에 더하여 "},{"type":"span","marks":["highlight"],"value":"물리 주소"},{"type":"span","value":"를 생성"}]},{"type":"paragraph","children":[{"type":"span","value":"위의 예시 코드의 일부를 통해 명령어 실행 시 동작 방식을 조금 더 알아보자."}]},{"code":"128: movl 0x0(\\%ebx), \\%eax","type":"code"},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"프로그램 카운터(PC)는 128로 설정됨."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"하드웨어가 위 명령어를 반입할 때, PC 값을 베이스 레지스터의 값 32KB(32768)에 더해 32896의 물리 주소를 얻음."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"하드웨어는 해당 물리 주소에서 명령어를 가져옴."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"프로세서는 명령어의 실행을 시작함."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"프로세스는 가상 주소 15KB의 값을 탑재하라는 명령어를 내림."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"이 주소를 프로세서가 받아 다시 베이스 레지스터(32KB)를 더하고 물리 주소 47KB에서 원하는 내용을 탑재함."}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"⭐ 위의 내용 중 가상 주소에서 물리 주소로의 변환이 "},{"type":"span","marks":["highlight"],"value":"주소 변환"},{"type":"span","value":"이라고 부르는 기술임."}]},{"type":"paragraph","children":[{"type":"span","value":"주소의 재배치가 실행 시에 일어나고, 프로세스가 실행을 시작한 이후에도 주소 공간을 이동할 수 있기 때문에 "},{"type":"span","marks":["highlight"],"value":"동적 재배치(dynamic relocation)"},{"type":"span","value":"라고도 불림."}]},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 베이스와 바운드 레지스터는 CPU 칩 상에 존재하는 하드웨어 구조임.(CPU당 1쌍)"}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"메모리 관리 장치(memory management unit, MMU)"},{"type":"span","value":": 주소 변환에 도움을 주는 프로세서의 일부"}]},{"type":"paragraph","children":[{"type":"span","value":"바운드 레지스터는 다음의 두 가지 방식 중 하나로 정의될 수 있음.\n[1] "},{"type":"span","marks":["underline"],"value":"주소 공간의 크기를 저장하는 방식"},{"type":"span","value":"\n➡️ 하드웨어는 가상 주소를 베이스 레지스터에 더하기 전 먼저 바운드 레지스터와 비교\n[2] "},{"type":"span","marks":["underline"],"value":"주소 공간의 마지막 물리 주소를 저장하는 방식"},{"type":"span","value":"\n➡️ 하드웨어는 먼저 베이스 레지스터를 더하고 그 결과가 바운드 안에 있는지 검사"}]},{"type":"heading","level":3,"children":[{"type":"span","value":"예제"}]},{"type":"paragraph","children":[{"type":"span","value":"주소 공간의 크기가 4KB인 프로세스가 물리 주소 16KB에 탑재되어 있다고 가정하자."}]},{"type":"paragraph","children":[{"type":"span","value":"주소 변환의 결과는 다음과 같다."}]},{"code":"Virtual Address           Physical Address\n──────────────────────────────────────────\n              0    →                  16KB\n           1 KB    →                  17KB\n           3000    →                 19384\n           4400    →  Fault(out of bounds)","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"위의 예시와 같이 물리 주소를 얻기 위해서는 간단히 가상 주소에 베이스 주소를 더하기만 하면 됨."}]},{"type":"paragraph","children":[{"type":"span","value":"가상 주소가 너무 크거나 음수일 경우에 폴트를 일으키고 예외가 발생하게 됨."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"그렇다면 소프트웨어-기반 재배치는 무엇일까?"}]},{"type":"paragraph","children":[{"type":"span","value":"초창기, 하드웨어 지원이 제공되기 전, 일부 시스템은 소프트웨어만으로 재배치를 수행하였음.\n➡️ "},{"type":"span","marks":["highlight"],"value":"정적 재배치(static relocation)"},{"type":"span","value":"라고 불림."}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"로더(loader)"},{"type":"span","value":": 실행하고자 하는 실행 파일의 모든 주소를 원하는 물리 메모리 오프셋으로 변경하는 소프트웨어"}]},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 정적 재배치의 문제점\n[1] "},{"type":"span","marks":["underline"],"value":"보호 기능이 없음."},{"type":"span","value":"\n➡️ 잘못된 주소를 생성하여 다른 프로세스나 운영체제의 메모리를 불법적으로 접근할 수 있음.\n[2] "},{"type":"span","marks":["underline"],"value":"한 번 배치되면 추후 주소 공간을 재배치하는 것이 어려움."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"4️⃣ 하드웨어 지원: 요약"}]},{"type":"heading","level":3,"children":[{"type":"span","value":"특권 모드(또는 커널 모드)"}]},{"type":"paragraph","children":[{"type":"span","value":"응용 프로그램이 실행되는 사용자 모드와 달리 컴퓨터 전체에 대한 접근 권한을 가지며 운영체제가 실행되는 CPU 모드이다."}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"프로세서 상태 워드(processor status word)"},{"type":"span","value":" 레지스터의 한 비트가 CPU의 현재 실행 모드를 나타낸다."}]},{"type":"paragraph","children":[{"type":"span","value":"시스템 콜 또는 예외 및 인터럽트 발생 시와 같은 특정 순간에 CPU가 모드를 전환한다."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"베이스/바운드 레지스터"}]},{"type":"paragraph","children":[{"type":"span","value":" "}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"5️⃣"}]},{"type":"paragraph","children":[{"type":"span","value":""}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"🧺 주소 변환의 원리 정리 하기"}]},{"type":"paragraph","children":[{"type":"span","value":""}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"📚 참고 문헌"}]},{"type":"paragraph","children":[{"url":"https://pages.cs.wisc.edu/~remzi/OSTEP/vm-mechanism.pdf","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"Operating Systems: Three Easy Pieces ― 15: Mechanism: Address Translation"}]}]},{"type":"paragraph","children":[{"url":"https://pages.cs.wisc.edu/~remzi/OSTEP/Korean/15-vm-mechanism.pdf","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"운영체제 아주 쉬운 세 가지 이야기 ― 18: 주소 변환의 원리"}]}]}]}}}}},"pageContext":{"id":"176854321","locale":"ko-KR"}},
    "staticQueryHashes": ["1034768456","1118752904","2342916782","2757196681","3415878905","3879866231","4195094990"]}