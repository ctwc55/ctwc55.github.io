{"componentChunkName":"component---src-templates-article-jsx","path":"/blog/development/os-address-translation","result":{"data":{"datoCmsMiscTextString":{"locale":"ko-KR","updatedAtText":"업데이트됨","nextReadText":"관련있는 게시물"},"datoCmsBlogPost":{"locale":"ko-KR","originalId":"176854321","title":"[운영체제][OSTEP] 주소 변환의 원리","seo":{"seoTitle":"[운영체제][OSTEP] 주소 변환의 원리","seoDescription":"효율적이고 유연하게 메모리를 가상화하는 방법에 대해 공부해봅니다.","seoImage":{"seoImageUrl":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format"}},"subtitle":"효율적이고 유연하게 메모리를 가상화하는 방법에 대해 공부해봅니다.","coverImage":{"coverImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&w=860","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.25&w=860 215w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.5&w=860 430w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&w=860 860w","sizes":"(min-width: 860px) 860px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgLCgoLDhMVDhcNDh0VDxUSGhYdHSIVFhUaKysjGh0oHSEWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLCgUFEBAOEC8oIhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIAAwAGAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAFAQQGAP/EAB0QAAEEAgMAAAAAAAAAAAAAAAEAAgMEESEFEjL/xAAWAQADAAAAAAAAAAAAAAAAAAAAAQP/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwDD1KM1uPLjpIRUI4GZc4aRXH25hTOHqqbth7yDIVIiXI2IQzqCoREhL/RyuQH/2Q=="},"width":860,"height":430}},"meta":{"updatedAt":"2023-07-18T17:02:12.468+09:00","firstPublishedAt":"2023-07-15T15:06:52.846+09:00"},"categoryLink":{"title":"개발 공부","id":"4743072"},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorPictureData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 60px) 60px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgWEQ8LDhgYDhUNDhgNDw8NFxUdGBYfFhUaHysjGikoHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OHBANHDUcIig7NS81NS81MjUvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAFAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAABQYHAv/EAB4QAAICAgMBAQAAAAAAAAAAAAABAgMFBgQRQXEi/8QAFQEBAQAAAAAAAAAAAAAAAAAABAP/xAAaEQACAwEBAAAAAAAAAAAAAAAAAQIDEhMR/9oADAMBAAIRAxEAPwDT8/1LHSK/r67scevSfz99VXBkm/Cva/zKle/pCc/JoRXWsFujxvygcLI1pAXqQTmjONm2RzpceyCwmwxpsbbADWJdBFbeCfe2wXoAGpIL6z//2Q=="},"width":60,"height":60}}},"relatedPosts":[{"id":"145790692","meta":{"updatedAt":"2023-07-18T19:35:08.039+09:00"},"categoryLink":{"title":"개발 공부"},"coverImage":{"gatsbyImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.09&w=860 75w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.18&w=860 150w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860 300w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.7&w=860 600w","sizes":"(min-width: 300px) 300px, 100vw"}},"layout":"constrained","width":300,"height":120},"squaredImage":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.06&fit=crop&fp-x=0.5&fp-y=0.5&w=430 25w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.12&fit=crop&fp-x=0.5&fp-y=0.5&w=430 50w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430 100w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.47&fit=crop&fp-x=0.5&fp-y=0.5&w=430 200w","sizes":"(min-width: 100px) 100px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBhINEBAQCggUDg0IDgcHFh0JFhEYFxUZGCIVFhUaHysjGh0oHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OEg4REC8dFhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAGAMBIgACEQEDEQH/xAAaAAEBAAIDAAAAAAAAAAAAAAAABAUGAQID/8QAHRAAAgICAwEAAAAAAAAAAAAAAAIDBAEREhQVBf/EABYBAQEBAAAAAAAAAAAAAAAAAAADAf/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/ANASs2WLoaraMl1o0O241wSYlSHjgHM9hVAEFr6bKSemzAAeclpnAAH/2Q=="},"width":100,"height":100}},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.11&w=77 8w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 30px) 30px, 100vw"}},"layout":"constrained","width":30,"height":30}}},"subtitle":"Unix/C 프로그램에서 메모리를 할당하고 관리하는 방법에 대해 공부해봅니다.","title":"[운영체제][OSTEP] 메모리 관리 API"},{"id":"177405298","meta":{"updatedAt":"2023-07-18T18:40:30.124+09:00"},"categoryLink":{"title":"개발 공부"},"coverImage":{"gatsbyImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.09&w=860 75w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.18&w=860 150w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860 300w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.7&w=860 600w","sizes":"(min-width: 300px) 300px, 100vw"}},"layout":"constrained","width":300,"height":120},"squaredImage":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.06&fit=crop&fp-x=0.5&fp-y=0.5&w=430 25w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.12&fit=crop&fp-x=0.5&fp-y=0.5&w=430 50w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430 100w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.47&fit=crop&fp-x=0.5&fp-y=0.5&w=430 200w","sizes":"(min-width: 100px) 100px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBhINEBAQCggUDg0IDgcHFh0JFhEYFxUZGCIVFhUaHysjGh0oHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OEg4REC8dFhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAGAMBIgACEQEDEQH/xAAaAAEBAAIDAAAAAAAAAAAAAAAABAUGAQID/8QAHRAAAgICAwEAAAAAAAAAAAAAAAIDBAEREhQVBf/EABYBAQEBAAAAAAAAAAAAAAAAAAADAf/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/ANASs2WLoaraMl1o0O241wSYlSHjgHM9hVAEFr6bKSemzAAeclpnAAH/2Q=="},"width":100,"height":100}},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.11&w=77 8w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 30px) 30px, 100vw"}},"layout":"constrained","width":30,"height":30}}},"subtitle":"대용량 주소 공간을 지원하는 방법에 대해 공부해봅니다.","title":"[운영체제][OSTEP] 세그멘테이션"}],"structuredBody":{"blocks":[],"links":[{"id":"136799565"}],"value":{"schema":"dast","document":{"type":"root","children":[{"type":"heading","level":2,"children":[{"type":"span","value":"🚪 들어가며"}]},{"type":"paragraph","children":[{"type":"span","value":"메모리 가상화 또한 CPU 가상화와 비슷한 전략을 추구\n➡️ "},{"type":"span","marks":["highlight"],"value":"가상화를 제공하는 동시에 효율성(efficiency)과 제어(control) 모두를 추구"}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"효율성"},{"type":"span","value":"을 높이려면 "},{"type":"span","marks":["highlight"],"value":"하드웨어 지원을 활용"},{"type":"span","value":"할 수 밖에 없음."}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"제어"},{"type":"span","value":"는 응용 프로그램이 "},{"type":"span","marks":["highlight"],"value":"자기자신의 메모리 이외에는 다른 메모리에 접근하지 못한다는 것을 운영체제가 보장"},{"type":"span","value":"하는 것을 의미"}]},{"type":"paragraph","children":[{"type":"span","value":"유연성(flexibility) 측면에서 VM 시스템에서 필요한 사항\n➡️ 프로그래머가 원하는 대로 주소 공간을 사용하고, 프로그래밍하기 쉬운 시스템을 만들기 원함."}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"하드웨어-기반 주소 변환(hardware-based address translation)"},{"type":"span","value":" 또는 "},{"type":"span","marks":["highlight"],"value":"주소 변환(address translation)\n"},{"type":"span","value":"➡️ "},{"item":"136799565","meta":[{"id":"target","value":"_blank"}],"type":"itemLink","children":[{"type":"span","value":"제한적 직접 실행"}]},{"type":"span","value":" 방식에 부가적으로 사용되는 기능이라고 생각할 수 있음."}]},{"type":"paragraph","children":[{"type":"span","value":"주소 변환을 통해 하드웨어는 명령어 반입, 탑재, 저장 등의 "},{"type":"span","marks":["highlight"],"value":"가상 주소를 정보가 실제 존재하는 물리 주소로 변환"},{"type":"span","value":" ➡️ 하드웨어가 주소를 변환"}]},{"type":"paragraph","children":[{"type":"span","value":"운영체제는 메모리의 빈 공간과 사용 중인 공간을 항상 알고 있어야 하고, 메모리 사용을 제어하고 관리"}]},{"type":"heading","level":3,"children":[{"type":"span","value":"🚀 이 모든 작업의 목표"}]},{"type":"paragraph","children":[{"type":"span","value":"프로그램이 자신의 전용 메모리를 소유하고 그 안에 자신의 코드와 데이터가 있다는 "},{"type":"span","marks":["highlight"],"value":"환상"},{"type":"span","value":"을 만드는 것"}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"1️⃣ 가정"}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"사용자 주소 공간은 물리 메모리에 연속적으로 배치되어야 한다고 가정"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"단순화를 위해 주소 공간의 크기가 너무 크지 않다고 가정"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"각 주소 공간의 크기는 같다고 가정"}]}]}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"2️⃣ 사례"}]},{"type":"paragraph","children":[{"type":"span","value":"다음과 같은 프로세스가 있다고 가정하자."}]},{"type":"paragraph","children":[{"type":"span","value":"메모리에 값을 탑재하고, 3을 증가시키고, 다시 메모리에 저장하는 코드이다."}]},{"type":"paragraph","children":[{"type":"span","value":"이 코드의 C 언어 표현은 다음과 같이 나타낼 수 있다."}]},{"code":"void func() {\n  int x = 3000;\n  x = x + 3; // 우리가 관심있는 코드\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"컴파일러는 이 코드를 어셈블리 코드로 변환하고, 그 결과는 x86 어셈블리로 다음과 같을 것이다."}]},{"code":"128: movl 0x0(\\%ebx), \\%eax ; 0+ebx를 eax에 저장\n132: addl \\$0x03, \\%eax     ; eax레지스터에 3을 더한다\n135: movl \\%eax, 0x0(\\%ebx) ; eax를 메모리에 다시 저장","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"다음은 위의 코드와 데이터가 프로세스 주소 공간에 어떻게 배치되어 있는지 나타내고 있다."}]},{"code":" 0 KB ┌──────────────────────┐\n   128│ movl 0x0(%ebx), %eax │\n   132│ addl 0x03, %eax      │\n   135│ movl %eax, 0x0(%ebx) │\n 1 KB │                      │\n      │     Program Code     │\n 2 KB ├──────────────────────┤\n      │                      │\n 3 KB │         Heap         │\n      │                      │\n 4 KB ├──────────────────────┤\n      │          │           │\n      │          │           │\n      │          │           │\n      │          ↓           │\n      │        (free)        │\n      │          ↑           │\n      │          │           │\n      │          │           │\n      │          │           │\n14 KB ├──────────────────────┤\n      │                      │\n15 KB │ 3000   Stack         │\n      │                      │\n16 KB └──────────────────────┘","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"세 개의 명령어 코드는 주소 128에 위치하고, 변수 x의 값은 주소 15KB에 위치한다.\n또한 x의 초기 값은 3000이다."}]},{"type":"paragraph","children":[{"type":"span","value":"이 명령어가 실행되면 프로세스의 관점에서 다음과 같은 메모리 접근이 일어난다."}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"주소 128의 명령어를 반입"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"해당 명령어 실행(주소 15KB에서 탑재)"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"주소 132의 명령어를 반입"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"해당 명령어 실행(메모리 참조 없음)"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"주소 135의 명령어를 반입"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"해당 명령어 실행(15KB에 저장)"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"[프로그램 관점]\n주소 공간: 주소 0부터 시작하여 최대 16KB까지\n➡️ 프로그램이 생성하는 모든 메모리 참조는 이 범위 내에 있어야 함."}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"메모리 가상화"},{"type":"span","value":"를 위해 운영체제가 프로세스를 물리 메모리 주소 0이 아닌 다른 곳에 위치시키고 싶을 때, "},{"type":"span","marks":["highlight"],"value":"프로세스 모르게 메모리를 다른 위치에 어떻게 "},{"type":"span","marks":["highlight","underline"],"value":"재배치"},{"type":"span","marks":["highlight"],"value":" 하느냐가 관건"}]},{"type":"paragraph","children":[{"type":"span","value":"다음은 이 프로세스의 주소 공간이 메모리에 배치되었을 때 가능한 물리 메모리 배치의 예시이다."}]},{"code":" 0 KB ┌────────────────────────────┐\n      │                            │\n      │      Operating System      │\n      │                            │\n16 KB ├────────────────────────────┤\n      │                            │\n      │        (not in use)        │\n      │                            │\n32 KB ├────────────────────────────┤ ┐\n      │            Code            │ │\n      ├────────────────────────────┤ │\n      │            Heap            │ │\n      ├────────────────────────────┤ │ Relocated\n      │              ↓             │ │ Process\n      │ (allocated but not in use) │ │\n      │              ↑             │ │ \n      ├────────────────────────────┤ │\n      │            Stack           │ │\n48 KB ├────────────────────────────┤ ┘\n      │                            │\n      │        (not in use)        │\n      │                            │\n64 KB └────────────────────────────┘","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"물리 메모리의 첫 번째 슬롯 - 운영체제 자신이 사용"}]},{"type":"paragraph","children":[{"type":"span","value":"위의 예시에서 프로세스는 물리 주소 32KB에서 시작하는 슬롯에 재배치됨."}]},{"type":"paragraph","children":[{"type":"span","value":"다른 두 슬롯(16KB-32KB와 48KB-64KB)은 비어 있음."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"3️⃣ 동적(하드웨어-기반) 재배치"}]},{"type":"paragraph","children":[{"type":"span","value":"1950년대 후반의 첫 번째 시분할 컴퓨터에서 "},{"type":"span","marks":["highlight"],"value":"베이스와 바운드(base and bound)"},{"type":"span","value":"라는 간단한 아이디어가 채택됨. ➡️ "},{"type":"span","marks":["highlight"],"value":"동적 재배치(dynamic relocation)"},{"type":"span","value":"라고도 함."}]},{"type":"paragraph","children":[{"type":"span","marks":["underline"],"value":"각 CPU마다 2개의 하드웨어 레지스터가 필요"}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"베이스(base)"},{"type":"span","value":" 레지스터"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"바운드(bound)"},{"type":"span","value":" 레지스터 또는 "},{"type":"span","marks":["highlight"],"value":"한계(limit)"},{"type":"span","value":" 레지스터"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"이러한 CPU 쌍은 우리가 원하는 위치에 주소 공간을 배치할 수 있게 함.\n➡️ 배치와 동시에 프로세스가 오직 자신의 주소 공간에만 접근한다는 것을 보장"}]},{"type":"paragraph","children":[{"type":"span","value":"이 설정에서 각 프로그램은 "},{"type":"span","marks":["highlight"],"value":"주소 0에 탑재되는 것처럼 작성되고 컴파일됨."}]},{"type":"paragraph","children":[{"type":"span","value":"프로그램 시작 시, "},{"type":"span","marks":["highlight"],"value":"운영체제가 프로그램이 탑재될 물리 메모리 위치를 결정"},{"type":"span","value":"하고 "},{"type":"span","marks":["highlight"],"value":"베이스 레지스터를 그 주소로 지정.\n"},{"type":"span","value":"➡️ 2️⃣의 재배치 예시에서 운영체제는 프로세스를 물리 주소 32KB에 저장하기로 결정하고 베이스 레지스터를 이 값으로 설정"}]},{"type":"paragraph","children":[{"type":"span","value":"프로세스에 의해 생성되는 모든 주소가 다음과 같은 방법으로 프로세서에 의해 "},{"type":"span","marks":["highlight"],"value":"변환"}]},{"type":"paragraph","children":[{"type":"span","value":"physical address = virtual address + base"}]},{"type":"paragraph","children":[{"type":"span","value":"프로세스가 생성하는 메모리 참조는 "},{"type":"span","marks":["highlight"],"value":"가상 주소\n"},{"type":"span","value":"하드웨어는 베이스 레지스터의 내용을 이 주소에 더하여 "},{"type":"span","marks":["highlight"],"value":"물리 주소"},{"type":"span","value":"를 생성"}]},{"type":"paragraph","children":[{"type":"span","value":"위의 예시 코드의 일부를 통해 명령어 실행 시 동작 방식을 조금 더 알아보자."}]},{"code":"128: movl 0x0(\\%ebx), \\%eax","type":"code"},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"프로그램 카운터(PC)는 128로 설정됨."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"하드웨어가 위 명령어를 반입할 때, PC 값을 베이스 레지스터의 값 32KB(32768)에 더해 32896의 물리 주소를 얻음."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"하드웨어는 해당 물리 주소에서 명령어를 가져옴."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"프로세서는 명령어의 실행을 시작함."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"프로세스는 가상 주소 15KB의 값을 탑재하라는 명령어를 내림."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"이 주소를 프로세서가 받아 다시 베이스 레지스터(32KB)를 더하고 물리 주소 47KB에서 원하는 내용을 탑재함."}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"⭐ 위의 내용 중 가상 주소에서 물리 주소로의 변환이 "},{"type":"span","marks":["highlight"],"value":"주소 변환"},{"type":"span","value":"이라고 부르는 기술임."}]},{"type":"paragraph","children":[{"type":"span","value":"주소의 재배치가 실행 시에 일어나고, 프로세스가 실행을 시작한 이후에도 주소 공간을 이동할 수 있기 때문에 "},{"type":"span","marks":["highlight"],"value":"동적 재배치(dynamic relocation)"},{"type":"span","value":"라고도 불림."}]},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 베이스와 바운드 레지스터는 CPU 칩 상에 존재하는 하드웨어 구조임.(CPU당 1쌍)"}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"메모리 관리 장치(memory management unit, MMU)"},{"type":"span","value":": 주소 변환에 도움을 주는 프로세서의 일부"}]},{"type":"paragraph","children":[{"type":"span","value":"바운드 레지스터는 다음의 두 가지 방식 중 하나로 정의될 수 있음.\n[1] "},{"type":"span","marks":["underline"],"value":"주소 공간의 크기를 저장하는 방식"},{"type":"span","value":"\n➡️ 하드웨어는 가상 주소를 베이스 레지스터에 더하기 전 먼저 바운드 레지스터와 비교\n[2] "},{"type":"span","marks":["underline"],"value":"주소 공간의 마지막 물리 주소를 저장하는 방식"},{"type":"span","value":"\n➡️ 하드웨어는 먼저 베이스 레지스터를 더하고 그 결과가 바운드 안에 있는지 검사"}]},{"type":"heading","level":3,"children":[{"type":"span","value":"예제"}]},{"type":"paragraph","children":[{"type":"span","value":"주소 공간의 크기가 4KB인 프로세스가 물리 주소 16KB에 탑재되어 있다고 가정하자."}]},{"type":"paragraph","children":[{"type":"span","value":"주소 변환의 결과는 다음과 같다."}]},{"code":"Virtual Address           Physical Address\n──────────────────────────────────────────\n              0    →                  16KB\n           1 KB    →                  17KB\n           3000    →                 19384\n           4400    →  Fault(out of bounds)","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"위의 예시와 같이 물리 주소를 얻기 위해서는 간단히 가상 주소에 베이스 주소를 더하기만 하면 됨."}]},{"type":"paragraph","children":[{"type":"span","value":"가상 주소가 너무 크거나 음수일 경우에 폴트를 일으키고 예외가 발생하게 됨."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"그렇다면 소프트웨어-기반 재배치는 무엇일까?"}]},{"type":"paragraph","children":[{"type":"span","value":"초창기, 하드웨어 지원이 제공되기 전, 일부 시스템은 소프트웨어만으로 재배치를 수행하였음.\n➡️ "},{"type":"span","marks":["highlight"],"value":"정적 재배치(static relocation)"},{"type":"span","value":"라고 불림."}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"로더(loader)"},{"type":"span","value":": 실행하고자 하는 실행 파일의 모든 주소를 원하는 물리 메모리 오프셋으로 변경하는 소프트웨어"}]},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 정적 재배치의 문제점\n[1] "},{"type":"span","marks":["underline"],"value":"보호 기능이 없음."},{"type":"span","value":"\n➡️ 잘못된 주소를 생성하여 다른 프로세스나 운영체제의 메모리를 불법적으로 접근할 수 있음.\n[2] "},{"type":"span","marks":["underline"],"value":"한 번 배치되면 추후 주소 공간을 재배치하는 것이 어려움."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"4️⃣ 하드웨어 지원: 요약"}]},{"type":"heading","level":3,"children":[{"type":"span","value":"특권 모드(또는 커널 모드)"}]},{"type":"paragraph","children":[{"type":"span","value":"응용 프로그램이 실행되는 사용자 모드와 달리 컴퓨터 전체에 대한 접근 권한을 가지며 운영체제가 실행되는 CPU 모드이다."}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"프로세서 상태 워드(processor status word)"},{"type":"span","value":" 레지스터의 한 비트가 CPU의 현재 실행 모드를 나타낸다."}]},{"type":"paragraph","children":[{"type":"span","value":"시스템 콜 또는 예외 및 인터럽트 발생 시와 같은 특정 순간에 CPU가 모드를 전환한다."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"베이스/바운드 레지스터"}]},{"type":"paragraph","children":[{"type":"span","value":"CPU는 "},{"type":"span","marks":["highlight"],"value":"메모리 관리 장치(MMU)"},{"type":"span","value":"의 일부인 추가의 레지스터 쌍(베이스/바운드 레지스터)을 가짐."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"가상 주소를 변환하고 범위 안에 있는지 검사하는 능력"}]},{"type":"paragraph","children":[{"type":"span","value":"가상 주소의 변환\n➡️ 프로그램이 실행 중인 경우, 하드웨어는 "},{"type":"span","marks":["underline"],"value":"프로그램이 생성한 가상 주소에 베이스 값을 더하여 주소를 변환"}]},{"type":"paragraph","children":[{"type":"span","value":"하드웨어의 주소 유효성 검사\n➡️ 바운드 레지스터와 CPU 내의 일부 회로를 사용하여 이루어짐."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"베이스/바운드를 갱신하기 위한 특권 명령어"}]},{"type":"paragraph","children":[{"type":"span","marks":["underline"],"value":"다른 프로세스를 실행시킬 때"},{"type":"span","value":" 운영체제가 이 명령어를 사용하여 베이스와 바운드 레지스터의 값을 변경"}]},{"type":"paragraph","children":[{"type":"span","value":"이 명령어들은 특권 명령어이므로 특권 모드(커널 모드)에서만 레지스터를 변경할 수 있음."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"예외 발생 기능 및 예외 핸들러 등록을 위한 특권 명령어"}]},{"type":"paragraph","children":[{"type":"span","value":"CPU는 사용자 프로그램이 "},{"type":"span","marks":["underline"],"value":"바운드를 벗어난 주소로 불법적인 메모리 접근을 시도"},{"type":"span","value":"하려는 상황에서 "},{"type":"span","marks":["highlight"],"value":"예외"},{"type":"span","value":"를 발생시킬 수 있어야 함.\n➡️ \"바운드 벗어남\" "},{"type":"span","marks":["highlight"],"value":"예외 핸들러(exception handler)"},{"type":"span","value":"가 실행"}]},{"type":"paragraph","children":[{"type":"span","value":"사용자 프로그램이 "},{"type":"span","marks":["underline"],"value":"베이스와 바운드 레지스터 값의 변경"},{"type":"span","value":"을 시도\n➡️ 예외 발생 및 \"사용자 모드에서의 특권 연산 발생\" 핸들러 실행"}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"5️⃣ 운영체제 이슈"}]},{"type":"paragraph","children":[{"type":"span","value":"하드웨어 지원 + 운영체제 관리 = 간단한 가상 메모리 구현"}]},{"type":"paragraph","children":[{"type":"span","value":"베이스와 바운드 방식의 가상 메모리 구현을 위해서 운영체제가 반드시 개입되어야 하는 중요한 몇 시점이 존재"}]},{"type":"paragraph","children":[{"type":"span","value":"["},{"type":"span","marks":["highlight"],"value":"1. 프로세스 생성 시 운영체제는 주소 공간이 저장될 메모리 공간을 찾아 조치를 취해야 함."},{"type":"span","value":"]"}]},{"type":"paragraph","children":[{"type":"span","value":"운영체제는 물리 메모리를 슬롯의 배열로 보고 각 슬롯의 사용여부를 관리"}]},{"type":"paragraph","children":[{"type":"span","value":"🚀 새로운 프로세스 생성 시\n➡️ 운영체제는 새로운 주소 공간 할당에 필요한 영역을 찾기 위해 자료 구조(흔히 "},{"type":"span","marks":["highlight"],"value":"빈 공간 리스트(free list)"},{"type":"span","value":"라고 불림)를 검색\n➡️ 검색을 통해 선택된 공간을 사용 중이라고 표시"}]},{"type":"paragraph","children":[{"type":"span","value":"2️⃣의 재배치 예시에서 비어 있는 두 슬롯(16KB-32KB와 48KB-64KB)이 "},{"type":"span","marks":["highlight"],"value":"빈 공간 리스트"},{"type":"span","value":"로 구성됨."}]},{"type":"paragraph","children":[{"type":"span","value":"["},{"type":"span","marks":["highlight"],"value":"2. 프로세스 종료 시 프로세스가 사용하던 메모리 회수 및 다른 프로세스/운영체제가 사용할 수 있도록 조치"},{"type":"span","value":"]"}]},{"type":"paragraph","children":[{"type":"span","value":"프로세스가 종료하면, 운영체제는 종료한 프로세스의 메모리를 다시 빈 공간 리스트에 넣고 연관된 자료 구조를 모두 정리"}]},{"type":"paragraph","children":[{"type":"span","value":"["},{"type":"span","marks":["highlight"],"value":"3. 운영체제는 문맥 교환이 일어날 때에도 몇 가지 추가 조치를 취해야 함."},{"type":"span","value":"]"}]},{"type":"paragraph","children":[{"type":"span","value":"CPU마다 한 쌍의 베이스-바운드 레지스터만 존재 & 실행 중인 프로그램마다 다른 베이스-바운드 값\n➡️ 운영체제는 프로세스 전환 시 베이스와 바운드 쌍을 저장하고 복원해야 함."}]},{"type":"paragraph","children":[{"type":"span","value":"⛔ 실행 중인 프로세스 중단 결정 시\n➡️ 운영체제는 메모리에 존재하는 프로세스 별 자료 구조("},{"type":"span","marks":["highlight"],"value":"프로세스 구조체(process structure)"},{"type":"span","value":" 또는 "},{"type":"span","marks":["highlight"],"value":"프로세스 제어 블록(process control block, PCB)"},{"type":"span","value":") 안에 베이스와 바운드 레지스터의 값을 저장\n➡️ 운영체제가 메모리의 현 위치에서 다른 위치로 주소 공간을 비교적 쉽게 옮길 수 있음.(새 위치로 주소 공간 복사 후 프로세스 구조체의 베이스 레지스터를 갱신하여 새 위치를 가리키도록 함.)"}]},{"type":"paragraph","children":[{"type":"span","value":"🚀 프로세스 실행 시\n➡️ 해당 프로세스에 맞는 값으로 CPU의 베이스와 바운드 값을 설정"}]},{"type":"paragraph","children":[{"type":"span","value":"["},{"type":"span","marks":["highlight"],"value":"4. 운영체제는 예외 핸들러 또는 호출될 함수를 제공해야 함."},{"type":"span","value":"]"}]},{"type":"paragraph","children":[{"type":"span","value":"운영체제는 부팅할 때 특권 명령어를 사용하여 이 핸들러를 설치"}]},{"type":"paragraph","children":[{"type":"span","value":"운영체제는 예외(프로세스가 바운드 밖의 메모리에 접근 등)가 발생할 때 조치를 취할 준비가 되어 있어야 함."}]},{"type":"paragraph","children":[{"type":"span","value":"불법 행위를 한 프로세스 ➡️ 종료"}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"🧺 주소 변환의 원리 정리 하기"}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"주소 변환"},{"type":"span","value":" 사용 ➡️ 운영체제는 프로세스의 모든 메모리 접근을 제어 & 접근이 항상 주소 공간의 범위 내에서 이루어지도록 보장"}]},{"type":"paragraph","children":[{"type":"span","value":"주소 변환의 효율성의 열쇠 = "},{"type":"span","marks":["highlight"],"value":"하드웨어 지원\n"},{"type":"span","value":"➡️ 가상 주소에서 물리 주소로의 변환을 빠르게 수행"}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"베이스와 바운드(base-and-bound)"},{"type":"span","value":" 또는 "},{"type":"span","marks":["highlight"],"value":"동적 재배치"},{"type":"span","value":"\n➡️ 베이스 레지스터를 가상 주소에 더하고 생성된 주소가 바운드를 벗어나는지 검사하기 위한 간단한 하드웨어 회로만 추가하면 되므로 매우 효율적"}]},{"type":"paragraph","children":[{"type":"span","value":"base-and-bound 가상화의 "},{"type":"span","marks":["highlight"],"value":"보호"},{"type":"span","value":" 기능의 제공\n➡️ 프로세스가 자신의 주소 공간 이외의 메모리는 참조할 수 없도록 함."}]},{"type":"paragraph","children":[{"type":"span","value":"동적 재배치는 비효율적\n➡️ 2️⃣의 재배치 예시에서 프로세스 스택과 힙이 아주 크지 않기 때문에, 둘 사이의 공간이 낭비됨.\n➡️ "},{"type":"span","marks":["highlight"],"value":"내부 단편화(internal fragmentation)"},{"type":"span","value":" 발생"}]},{"type":"paragraph","children":[{"type":"span","value":"물리 메모리의 이용률을 높이고 내부 단편화를 방지하기 위해 더 정교한 기법이 필요\n➡️ 일반화된 base-and-bound 기법 = "},{"type":"span","marks":["highlight"],"value":"세그멘테이션(segmentation)"}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"📚 참고 문헌"}]},{"type":"paragraph","children":[{"url":"https://pages.cs.wisc.edu/~remzi/OSTEP/vm-mechanism.pdf","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"Operating Systems: Three Easy Pieces ― 15: Mechanism: Address Translation"}]}]},{"type":"paragraph","children":[{"url":"https://pages.cs.wisc.edu/~remzi/OSTEP/Korean/15-vm-mechanism.pdf","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"운영체제 아주 쉬운 세 가지 이야기 ― 18: 주소 변환의 원리"}]}]}]}}}}},"pageContext":{"id":"176854321","locale":"ko-KR"}},"staticQueryHashes":["1034768456","1118752904","2342916782","2757196681","3415878905","3879866231","4195094990"]}