{"componentChunkName":"component---src-templates-article-jsx","path":"/blog/development/os-io-devices","result":{"data":{"datoCmsMiscTextString":{"locale":"ko-KR","updatedAtText":"업데이트됨","nextReadText":"관련있는 게시물"},"datoCmsBlogPost":{"locale":"ko-KR","originalId":"204656768","title":"[운영체제][OSTEP] I/O 장치","seo":{"seoTitle":"[운영체제][OSTEP] I/O 장치","seoDescription":"시스템에 I/O를 통합하는 방법에 대해 공부해봅니다.","seoImage":{"seoImageUrl":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format"}},"subtitle":"시스템에 I/O를 통합하는 방법에 대해 공부해봅니다.","coverImage":{"coverImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&w=860","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.25&w=860 215w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.5&w=860 430w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&w=860 860w","sizes":"(min-width: 860px) 860px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgLCgoLDhMVDhcNDh0VDxUSGhYdHSIVFhUaKysjGh0oHSEWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLCgUFEBAOEC8oIhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIAAwAGAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAFAQQGAP/EAB0QAAEEAgMAAAAAAAAAAAAAAAEAAgMEESEFEjL/xAAWAQADAAAAAAAAAAAAAAAAAAAAAQP/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwDD1KM1uPLjpIRUI4GZc4aRXH25hTOHqqbth7yDIVIiXI2IQzqCoREhL/RyuQH/2Q=="},"width":860,"height":430}},"meta":{"updatedAt":"2023-10-04T16:59:40.840+09:00","firstPublishedAt":"2023-09-30T17:37:02.567+09:00"},"categoryLink":{"title":"개발 공부","id":"4743072"},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorPictureData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 60px) 60px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgWEQ8LDhgYDhUNDhgNDw8NFxUdGBYfFhUaHysjGikoHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OHBANHDUcIig7NS81NS81MjUvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAFAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAABQYHAv/EAB4QAAICAgMBAQAAAAAAAAAAAAABAgMFBgQRQXEi/8QAFQEBAQAAAAAAAAAAAAAAAAAABAP/xAAaEQACAwEBAAAAAAAAAAAAAAAAAQIDEhMR/9oADAMBAAIRAxEAPwDT8/1LHSK/r67scevSfz99VXBkm/Cva/zKle/pCc/JoRXWsFujxvygcLI1pAXqQTmjONm2RzpceyCwmwxpsbbADWJdBFbeCfe2wXoAGpIL6z//2Q=="},"width":60,"height":60}}},"relatedPosts":[],"structuredBody":{"blocks":[],"links":[],"value":{"schema":"dast","document":{"type":"root","children":[{"type":"heading","level":2,"children":[{"type":"span","value":"1️⃣ 시스템 구조"}]},{"type":"paragraph","children":[{"type":"span","value":"먼저 일반적인 시스템 구조를 살펴보자."}]},{"code":"   ┌───────┐    ┌────────┐\n   │  CPU  │    │ Memory │\n   └───┬───┘    └────┬───┘\n       │             │\n←──────┴──────┬──────┴──────→ Memory Bus\n              │               (proprietary)\n              │\n←─────────────┼──────┬──────→ General I/O Bus\n              │ ┌────┴─────┐  (e.g., PCI)\n              │ │ Graphics │\n              │ └──────────┘\n              │\n←──┬──────┬───┴───┬──────┬──→ Peripheral I/O Bus\n ┌─┴─┐  ┌─┴─┐   ┌─┴─┐  ┌─┴─┐  (e.g., SCSI, SATA, USB)\n │   │  │   │   │   │  │   │\n └───┘  └───┘   └───┘  └───┘","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"위 그림에서는 CPU와 주메모리가 "},{"type":"span","marks":["highlight"],"value":"메모리 버스"},{"type":"span","value":"로 연결되어 있다."}]},{"type":"paragraph","children":[{"type":"span","value":"또한 몇 가지 장치들(위 그림에서는 그래픽)이 범용 "},{"type":"span","marks":["highlight"],"value":"I/O 버스"},{"type":"span","value":"에 연결되어 있다.\n➡️ 많은 현대의 시스템에서는 PCI(또는 많은 파생 버스)를 사용하고 있다."}]},{"type":"paragraph","children":[{"type":"span","value":"마지막으로, 그 아래에는 "},{"type":"span","marks":["highlight"],"value":"SCSI"},{"type":"span","value":"나 "},{"type":"span","marks":["highlight"],"value":"SATA"},{"type":"span","value":" 또는 "},{"type":"span","marks":["highlight"],"value":"USB"},{"type":"span","value":"와 같은 "},{"type":"span","marks":["highlight"],"value":"주변장치용 버스"},{"type":"span","value":"가 있다.\n➡️ 이 버스들을 통해 "},{"type":"span","marks":["highlight"],"value":"디스크"},{"type":"span","value":", "},{"type":"span","marks":["highlight"],"value":"마우스"},{"type":"span","value":"와 같은 가장 느린 장치들이 연결된다."}]},{"type":"paragraph","children":[{"type":"span","value":"🤔 왜 이런 계층적인 구조가 필요할까?\n➡️ 물리학적인 이유와 비용 때문"}]},{"type":"paragraph","children":[{"type":"span","value":"버스가 고속화되려면 더 짧아져야 하는데, 그런 고속의 메모리 버스는 여러 장치들을 수용할 공간이 없고, 고속의 성능을 내는 버스를 만드는 기술은 꽤 비쌈.\n➡️ 따라서 시스템 설계자들은 "},{"type":"span","marks":["highlight"],"value":"계층적 구조"},{"type":"span","value":"를 택하여 (그래픽 카드와 같이) "},{"type":"span","marks":["highlight"],"value":"고성능 장치들을 CPU에 가깝게 배치하였고 느린 성능의 장치들을 그보다 멀리 배치함."}]},{"type":"paragraph","children":[{"type":"span","value":"✅ 디스크처럼 느린 장치들을 주변 장치 I/O 버스에 연결하여 얻을 수 있는 이득은 많은데, 특히 많은 장치들을 연결할 수 있음."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"2️⃣ 표준 장치"}]},{"type":"paragraph","children":[{"type":"span","value":"이번에는 가상의 표준 장치를 살펴보고 이 장치를 효율적으로 활용하기 위해 필요한 것은 무엇인지 알아보자."}]},{"type":"paragraph","children":[{"type":"span","value":"다음과 같은 표준 장치를 생각해보자. 두 개의 중요한 요소가 있다. "}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"인터페이스"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"레지스터(상태, 명령, 데이터)"}]}]}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"내부 장치"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"마이크로 컨트롤러(CPU)"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"메모리(DRAM 또는 SRAM 또는 모두)"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"다른 하드웨어에 특화된 칩"}]}]}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"첫 번째는 시스템의 다른 구성 요소에게 제공하는 하드웨어 "},{"type":"span","marks":["highlight"],"value":"인터페이스"},{"type":"span","value":"이다."}]},{"type":"paragraph","children":[{"type":"span","value":"💡 소프트웨어가 인터페이스를 제공하듯이 "},{"type":"span","marks":["highlight"],"value":"하드웨어도 인터페이스를 제공하여 시스템 소프트웨어가 동작을 제어"},{"type":"span","value":"할 수 있도록 해야 한다.\n➡️ ✅ 그러므로 모든 하드웨어 장치들은 특정한 상호 동작을 위한 방식과 명시적인 인터페이스를 갖고 있다."}]},{"type":"paragraph","children":[{"type":"span","value":"두 번째는 "},{"type":"span","marks":["highlight"],"value":"내부 구조"},{"type":"span","value":"이다."}]},{"type":"paragraph","children":[{"type":"span","value":"💡 구현 방법에 따라 다르지만 "},{"type":"span","marks":["highlight"],"value":"내부 구조는 시스템에게 제공하는 장치에 대한 추상화를 정의하는 책임"},{"type":"span","value":"을 갖고 있다.\n➡️ 매우 단순한 장치들은 하나 또는 몇 개의 하드웨어 칩을 사용하여 기능을 구현\n➡️ ✅ 좀 더 복잡한 장치는 단순한 CPU와 범용 메모리 그리고 장치에 특화된 칩들을 사용하여 목적에 맞는 동작을 함.\n➡️ ✅ 최신 RAID 컨트롤러는 수십만 줄에 달하는 "},{"type":"span","marks":["highlight"],"value":"펌웨어(firmware)"},{"type":"span","value":"라는 소프트웨어가 하드웨어 내부의 동작을 정의"}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"3️⃣ 표준 방식"}]},{"type":"paragraph","children":[{"type":"span","value":"위에서 가정한 표준 장치의 인터페이스는 세 개의 레지스터(상태, 명령, 데이터)로 구성되어 있는 것을 확인할 수 있다."}]},{"type":"paragraph","children":[{"type":"span","value":"각각의 레지스터를 설명하면 다음과 같다."}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"상태(status)"},{"type":"span","value":" 레지스터: 장치의 현재 상태를 읽을 수 있음."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"명령어(command)"},{"type":"span","value":" 레지스터: 장치가 특정 동작을 수행하도록 요청할 때 사용"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"데이터(data)"},{"type":"span","value":" 레지스터: 장치에 데이터를 보내거나 받을 때 사용"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"✅ 이 레지스터들을 읽거나 쓰는 것을 통해 운영체제는 장치의 동작을 제어할 수 있음."}]},{"type":"paragraph","children":[{"type":"span","value":"이번에는 장치가 운영체제를 대신하여 특정 동작을 할 때에 운영체제와 장치 간에 일어날 수 있는 상호 동작의 과정을 살펴보자."}]},{"code":"While (STATUS == BUSY); // 장치가 바쁜 상태가 아닐 때까지 대기\n데이터를 DATA 레지스터에 쓰기\n명령어를 COMMAND 레지스터에 쓰기\n    (그러면 장치가 명령어를 실행한다)\nWhile (STATUS == BUSY); // 요청을 처리하여 완료할 때까지 대기","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"방식은 네 단계로 이루어져 있다."}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"먼저 반복적으로 장치의 상태 레지스터를 읽어서 명령의 수신 가능 여부를 확인"}]},{"type":"paragraph","children":[{"type":"span","value":"➡️ 이 동작은 장치에 대해 "},{"type":"span","marks":["highlight"],"value":"폴링(polling)"},{"type":"span","value":"한다고 표현함."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"운영체제가 데이터 레지스터에 어떤 데이터를 전달"}]},{"type":"paragraph","children":[{"type":"span","value":"➡️ 데이터 전송에 메인 CPU가 관여하는 경우를 "},{"type":"span","marks":["highlight"],"value":"programmed I/O"},{"type":"span","value":"라고 부름."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"운영체제가 명령 레지스터에 명령어를 기록"}]},{"type":"paragraph","children":[{"type":"span","value":"➡️ 이 레지스터에 명령어가 기록되면 데이터는 이미 준비되었다고 판단하고 명령어를 처리"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"운영체제는 디바이스가 처리를 완료했는지 확인하는 폴링 반복문을 돌면서 대기"}]},{"type":"paragraph","children":[{"type":"span","value":"➡️ 성공과 실패를 알리는 에러 코드를 받게 됨."}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 기본 방식은 방식이 간단하며 제대로 작동하지만, 매우 비효율적임."}]},{"type":"paragraph","children":[{"type":"span","value":"다른 프로세스에게 CPU를 양도하지 않고, 장치가 동작을 완료할 동안 계속 루프를 돌면서 장치상태를 체크하고 있음.\n➡️ 매우 비효율적인 폴링을 사용\n➡️ CPU 시간을 많이 소모"}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"4️⃣ 인터럽트를 이용한 CPU 오버헤드 개선"}]},{"type":"paragraph","children":[{"type":"span","value":"디바이스를 폴링하는 대신 운영체제는 입출력 작업을 요청한 프로세스를 블록 시키고 CPU를 다른 프로세스에게 양도함."}]},{"type":"paragraph","children":[{"type":"span","value":"✅ 장치가 작업을 끝마치고 나면 하드웨어 인터럽트를 발생시키고 CPU는 운영체제가 미리 정의 해놓은 "},{"type":"span","marks":["highlight"],"value":"인터럽트 서비스 루틴(interrupt service routine(ISR))"},{"type":"span","value":" 또는 간단하게 "},{"type":"span","marks":["highlight"],"value":"인터럽트 핸드러(interrupt handler)"},{"type":"span","value":"를 실행\n➡️ 이 핸들러는 운영체제 코드의 일부"}]},{"type":"paragraph","children":[{"type":"span","value":"인터럽트 핸들러는 입출력 요청의 완료(데이터와 장치가 전달하는 에러 코드를 읽는 것 등), I/O를 대기 중인 프로세스 깨우기 등을 담당"}]},{"type":"paragraph","children":[{"type":"span","value":"💡 사용률을 높이기 위한 핵심 방법 중 하나는 인터럽트를 활용하여 CPU 연산과 I/O를 "},{"type":"span","marks":["highlight"],"value":"중첩"},{"type":"span","value":"시키는 것"}]},{"type":"paragraph","children":[{"type":"span","value":"다음의 시간표는 폴링을 사용할 때를 나타낸다."}]},{"code":"CPU   1 1 1 1 1 p p p p p 1 1 1 1 1\nDisk            1 1 1 1 1","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"CPU에서 프로세스 1이 일정 시간 동안 실행되다가(1로 표현) 디스크의 데이터를 읽기 위해 I/O 요청을 발생시키면, 시스템은 I/O가 완료될 때까지 반복적으로 장치의 상태를 폴링함.(p로 표현)\n➡️ 디스크가 요청의 처리를 완료하면 다시 프로세스 1이 동작할 수 있음."}]},{"type":"paragraph","children":[{"type":"span","value":"다음의 시간표는 인터럽트를 사용할 때를 나타낸다."}]},{"code":"CPU   1 1 1 1 1 2 2 2 2 2 1 1 1 1 1\nDisk            1 1 1 1 1","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"💡 인터럽트를 사용하여 연산과 I/O 작업을 중첩시킬 수 있다면 운영체제는 디스크의 응답을 기다리면서 다른 일을 할 수 있다."}]},{"type":"paragraph","children":[{"type":"span","value":"위의 예시에서는 프로세스 1의 요청이 디스크에서 처리되는 동안 운영체제는 프로세스 2를 CPU에서 실행시키고 디스크 요청이 완료되어 인터럽트가 발생하면 운영체제가 프로세스 1을 깨워 다시 실행시킨다.\n➡️ ✅ CPU와 디스크가 시간 흐름표의 중간 부분에서 적절히 활용됨."}]},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 하지만, 인터럽트가 항상 최적의 해법은 아니란 것에 유의해야 함."}]},{"type":"paragraph","children":[{"type":"span","value":"예를 들어, 대부분 작업이 한 번의 폴링만으로 끝날 정도로 매우 빠른 장치인 경우\n➡️ 인터럽트를 사용하면 시스템이 느려지게 됨.(문맥 교환은 매우 costly)"}]},{"type":"paragraph","children":[{"type":"span","value":"💡 그러므로 "},{"type":"span","marks":["highlight"],"value":"빠른 장치라면 폴링이 최선이고 느리다면 인터럽트를 사용하여 중첩시키는 것이 최선임."}]},{"type":"paragraph","children":[{"type":"span","value":"만약 장치의 속도를 모른다거나 빠를 때도 있고 느릴 때도 있는 장치라고 한다면, 짧은 시간 동안만 폴링을 하다가 처리가 완료되지 않으면 인터럽트를 사용하는 "},{"type":"span","marks":["highlight"],"value":"하이브리드"},{"type":"span","value":" 방식을 채용하는 것이 최선일 것\n➡️ 이와 같은 "},{"type":"span","marks":["highlight"],"value":"두 단계"},{"type":"span","value":" 접근법으로 양쪽의 장점만 취할 수 있음."}]},{"type":"paragraph","children":[{"type":"span","value":"인터럽트를 사용하지 않는 다른 이유는 네트워크 환경에서 찾아볼 수 있음."}]},{"type":"paragraph","children":[{"type":"span","value":"대량으로 도착하는 패킷이 있을 때에 각 패킷마다 인터럽트가 발생\n➡️ ⚠️ 이 경우 인터럽트만 처리하다가 운영체제가 사용자 프로세서의 요청을 처리할 수 없도록 만드는 "},{"type":"span","marks":["highlight"],"value":"무한반복(livelock)"},{"type":"span","value":"에 빠질 가능성이 있음."}]},{"type":"paragraph","children":[{"type":"span","value":"예를 들어, \""},{"url":"https://ko.wikipedia.org/wiki/%EC%8A%AC%EB%9E%98%EC%8B%9C%EB%8B%B7_%ED%9A%A8%EA%B3%BC","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"슬래시닷(slashdot) 현상"}]},{"type":"span","value":"\"으로 인해 일시적으로 웹 서버에 사용자가 많이 몰리는 경우\n➡️ ✅ 폴링을 사용하면 시스템의 상황을 보다 효율적으로 제어할 수 있음.\n➡️ 웹 서버가 패킷 도착을 검사하기 전에 사용자 요청들을 좀 더 처리할 수 있기 때문"}]},{"type":"paragraph","children":[{"type":"span","value":"또 다른 인터럽트 기반의 최적화 기법은 "},{"type":"span","marks":["highlight"],"value":"병합(coalescing)"},{"type":"span","value":"임.\n➡️ 이 환경에서는 CPU에 인터럽트를 전달하기 전에 잠시 기다렸다가 인터럽트를 발생시킴."}]},{"type":"paragraph","children":[{"type":"span","value":"💡 기다리는 동안에 다른 요청들도 끝나게 되기 때문에 여러 번 인터럽트를 발생시키는 대신 인터럽트를 한 번만 CPU에 전달하게 됨.\n➡️ 이 방법으로 인터럽트 처리의 오버헤드를 줄일 수 있음."}]},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 물론, 너무 오래 기다리면 요청에 대한 지연 시간이 늘어나기 때문에 시스템의 절충 시간을 찾아야 함."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"5️⃣ DMA를 이용한 효율적인 데이터 이동"}]},{"type":"paragraph","children":[{"type":"span","value":"앞서 설명한 표준 방식에서 고려해야 하는 부분이 하나 더 있음."}]},{"type":"paragraph","children":[{"type":"span","value":"많은 양의 데이터를 디스크로 전달하기 위해 programmed I/O(PIO)를 사용하면 CPU가 또 다시 단순 작업 처리에 소모됨.\n➡️ 다른 프로세스를 처리하기 위해 사용될 수 있는 많은 시간을 허비하게 됨."}]},{"type":"paragraph","children":[{"type":"span","value":"다음의 시간 흐름표가 그 문제를 나타낸다."}]},{"code":"CPU   1 1 1 1 1 c c c 2 2 2 2 2 1 1\nDisk                  1 1 1 1 1","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"프로세스 1이 실행 도중에 디스크에 어떤 데이터를 기록하고자 I/O를 발생시켜서 명시적으로 데이터를 메모리에서 디스크로 한 워드씩 복사(c로 표기)하고 복사가 완료되면 디스크에서 I/O의 처리를 시작하고, 마침내 CPU를 다른 작업 처리에 사용할 수 있게 됨.\n➡️ PIO의 오버헤드를 줄여야 함."}]},{"type":"paragraph","children":[{"type":"span","value":"이 문제에 대한 해법을 "},{"type":"span","marks":["highlight"],"value":"직접 메모리 접근 방식(Direct Memory Access, DMA)"},{"type":"span","value":"이라고 부름."}]},{"type":"paragraph","children":[{"type":"span","value":"DMA 엔진은 시스템 내에 있는 특수 장치로서 CPU의 간섭없이 메모리와 장치 간에 전송을 담당함."}]},{"type":"paragraph","children":[{"type":"span","value":"DMA는 다음과 같이 동작함."}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"데이터를 장치로 전송하는 경우"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"운영체제는 DMA 엔진에 메모리 상의 데이터 위치와 전송할 데이터의 크기와 대상 장치를 프로그램함."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"그 시점에 전송하기 위해 할 일은 끝나기 때문에 운영체제는 다른 일을 진행할 수 있음."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"DMA 동작이 끝나면 DMA 컨트롤러가 인터럽트를 발생시켜 운영체제가 전송이 완료되었음을 알 수 있도록 함."}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"수정된 시간 흐름표는 다음과 같다."}]},{"code":"CPU   1 1 1 1 1 2 2 2 2 2 2 2 2 1 1\nDMA             c c c    \nDisk                  1 1 1 1 1","type":"code"},{"type":"paragraph","children":[{"type":"span","value":""}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"6️⃣"}]},{"type":"paragraph","children":[{"type":"span","value":""}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"7️⃣"}]},{"type":"paragraph","children":[{"type":"span","value":""}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"8️⃣"}]},{"type":"paragraph","children":[{"type":"span","value":""}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"9️⃣"}]},{"type":"paragraph","children":[{"type":"span","value":""}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"📚 참고 문헌"}]},{"type":"paragraph","children":[{"url":"https://pages.cs.wisc.edu/~remzi/OSTEP/file-devices.pdf","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"Operating Systems: Three Easy Pieces ― 36: I/O Devices"}]}]},{"type":"paragraph","children":[{"url":"https://pages.cs.wisc.edu/~remzi/OSTEP/Korean/36_file-devices.pdf","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"운영체제 아주 쉬운 세 가지 이야기 ― 39: I/O 장치"}]}]}]}}}}},"pageContext":{"id":"204656768","locale":"ko-KR"}},"staticQueryHashes":["1034768456","1118752904","2342916782","2757196681","3415878905","3879866231","4195094990"]}