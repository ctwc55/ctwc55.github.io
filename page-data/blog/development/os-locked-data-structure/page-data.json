{"componentChunkName":"component---src-templates-article-jsx","path":"/blog/development/os-locked-data-structure","result":{"data":{"datoCmsMiscTextString":{"locale":"ko-KR","updatedAtText":"업데이트됨","nextReadText":"관련있는 게시물"},"datoCmsBlogPost":{"locale":"ko-KR","originalId":"189836506","title":"[운영체제][OSTEP] 락 기반의 병행 자료 구조","seo":{"seoTitle":"[운영체제][OSTEP] 락 기반의 병행 자료 구조","seoDescription":"자료 구조에 락을 추가하여 쓰레드 사용에 안전한 구조를 만드는 방법에 대해 공부해봅니다.","seoImage":{"seoImageUrl":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format"}},"subtitle":"자료 구조에 락을 추가하여 쓰레드 사용에 안전한 구조를 만드는 방법에 대해 공부해봅니다.","coverImage":{"coverImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&w=860","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.25&w=860 215w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.5&w=860 430w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&w=860 860w","sizes":"(min-width: 860px) 860px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgLCgoLDhMVDhcNDh0VDxUSGhYdHSIVFhUaKysjGh0oHSEWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLCgUFEBAOEC8oIhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIAAwAGAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAFAQQGAP/EAB0QAAEEAgMAAAAAAAAAAAAAAAEAAgMEESEFEjL/xAAWAQADAAAAAAAAAAAAAAAAAAAAAQP/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwDD1KM1uPLjpIRUI4GZc4aRXH25hTOHqqbth7yDIVIiXI2IQzqCoREhL/RyuQH/2Q=="},"width":860,"height":430}},"meta":{"updatedAt":"2023-08-28T15:47:12.013+09:00","firstPublishedAt":"2023-08-22T22:47:21.442+09:00"},"categoryLink":{"title":"개발 공부","id":"4743072"},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorPictureData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 60px) 60px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgWEQ8LDhgYDhUNDhgNDw8NFxUdGBYfFhUaHysjGikoHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OHBANHDUcIig7NS81NS81MjUvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAFAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAABQYHAv/EAB4QAAICAgMBAQAAAAAAAAAAAAABAgMFBgQRQXEi/8QAFQEBAQAAAAAAAAAAAAAAAAAABAP/xAAaEQACAwEBAAAAAAAAAAAAAAAAAQIDEhMR/9oADAMBAAIRAxEAPwDT8/1LHSK/r67scevSfz99VXBkm/Cva/zKle/pCc/JoRXWsFujxvygcLI1pAXqQTmjONm2RzpceyCwmwxpsbbADWJdBFbeCfe2wXoAGpIL6z//2Q=="},"width":60,"height":60}}},"relatedPosts":[{"id":"187813035","meta":{"updatedAt":"2023-08-22T22:47:51.945+09:00"},"categoryLink":{"title":"개발 공부"},"coverImage":{"gatsbyImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.09&w=860 75w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.18&w=860 150w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860 300w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.7&w=860 600w","sizes":"(min-width: 300px) 300px, 100vw"}},"layout":"constrained","width":300,"height":120},"squaredImage":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.06&fit=crop&fp-x=0.5&fp-y=0.5&w=430 25w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.12&fit=crop&fp-x=0.5&fp-y=0.5&w=430 50w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430 100w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.47&fit=crop&fp-x=0.5&fp-y=0.5&w=430 200w","sizes":"(min-width: 100px) 100px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBhINEBAQCggUDg0IDgcHFh0JFhEYFxUZGCIVFhUaHysjGh0oHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OEg4REC8dFhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAGAMBIgACEQEDEQH/xAAaAAEBAAIDAAAAAAAAAAAAAAAABAUGAQID/8QAHRAAAgICAwEAAAAAAAAAAAAAAAIDBAEREhQVBf/EABYBAQEBAAAAAAAAAAAAAAAAAAADAf/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/ANASs2WLoaraMl1o0O241wSYlSHjgHM9hVAEFr6bKSemzAAeclpnAAH/2Q=="},"width":100,"height":100}},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.11&w=77 8w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 30px) 30px, 100vw"}},"layout":"constrained","width":30,"height":30}}},"subtitle":"임계 영역에서의 원자적인 실행을 위한 락에 대해 공부해봅니다.","title":"[운영체제][OSTEP] 락"}],"structuredBody":{"blocks":[],"links":[],"value":{"schema":"dast","document":{"type":"root","children":[{"type":"heading","level":2,"children":[{"type":"span","value":"🚪 들어가며"}]},{"type":"paragraph","children":[{"type":"span","value":"💡 "},{"type":"span","marks":["highlight"],"value":"쓰레드 사용에 안전(쓰레드 안전, thread safe)"},{"type":"span","value":"한 구조\n자료 구조에 락을 추가하여 쓰레드가 사용할 수 있도록 만든 것"}]},{"type":"paragraph","children":[{"type":"span","value":"이번 챕터에서는 "},{"type":"span","marks":["highlight"],"value":"특정 자료 구조에 어떤 방식으로 락을 추가"},{"type":"span","value":"해야 그 자료 구조가 "},{"type":"span","marks":["highlight"],"value":"정확하게 동작"},{"type":"span","value":"하게 만들 수 있을지, "},{"type":"span","marks":["highlight"],"value":"자료 구조에 락을 추가"},{"type":"span","value":"하여 "},{"type":"span","marks":["highlight"],"value":"여러 쓰레드가 그 자료 구조를 동시 사용(병행성) 가능"},{"type":"span","value":"하도록 하는 방법에 대해 알아보자."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"1️⃣ 병행 카운터"}]},{"type":"paragraph","children":[{"type":"span","value":"카운터: 가장 간단한 자료 구조 중 하나(특정 원소가 몇 개 있는지 카운팅)"}]},{"type":"paragraph","children":[{"type":"span","value":"먼저 병행이 불가능한 카운터를 살펴보자."}]},{"code":"typedef struct __counter_t {\n  int value;\n} counter_t;\n\nvoid init(counter_t *c) {\n  c−>value = 0;\n}\n\nvoid increment(counter_t *c) {\n  c−>value++;\n}\n\nvoid decrement(counter_t *c) {\n  c−>value−−;\n}\n\nint get(counter_t *c) {\n  return c−>value;\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"다음은 락이 있는(쓰레드 안전(thread safe)한) 카운터이다."}]},{"code":"typedef struct __counter_t {\n  int value;\n  pthread_mutex_t lock;\n} counter_t;\n\nvoid init(counter_t *c) {\n  c−>value = 0;\n  Pthread_mutex_init(&c−>lock, NULL);\n}\n\nvoid increment(counter_t *c) {\n  Pthread_mutex_lock(&c−>lock);\n  c−>value++;\n  Pthread_mutex_unlock(&c−>lock);\n}\n\nvoid decrement(counter_t *c) {\n  Pthread_mutex_lock(&c−>lock);\n  c−>value−−;\n  Pthread_mutex_unlock(&c−>lock);\n}\n\nint get(counter_t *c) {\n  Pthread_mutex_lock(&c−>lock);\n  int rc = c−>value;\n  Pthread_mutex_unlock(&c−>lock);\n  return rc;\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"위에서 우리는 다음을 확인할 수 있다."}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"자료 구조를 조작하는 루틴을 호출할 때 락을 추가한다."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"루틴 호출 후 리턴 시 락이 해제된다."}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"위 방식은 "},{"type":"span","marks":["highlight"],"value":"모니터(monitor)"},{"type":"span","value":"를 사용하여 만든 자료 구조와 유사하다.\n🔖 모니터 기법: 객체에 대한 메소드를 호출하고 리턴할 때 자동적으로 락을 획득하고 해제"}]},{"type":"paragraph","children":[{"type":"span","value":"이 방식을 통해 제대로 동작하는 병행 자료 구조를 가질 수 있지만, "},{"type":"span","marks":["highlight"],"value":"성능 개선이 필요"},{"type":"span","value":"하다."}]},{"type":"paragraph","children":[{"type":"span","value":"이상적으로는 "},{"type":"span","marks":["highlight"],"value":"하나의 쓰레드가 하나의 CPU에서 작업을 끝내는 것처럼 멀티프로세서에서 실행되는 쓰레드들도 빠르게 작업을 처리"},{"type":"span","value":"하고 싶음.\n➡️ 이와 같은 것을 "},{"type":"span","marks":["highlight"],"value":"완벽한 확장성(perfect scaling)"},{"type":"span","value":"이라고 한다."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"확장성 있는 카운팅"}]},{"type":"paragraph","children":[{"type":"span","value":"확장성 있는 카운터는 중요한 의미를 갖는다.\n➡️ 확장 가능한 카운터가 없으면 Linux의 몇몇 작업은 멀티코어 기기에서 심각한 확장성 문제를 겪을 수 있음."}]},{"type":"paragraph","children":[{"type":"span","value":"이러한 기법들 중 "},{"type":"span","marks":["highlight"],"value":"엉성한 카운터(sloppy counter)"},{"type":"span","value":"라는 것을 살펴보자."}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"엉성한 카운터는 "},{"type":"span","marks":["highlight"],"value":"하나의 논리적 카운터로 표현"},{"type":"span","value":"됨."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"CPU 코어마다 존재하는 물리적인 지역 카운터"},{"type":"span","value":"와 "},{"type":"span","marks":["highlight"],"value":"하나의 전역 카운터"},{"type":"span","value":"로 구성"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"이 카운터들 외에 "},{"type":"span","marks":["highlight"],"value":"지역 카운터를 위한 락"},{"type":"span","value":"들과 "},{"type":"span","marks":["highlight"],"value":"전역 카운터를 위한 락"},{"type":"span","value":"이 존재"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"엉성한 카운터의 기본 개념은 다음과 같다."}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"쓰레드는 지역 카운터를 증가시킨다."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"해당 지역 카운터는 지역 락에 의해 보호된다."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"각 CPU 마다 지역 카운터가 존재하므로 CPU들에 분산된 쓰레드들은 지역 카운터를 경쟁 없이 갱신"}]},{"type":"paragraph","children":[{"type":"span","value":"➡️ 카운터 갱신은 확장성이 있음."}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"👀 쓰레드가 카운터의 값을 읽을 수 있음. ➡️ 전역 카운터를 최신 최신으로 갱신해야 함."}]},{"type":"paragraph","children":[{"type":"span","value":"🛒 그러기 위해 지역 카운터의 값은 주기적으로 전역 카운터로 전달\n➡️ 전역 락을 사용하여 지역 카운터의 값을 전역 카운터의 값에 더함.\n➡️ 해당 지역 카운터의 값은 0으로 초기화"}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"지역에서 전역으로 값을 전달하는 빈도"},{"type":"span","value":"는 정해 놓은 S(sloppiness의 앞 글자) 값에 의해 결정\n➡️ S의 값이 작을수록 확장성 없는 카운터처럼 동작\n➡️ 커질수록 전역 카운터의 값은 실제 값과 차이가 있게 됨.(CPU 개수 * S만큼 뒤처짐.)"}]},{"type":"paragraph","children":[{"type":"span","value":"정확한 카운터 값을 얻기 위해서는 모든 지역 락과 전역 락을 획득한 후 계산해야 함.\n➡️ ⚠️ 이 경우 확장성이 없게 됨.\n➡️ 지역 락을 획득하는 순서를 적절히 제어하지 않으면 교착 상태가 발생"}]},{"type":"paragraph","children":[{"type":"span","value":"다음의 예시와 함께 이를 조금 더 살펴보자."}]},{"code":"Time │   L1    L2    L3    L4   │ G\n─────┼──────────────────────────┼───────\n   0 │   0     0     0     0    │ 0\n   1 │   0     0     1     1    │ 0\n   2 │   1     0     2     1    │ 0\n   3 │   2     0     3     1    │ 0\n   4 │   3     0     3     2    │ 0\n   5 │   4     1     3     3    │ 0\n   6 │  5→0    1     3     4    │ 5(from L1)\n   7 │   0     2     4    5→0   │ 10(from L4)","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"위의 예시에서는 한계치를 5로 설정하였고 네 개의 CPU에 각각의 지역 카운터 L1 ... L4를 갱신하는 쓰레드들이 있다."}]},{"type":"paragraph","children":[{"type":"span","value":"만약 "},{"type":"span","marks":["highlight"],"value":"지역 카운터가 한계치 S에 도달"},{"type":"span","value":"하면 "},{"type":"span","marks":["highlight"],"value":"지역 값은 전역 카운터에 반영되고 지역 카운터의 값은 초기화"},{"type":"span","value":"된다."}]},{"type":"paragraph","children":[{"type":"span","value":"💡 엉성한 카운터는 정확도(낮은 S값)와 성능(높은 S값)의 균형을 조절할 수 있다."}]},{"type":"paragraph","children":[{"type":"span","value":"다음은 엉성한 카운터의 대략적인 코드이다."}]},{"code":"typedef struct __counter_t {\n    int global; // 전역 카운터\n    pthread_mutex_t glock; // 전역 카운터\n    int local[NUMCPUS]; // 지역 카운터(cpu당)\n    pthread_mutex_t llock[NUMCPUS]; // ... 그리고 락들\n    int threshold; // 갱신 빈도\n} counter_t;\n\n// init: 한계치를 기록하고 락과 지역 카운터\n// 그리고 전역 카운터의 값들을 초기화함\nvoid init(counter_t *c, int threshold) {\n    c−>threshold = threshold;\n    \n    c−>global = 0;\n    pthread_mutex_init(&c−>glock, NULL);\n    \n    int i;\n    for (i = 0; i < NUMCPUS; i++) {\n        c−>local[i] = 0;\n        pthread_mutex_init(&c−>llock[i], NULL);\n    }\n}\n\n// update: 보통은 지역 락을 획득한 후 지역 값을 갱신함\n// '한계치'까지 지역 카운터의 값이 커지면,\n// 전역 락을 획득하고 지역 값을 전역 카운터에 전달함\nvoid update(counter_t *c, int threadID, int amt) {\n    pthread_mutex_lock(&c−>llock[threadID]);\n    c−>local[threadID] += amt; // amt > 0을 가정\n    if (c−>local[threadID] >= c−>threshold) { // 전역으로 전달\n        pthread_mutex_lock(&c−>glock);\n        c−>global += c−>local[threadID];\n        pthread_mutex_unlock(&c−>glock);\n        c−>local[threadID] = 0;\n    }\n    pthread_mutex_unlock(&c−>llock[threadID]);\n}\n\n// get: 전역 카운터의 값을 리턴(정확하지 않을 수 있음)\nint get(counter_t *c) {\n    pthread_mutex_lock(&c−>glock);\n    int val = c−>global;\n    pthread_mutex_unlock(&c−>glock);\n    return val; // 대략의 값임!\n}","type":"code","language":"c"},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"2️⃣ 병행 연결 리스트"}]},{"type":"paragraph","children":[{"type":"span","value":"병행 삽입 연산을 중점적으로 살펴보도록 하자."}]},{"code":"// 기본 노드 구조\ntypedef struct __node_t {\n    int key;\n    struct __node_t *next;\n} node_t;\n\n// 기본 리스트 구조(리스트마다 하나씩 사용)\n\ntypedef struct __list_t {\n    node_t *head;\n    pthread_mutex_t lock;\n} list_t;\n\nvoid List_Init(list_t *L) {\n    L−>head = NULL;\n    pthread_mutex_init(&L−>lock, NULL);\n}\n\nint List_Insert(list_t *L, int key) {\n    pthread_mutex_lock(&L−>lock);\n    node_t *new = malloc(sizeof(node_t));\n    if (new == NULL) {\n        perror(\"malloc\");\n        pthread_mutex_unlock(&L−>lock);\n        return −1; // 실패\n    }\n    new−>key = key;\n    new−>next = L−>head;\n    L−>head = new;\n    pthread_mutex_unlock(&L−>lock);\n    return 0; // 성공\n}\n\nint List_Lookup(list_t *L, int key) {\n    pthread_mutex_lock(&L−>lock);\n    node_t *curr = L−>head;\n    while (curr) {\n        if (curr−>key == key) {\n            pthread_mutex_unlock(&L−>lock);\n            return 0; // 성공\n        }\n        curr = curr−>next;\n    }\n    pthread_mutex_unlock(&L−>lock);\n    return −1; // 오류\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"삽입 연산을 시작하기 전에 락을 획득하고 리턴 직전에 해제"},{"type":"span","value":"함."}]},{"type":"paragraph","children":[{"type":"span","value":"매우 드물게 "},{"type":"span","marks":["code"],"value":"malloc()"},{"type":"span","value":"이 실패할 경우 미묘한 문제가 생길 수 있음.\n➡️ 그러한 경우 실패를 처리하기 전에 락을 해제해야 함."}]},{"type":"paragraph","children":[{"type":"span","value":"🤔 삽입 연산이 병행하여 진행되는 상황에서 실패를 하더라도 락 해제를 호출하지 않으면서 삽입과 검색이 올바르게 동작하도록 수정할 수 있을까?\n➡️ ✅ 가능하다.\n➡️ 삽입 코드에서 임계 영역을 처리하는 부분만 락으로 감싸도록 코드 순서를 변경하고, 검색 코드의 종료는 검색과 삽입 모두 동일한 코드 패스를 사용하도록 할 수 있음.\n➡️ 검색 코드의 일부는 사실 락이 필요 없기 때문"}]},{"type":"paragraph","children":[{"type":"span","value":"개선된 다음의 코드를 살펴보자."}]},{"code":"void List_Init(list_t *L) {\n    L−>head = NULL;\n    pthread_mutex_init(&L−>lock, NULL);\n}\n\nvoid List_Insert(list_t *L, int key) {\n    // 동기화할 필요 없음\n    node_t *new = malloc(sizeof(node_t));\n    if (new == NULL) {\n        perror(“malloc ”);\n        return;\n    }\n    new−>key = key;\n    \n    // 임계 영역만 락으로 보호\n    pthread_mutex_lock(&L−>lock);\n    new−>next = L−>head;\n    L−>head = new;\n    pthread_mutex_unlock(&L−>lock);\n}\n\nint List_Lookup(list_t *L, int key) {\n    int rv = −1;\n    pthread_mutex_lock(&L−>lock);\n    node_t *curr = L−>head;\n    while (curr) {\n        if (curr−>key == key) {\n            rv = 0;\n            break;\n        }\n        curr = curr−>next;\n    }\n    pthread_mutex_unlock(&L−>lock);\n    return rv; // 성공과 실패를 나타냄\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"검색 루틴의 while 문 안에 break를 삽입하여 검색이 성공하면 바로 빠져나오게 수정\n➡️ 검색 성공/실패 경우 모두 동일한 리턴 코드를 실행"}]},{"type":"paragraph","children":[{"type":"span","value":"위와 같이 작성 시 코드에서 락을 획득하고 해제하는 문장 수를 줄일 수 있음.\n➡️ 버그(락 해제 없이 리턴 등) 발생 여지가 줄어 듦."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"확장성 있는 연결 리스트"}]},{"type":"paragraph","children":[{"type":"span","value":"병행성을 개선하는 방법 중 하나로 "},{"type":"span","marks":["highlight"],"value":"hand-over-hand locking(또는 lock coupling)"},{"type":"span","value":"이라는 기법을 개발함.\n➡️ 💡 전체 리스트에 하나의 락이 있는 것이 아니라 "},{"type":"span","marks":["highlight"],"value":"개별 노드마다 락을 추가"}]},{"type":"paragraph","children":[{"type":"span","value":"🚋 리스트를 순회할 때 "},{"type":"span","marks":["highlight"],"value":"다음 노드의 락을 먼저 획득하고 지금 노드의 락을 해제"}]},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 실제로는 간단한 락 방법(한 개의 락)에 비해 속도 개선을 기대하기가 쉽지 않음.\n➡️ 각 노드의 락 획득/해제 시 큰 오버헤드 발생"}]},{"type":"paragraph","children":[{"type":"span","value":"💡 일정 개수의 노드를 처리할 때마다 하나의 새로운 락을 획득하는 하이브리드 방식이 더 가치 있어 보임."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"락과 제어 흐름을 경계하자"}]},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 함수의 흐름이 바뀌는 부분(return, exit, 에러)으로 인한 실행 중지에 매우 세심한 주의를 기울여야 함.\n➡️ 많은 함수들이 "},{"type":"span","marks":["highlight"],"value":"락 획득, 메모리 할당, 상태 변경 연산들을 실행"},{"type":"span","value":"하는 데 "},{"type":"span","marks":["highlight"],"value":"에러가 발생하면 리턴하기 전에 이들을 이전 상태로 복구"},{"type":"span","value":"해야 하기 때문\n➡️ ☄️ 이 과정에서 에러가 발생하기 쉬움."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"3️⃣ 병행 큐"}]},{"type":"paragraph","children":[{"type":"span","value":"큰 락을 사용하는 것이 병행 자료 구조를 만들기에 표준임.\n➡️ 큐에서는 이 방법을 사용하지 않을 것임."}]},{"type":"paragraph","children":[{"type":"span","value":"다음은 Michael과 Scott이 설계한 조금 더 병행성이 좋은 큐의 코드이다."}]},{"code":"typedef struct __node_t {\n    int value;\n    struct __node_t *next;\n} node_t;\n\ntypedef struct __queue_t {\n    node_t *head;\n    node_t *tail;\n    pthread_mutex_t headLock;\n    pthread_mutex_t tailLock;\n} queue_t;\n\nvoid Queue_Init(queue_t *q) {\n    node_t *tmp = malloc(sizeof(node_t));\n    tmp−>next = NULL;\n    q−>head = q−>tail = tmp;\n    pthread_mutex_init(&q−>headLock, NULL);\n    pthread_mutex_init(&q−>tailLock, NULL);\n}\n\nvoid Queue_Enqueue(queue_t *q, int value) {\n    node_t *tmp = malloc(sizeof(node_t));\n    assert(tmp != NULL);\n    tmp−>value = value;\n    tmp−>next = NULL;\n    \n    pthread_mutex_lock(&q−>tailLock);\n    q−>tail−>next = tmp;\n    q−>tail = tmp;\n    pthread_mutex_unlock(&q−>tailLock);\n}\n\nint Queue_Dequeue(queue_t *q, int *value) {\n    pthread_mutex_lock(&q−>headLock);\n    node_t *tmp = q−>head;\n    node_t *newHead = tmp−>next;\n    if (newHead == NULL) {\n        pthread_mutex_unlock(&q−>headLock);\n        return −1; // 큐가 비어 있음\n    }\n    *value = newHead−>value;\n    q−>head = newHead;\n    pthread_mutex_unlock(&q−>headLock);\n    free(tmp);\n    return 0;\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"🔒 위의 코드에는 두 개의 락이 있음."}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"큐의 헤드"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"큐의 테일"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"이 두 개의 락은 "},{"type":"span","marks":["highlight"],"value":"큐에 삽입과 추출 연산에 병행성을 부여"},{"type":"span","value":"하는 것이 목적\n➡️ 일반적인 경우에는 "},{"type":"span","marks":["highlight"],"value":"삽입 루틴이 테일 락을 접근"},{"type":"span","value":"하고 "},{"type":"span","marks":["highlight"],"value":"추출 연산이 헤드 락"},{"type":"span","value":"만을 다룸."}]},{"type":"paragraph","children":[{"type":"span","value":"Michael과 Scott은 "},{"type":"span","marks":["highlight"],"value":"큐 초기화 코드에 더미(dummy) 노드 하나를 추가"},{"type":"span","value":"함.\n➡️ "},{"type":"span","marks":["highlight"],"value":"헤드와 테일 연산을 구분"},{"type":"span","value":"하는 데 사용"}]},{"type":"paragraph","children":[{"type":"span","value":"🧵 큐는 멀티 쓰레드 프로그램에서 자주 사용됨.\n➡️ 🚫 위의 락만 있는 큐는 그런 프로그램에서 사용할 수 없음.\n➡️ 🚧 큐가 비었거나 가득 찬 경우, 쓰레드가 대기하도록 하는 기능이 필요"}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"4️⃣ 병행 해시 테이블"}]},{"code":"#define BUCKETS ()\n\ntypedef struct __hash_t {\n  list_t lists[BUCKETS];\n} hash_t;\n\nvoid Hash_Init(hash_t *H) {\n  int i;\n  for (i = ; i < BUCKETS; i++) {\n    List_Init(&H−>lists[i]);\n  }\n}\n\nint Hash_Insert(hash_t *H, int key) {\n  int bucket = key % BUCKETS;\n  return List_Insert(&H−>lists[bucket], key);\n}\n\nint Hash_Lookup(hash_t *H, int key) {\n  int bucket = key % BUCKETS;\n  return List_Lookup(&H−>lists[bucket], key);\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"위의 코드는 앞선 병행 리스트를 사용하여 구현한 확장 되지 않는 간단한 해시 테이블의 코드이다."}]},{"type":"paragraph","children":[{"type":"span","value":"전체 자료 구조에 하나의 락을 사용한 것이 아니라 리스트로 구현된 해시 버켓마다 락을 사용함.\n➡️ 병행성이 좋아짐."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"🧺 락 기반의 병행 자료 구조 정리하기"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"⚠️ 락의 획득과 해제 시 코드의 흐름에 매우 주의를 기울여야 함."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"병행성 개선이 반드시 성능 개선으로 이어지는 것은 아님.\n➡️ 성능 개선은 성능에 문제가 생길 경우에만 해결책을 간구해야 함."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"미숙한 최적화(premature optimization)"},{"type":"span","value":"를 피하자.\n➡️ 부분적인 성능 개선 시도가 응용 프로그램의 전체 성능을 개선하지 못하면 아무 의미가 없음."}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"🔖 미숙한 최적화를 피하자(Knuth's Law)\nSun 운영체제와 Linux를 포함한 많은 운영체제가 처음 멀티프로세서 용으로 변화할 때 하나의 락을 사용했었음.\n➡️ "},{"type":"span","marks":["highlight"],"value":"큰 커널 락(big kernal lock, BKL)"},{"type":"span","value":"\n➡️ 오랫동안 이 기법만으로 충분했으나, 멀티 CPU 시스템이 대중화되면서 개선 작업이 이루어짐."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"📚 참고 문헌"}]},{"type":"paragraph","children":[{"url":"https://pages.cs.wisc.edu/~remzi/OSTEP/threads-locks-usage.pdf","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"Operating Systems: Three Easy Pieces ― 29: Lock-based Concurrent Data Structures"}]}]},{"type":"paragraph","children":[{"url":"https://pages.cs.wisc.edu/~remzi/OSTEP/Korean/29_threads-locks-usage.pdf","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"운영체제 아주 쉬운 세 가지 이야기 ― 32: 락 기반의 병행 자료 구조"}]}]}]}}}}},"pageContext":{"id":"189836506","locale":"ko-KR"}},"staticQueryHashes":["1034768456","1118752904","2342916782","2757196681","3415878905","3879866231","4195094990"]}