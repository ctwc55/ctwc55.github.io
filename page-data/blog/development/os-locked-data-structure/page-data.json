{"componentChunkName":"component---src-templates-article-jsx","path":"/blog/development/os-locked-data-structure","result":{"data":{"datoCmsMiscTextString":{"locale":"ko-KR","updatedAtText":"업데이트됨","nextReadText":"관련있는 게시물"},"datoCmsBlogPost":{"locale":"ko-KR","originalId":"189836506","title":"[운영체제][OSTEP] 락 기반의 병행 자료 구조","seo":{"seoTitle":"[운영체제][OSTEP] 락 기반의 병행 자료 구조","seoDescription":"자료 구조에 락을 추가하여 쓰레드 사용에 안전한 구조를 만드는 방법에 대해 공부해봅니다.","seoImage":{"seoImageUrl":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format"}},"subtitle":"자료 구조에 락을 추가하여 쓰레드 사용에 안전한 구조를 만드는 방법에 대해 공부해봅니다.","coverImage":{"coverImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&w=860","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.25&w=860 215w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.5&w=860 430w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&w=860 860w","sizes":"(min-width: 860px) 860px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgLCgoLDhMVDhcNDh0VDxUSGhYdHSIVFhUaKysjGh0oHSEWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLCgUFEBAOEC8oIhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIAAwAGAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAFAQQGAP/EAB0QAAEEAgMAAAAAAAAAAAAAAAEAAgMEESEFEjL/xAAWAQADAAAAAAAAAAAAAAAAAAAAAQP/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwDD1KM1uPLjpIRUI4GZc4aRXH25hTOHqqbth7yDIVIiXI2IQzqCoREhL/RyuQH/2Q=="},"width":860,"height":430}},"meta":{"updatedAt":"2023-08-25T16:47:29.072+09:00","firstPublishedAt":"2023-08-22T22:47:21.442+09:00"},"categoryLink":{"title":"개발 공부","id":"4743072"},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorPictureData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 60px) 60px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgWEQ8LDhgYDhUNDhgNDw8NFxUdGBYfFhUaHysjGikoHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OHBANHDUcIig7NS81NS81MjUvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAFAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAABQYHAv/EAB4QAAICAgMBAQAAAAAAAAAAAAABAgMFBgQRQXEi/8QAFQEBAQAAAAAAAAAAAAAAAAAABAP/xAAaEQACAwEBAAAAAAAAAAAAAAAAAQIDEhMR/9oADAMBAAIRAxEAPwDT8/1LHSK/r67scevSfz99VXBkm/Cva/zKle/pCc/JoRXWsFujxvygcLI1pAXqQTmjONm2RzpceyCwmwxpsbbADWJdBFbeCfe2wXoAGpIL6z//2Q=="},"width":60,"height":60}}},"relatedPosts":[{"id":"187813035","meta":{"updatedAt":"2023-08-22T22:47:51.945+09:00"},"categoryLink":{"title":"개발 공부"},"coverImage":{"gatsbyImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.09&w=860 75w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.18&w=860 150w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860 300w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.7&w=860 600w","sizes":"(min-width: 300px) 300px, 100vw"}},"layout":"constrained","width":300,"height":120},"squaredImage":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.06&fit=crop&fp-x=0.5&fp-y=0.5&w=430 25w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.12&fit=crop&fp-x=0.5&fp-y=0.5&w=430 50w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430 100w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.47&fit=crop&fp-x=0.5&fp-y=0.5&w=430 200w","sizes":"(min-width: 100px) 100px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBhINEBAQCggUDg0IDgcHFh0JFhEYFxUZGCIVFhUaHysjGh0oHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OEg4REC8dFhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAGAMBIgACEQEDEQH/xAAaAAEBAAIDAAAAAAAAAAAAAAAABAUGAQID/8QAHRAAAgICAwEAAAAAAAAAAAAAAAIDBAEREhQVBf/EABYBAQEBAAAAAAAAAAAAAAAAAAADAf/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/ANASs2WLoaraMl1o0O241wSYlSHjgHM9hVAEFr6bKSemzAAeclpnAAH/2Q=="},"width":100,"height":100}},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.11&w=77 8w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 30px) 30px, 100vw"}},"layout":"constrained","width":30,"height":30}}},"subtitle":"임계 영역에서의 원자적인 실행을 위한 락에 대해 공부해봅니다.","title":"[운영체제][OSTEP] 락"}],"structuredBody":{"blocks":[],"links":[],"value":{"schema":"dast","document":{"type":"root","children":[{"type":"heading","level":2,"children":[{"type":"span","value":"🚪 들어가며"}]},{"type":"paragraph","children":[{"type":"span","value":"💡 "},{"type":"span","marks":["highlight"],"value":"쓰레드 사용에 안전(쓰레드 안전, thread safe)"},{"type":"span","value":"한 구조\n자료 구조에 락을 추가하여 쓰레드가 사용할 수 있도록 만든 것"}]},{"type":"paragraph","children":[{"type":"span","value":"이번 챕터에서는 "},{"type":"span","marks":["highlight"],"value":"특정 자료 구조에 어떤 방식으로 락을 추가"},{"type":"span","value":"해야 그 자료 구조가 "},{"type":"span","marks":["highlight"],"value":"정확하게 동작"},{"type":"span","value":"하게 만들 수 있을지, "},{"type":"span","marks":["highlight"],"value":"자료 구조에 락을 추가"},{"type":"span","value":"하여 "},{"type":"span","marks":["highlight"],"value":"여러 쓰레드가 그 자료 구조를 동시 사용(병행성) 가능"},{"type":"span","value":"하도록 하는 방법에 대해 알아보자."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"1️⃣ 병행 카운터"}]},{"type":"paragraph","children":[{"type":"span","value":"카운터: 가장 간단한 자료 구조 중 하나(특정 원소가 몇 개 있는지 카운팅)"}]},{"type":"paragraph","children":[{"type":"span","value":"먼저 병행이 불가능한 카운터를 살펴보자."}]},{"code":"typedef struct __counter_t {\n  int value;\n} counter_t;\n\nvoid init(counter_t *c) {\n  c−>value = 0;\n}\n\nvoid increment(counter_t *c) {\n  c−>value++;\n}\n\nvoid decrement(counter_t *c) {\n  c−>value−−;\n}\n\nint get(counter_t *c) {\n  return c−>value;\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"다음은 락이 있는(쓰레드 안전(thread safe)한) 카운터이다."}]},{"code":"typedef struct __counter_t {\n  int value;\n  pthread_mutex_t lock;\n} counter_t;\n\nvoid init(counter_t *c) {\n  c−>value = 0;\n  Pthread_mutex_init(&c−>lock, NULL);\n}\n\nvoid increment(counter_t *c) {\n  Pthread_mutex_lock(&c−>lock);\n  c−>value++;\n  Pthread_mutex_unlock(&c−>lock);\n}\n\nvoid decrement(counter_t *c) {\n  Pthread_mutex_lock(&c−>lock);\n  c−>value−−;\n  Pthread_mutex_unlock(&c−>lock);\n}\n\nint get(counter_t *c) {\n  Pthread_mutex_lock(&c−>lock);\n  int rc = c−>value;\n  Pthread_mutex_unlock(&c−>lock);\n  return rc;\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"위에서 우리는 다음을 확인할 수 있다."}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"자료 구조를 조작하는 루틴을 호출할 때 락을 추가한다."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"루틴 호출 후 리턴 시 락이 해제된다."}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"위 방식은 "},{"type":"span","marks":["highlight"],"value":"모니터(monitor)"},{"type":"span","value":"를 사용하여 만든 자료 구조와 유사하다.\n🔖 모니터 기법: 객체에 대한 메소드를 호출하고 리턴할 때 자동적으로 락을 획득하고 해제"}]},{"type":"paragraph","children":[{"type":"span","value":"이 방식을 통해 제대로 동작하는 병행 자료 구조를 가질 수 있지만, "},{"type":"span","marks":["highlight"],"value":"성능 개선이 필요"},{"type":"span","value":"하다."}]},{"type":"paragraph","children":[{"type":"span","value":"이상적으로는 "},{"type":"span","marks":["highlight"],"value":"하나의 쓰레드가 하나의 CPU에서 작업을 끝내는 것처럼 멀티프로세서에서 실행되는 쓰레드들도 빠르게 작업을 처리"},{"type":"span","value":"하고 싶음.\n➡️ 이와 같은 것을 "},{"type":"span","marks":["highlight"],"value":"완벽한 확장성(perfect scaling)"},{"type":"span","value":"이라고 한다."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"확장성 있는 카운팅"}]},{"type":"paragraph","children":[{"type":"span","value":"확장성 있는 카운터는 중요한 의미를 갖는다.\n➡️ 확장 가능한 카운터가 없으면 Linux의 몇몇 작업은 멀티코어 기기에서 심각한 확장성 문제를 겪을 수 있음."}]},{"type":"paragraph","children":[{"type":"span","value":"이러한 기법들 중 "},{"type":"span","marks":["highlight"],"value":"엉성한 카운터(sloppy counter)"},{"type":"span","value":"라는 것을 살펴보자."}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"엉성한 카운터는 "},{"type":"span","marks":["highlight"],"value":"하나의 논리적 카운터로 표현"},{"type":"span","value":"됨."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"CPU 코어마다 존재하는 물리적인 지역 카운터"},{"type":"span","value":"와 "},{"type":"span","marks":["highlight"],"value":"하나의 전역 카운터"},{"type":"span","value":"로 구성"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"이 카운터들 외에 "},{"type":"span","marks":["highlight"],"value":"지역 카운터를 위한 락"},{"type":"span","value":"들과 "},{"type":"span","marks":["highlight"],"value":"전역 카운터를 위한 락"},{"type":"span","value":"이 존재"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"엉성한 카운터의 기본 개념은 다음과 같다."}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"쓰레드는 지역 카운터를 증가시킨다."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"해당 지역 카운터는 지역 락에 의해 보호된다."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"각 CPU 마다 지역 카운터가 존재하므로 CPU들에 분산된 쓰레드들은 지역 카운터를 경쟁 없이 갱신"}]},{"type":"paragraph","children":[{"type":"span","value":"➡️ 카운터 갱신은 확장성이 있음."}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"👀 쓰레드가 카운터의 값을 읽을 수 있음. ➡️ 전역 카운터를 최신 최신으로 갱신해야 함."}]},{"type":"paragraph","children":[{"type":"span","value":"🛒 그러기 위해 지역 카운터의 값은 주기적으로 전역 카운터로 전달\n➡️ 전역 락을 사용하여 지역 카운터의 값을 전역 카운터의 값에 더함.\n➡️ 해당 지역 카운터의 값은 0으로 초기화"}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"지역에서 전역으로 값을 전달하는 빈도"},{"type":"span","value":"는 정해 놓은 S(sloppiness의 앞 글자) 값에 의해 결정\n➡️ S의 값이 작을수록 확장성 없는 카운터처럼 동작\n➡️ 커질수록 전역 카운터의 값은 실제 값과 차이가 있게 됨."}]},{"type":"paragraph","children":[{"type":"span","value":"정확한 카운터 값을 얻기 위해서는 모든 지역 락과 전역 락을 획득한 후 계산해야 함.\n➡️ ⚠️ 이 경우 확장성이 없게 됨.\n➡️ 지역 락을 획득하는 순서를 적절히 제어하지 않으면 교착 상태가 발생"}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"2️⃣"}]},{"type":"paragraph","children":[{"type":"span","value":""}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"3️⃣"}]},{"type":"paragraph","children":[{"type":"span","value":""}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"4️⃣"}]},{"type":"paragraph","children":[{"type":"span","value":""}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"🧺 락 기반의 병행 자료 구조 정리하기"}]},{"type":"paragraph","children":[{"type":"span","value":""}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"📚 참고 문헌"}]},{"type":"paragraph","children":[{"url":"https://pages.cs.wisc.edu/~remzi/OSTEP/threads-locks-usage.pdf","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"Operating Systems: Three Easy Pieces ― 29: Lock-based Concurrent Data Structures"}]}]},{"type":"paragraph","children":[{"url":"https://pages.cs.wisc.edu/~remzi/OSTEP/Korean/29_threads-locks-usage.pdf","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"운영체제 아주 쉬운 세 가지 이야기 ― 32: 락 기반의 병행 자료 구조"}]}]}]}}}}},"pageContext":{"id":"189836506","locale":"ko-KR"}},"staticQueryHashes":["1034768456","1118752904","2342916782","2757196681","3415878905","3879866231","4195094990"]}