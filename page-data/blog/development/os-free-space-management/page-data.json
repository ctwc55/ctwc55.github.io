{"componentChunkName":"component---src-templates-article-jsx","path":"/blog/development/os-free-space-management","result":{"data":{"datoCmsMiscTextString":{"locale":"ko-KR","updatedAtText":"업데이트됨","nextReadText":"관련있는 게시물"},"datoCmsBlogPost":{"locale":"ko-KR","originalId":"179076819","title":"[운영체제][OSTEP] 빈 공간 관리","seo":{"seoTitle":"[운영체제][OSTEP] 빈 공간 관리","seoDescription":"메모리의 빈 공간을 관리하는 방법에 대해 공부해봅니다.","seoImage":{"seoImageUrl":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format"}},"subtitle":"메모리의 빈 공간을 관리하는 방법에 대해 공부해봅니다.","coverImage":{"coverImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&w=860","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.25&w=860 215w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.5&w=860 430w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&w=860 860w","sizes":"(min-width: 860px) 860px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgLCgoLDhMVDhcNDh0VDxUSGhYdHSIVFhUaKysjGh0oHSEWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLCgUFEBAOEC8oIhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIAAwAGAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAFAQQGAP/EAB0QAAEEAgMAAAAAAAAAAAAAAAEAAgMEESEFEjL/xAAWAQADAAAAAAAAAAAAAAAAAAAAAQP/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwDD1KM1uPLjpIRUI4GZc4aRXH25hTOHqqbth7yDIVIiXI2IQzqCoREhL/RyuQH/2Q=="},"width":860,"height":430}},"meta":{"updatedAt":"2023-07-31T00:37:08.451+09:00","firstPublishedAt":"2023-07-23T16:30:25.940+09:00"},"categoryLink":{"title":"개발 공부","id":"4743072"},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorPictureData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 60px) 60px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgWEQ8LDhgYDhUNDhgNDw8NFxUdGBYfFhUaHysjGikoHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OHBANHDUcIig7NS81NS81MjUvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAFAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAABQYHAv/EAB4QAAICAgMBAQAAAAAAAAAAAAABAgMFBgQRQXEi/8QAFQEBAQAAAAAAAAAAAAAAAAAABAP/xAAaEQACAwEBAAAAAAAAAAAAAAAAAQIDEhMR/9oADAMBAAIRAxEAPwDT8/1LHSK/r67scevSfz99VXBkm/Cva/zKle/pCc/JoRXWsFujxvygcLI1pAXqQTmjONm2RzpceyCwmwxpsbbADWJdBFbeCfe2wXoAGpIL6z//2Q=="},"width":60,"height":60}}},"relatedPosts":[{"id":"177405298","meta":{"updatedAt":"2023-07-18T23:24:51.666+09:00"},"categoryLink":{"title":"개발 공부"},"coverImage":{"gatsbyImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.09&w=860 75w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.18&w=860 150w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860 300w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.7&w=860 600w","sizes":"(min-width: 300px) 300px, 100vw"}},"layout":"constrained","width":300,"height":120},"squaredImage":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.06&fit=crop&fp-x=0.5&fp-y=0.5&w=430 25w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.12&fit=crop&fp-x=0.5&fp-y=0.5&w=430 50w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430 100w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.47&fit=crop&fp-x=0.5&fp-y=0.5&w=430 200w","sizes":"(min-width: 100px) 100px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBhINEBAQCggUDg0IDgcHFh0JFhEYFxUZGCIVFhUaHysjGh0oHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OEg4REC8dFhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAGAMBIgACEQEDEQH/xAAaAAEBAAIDAAAAAAAAAAAAAAAABAUGAQID/8QAHRAAAgICAwEAAAAAAAAAAAAAAAIDBAEREhQVBf/EABYBAQEBAAAAAAAAAAAAAAAAAAADAf/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/ANASs2WLoaraMl1o0O241wSYlSHjgHM9hVAEFr6bKSemzAAeclpnAAH/2Q=="},"width":100,"height":100}},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.11&w=77 8w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 30px) 30px, 100vw"}},"layout":"constrained","width":30,"height":30}}},"subtitle":"대용량 주소 공간을 지원하는 방법에 대해 공부해봅니다.","title":"[운영체제][OSTEP] 세그멘테이션"},{"id":"181343902","meta":{"updatedAt":"2023-08-01T02:16:32.054+09:00"},"categoryLink":{"title":"개발 공부"},"coverImage":{"gatsbyImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.09&w=860 75w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.18&w=860 150w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860 300w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.7&w=860 600w","sizes":"(min-width: 300px) 300px, 100vw"}},"layout":"constrained","width":300,"height":120},"squaredImage":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.06&fit=crop&fp-x=0.5&fp-y=0.5&w=430 25w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.12&fit=crop&fp-x=0.5&fp-y=0.5&w=430 50w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430 100w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.47&fit=crop&fp-x=0.5&fp-y=0.5&w=430 200w","sizes":"(min-width: 100px) 100px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBhINEBAQCggUDg0IDgcHFh0JFhEYFxUZGCIVFhUaHysjGh0oHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OEg4REC8dFhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAGAMBIgACEQEDEQH/xAAaAAEBAAIDAAAAAAAAAAAAAAAABAUGAQID/8QAHRAAAgICAwEAAAAAAAAAAAAAAAIDBAEREhQVBf/EABYBAQEBAAAAAAAAAAAAAAAAAAADAf/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/ANASs2WLoaraMl1o0O241wSYlSHjgHM9hVAEFr6bKSemzAAeclpnAAH/2Q=="},"width":100,"height":100}},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.11&w=77 8w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 30px) 30px, 100vw"}},"layout":"constrained","width":30,"height":30}}},"subtitle":"페이지를 사용하여 메모리를 가상화하는 방법에 대해 공부해봅니다.","title":"[운영체제][OSTEP] 페이징"}],"structuredBody":{"blocks":[],"links":[{"id":"177405298"}],"value":{"schema":"dast","document":{"type":"root","children":[{"type":"heading","level":2,"children":[{"type":"span","value":"🚪 들어가며"}]},{"type":"paragraph","children":[{"type":"span","value":"빈 공간 관리가 어려운 경우: 관리하는 공간이 "},{"type":"span","marks":["highlight"],"value":"가변-크기 빈 공간들의 집합"},{"type":"span","value":"으로 구성된 경우\nex1) 사용자-수준 메모리 할당 라이브러리("},{"type":"span","marks":["code"],"value":"malloc()"},{"type":"span","value":", "},{"type":"span","marks":["code"],"value":"free()"},{"type":"span","value":")\nex2) "},{"type":"span","marks":["underline"],"value":"세그멘테이션"},{"type":"span","value":"으로 물리 메모리를 관리하는 운영체제\n➡️ 위 예시들과 같은 경우 "},{"type":"span","marks":["highlight"],"value":"외부 단편화"},{"type":"span","value":" 존재"}]},{"type":"paragraph","children":[{"type":"span","value":"(빈 공간들의 전체 크기) > (요청된 크기) 이더라도 하나의 연속된 영역 존재X 일 경우\n➡️ 요청 실패"}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"1️⃣ 가정"}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"malloc()"},{"type":"span","value":"과 "},{"type":"span","marks":["code"],"value":"free()"},{"type":"span","value":"에서 제공하는 것과 같은 기본 인터페이스를 가정"}]},{"type":"heading","level":3,"children":[{"type":"span","value":"void *malloc(size_t size)"}]},{"type":"paragraph","children":[{"type":"span","value":"인자: 응용 프로그램의 요청 바이트 수\n반환: 요청된 크기와 같거나 큰 영역을 가리키는 void 포인터"}]},{"type":"heading","level":3,"children":[{"type":"span","value":"void free(void *ptr)"}]},{"type":"paragraph","children":[{"type":"span","value":"인자: 포인터\n반환: 해당 영역을 해제"}]},{"type":"paragraph","children":[{"type":"span","value":"위의 루틴들을 포함하는 라이브러리가 관리하는 공간: "},{"type":"span","marks":["highlight"],"value":"힙(heap)"}]},{"type":"paragraph","children":[{"type":"span","value":"힙의 "},{"type":"span","marks":["highlight"],"value":"빈 공간"},{"type":"span","value":" 관리: 일반적인 "},{"type":"span","marks":["highlight"],"value":"링크드리스트"},{"type":"span","value":" 사용(반드시 리스트일 필요X)"}]},{"type":"paragraph","children":[{"type":"span","value":"할당된 메모리 > 요청한 메모리\n➡️ 할당 청크의 내부에서 낭비가 발생: "},{"type":"span","marks":["highlight"],"value":"내부 단편화"}]},{"type":"paragraph","children":[{"type":"span","value":"클라이언트에게 할당된 메모리는 다른 위치로 재배치될 수 없다고 가정\n➡️ ⚠️ 단편화 해결에 유용하게 사용되는 빈 공간의 "},{"type":"span","marks":["highlight"],"value":"압축"},{"type":"span","value":"은 이 경우 "},{"type":"span","marks":["underline"],"value":"사용 불가능"}]},{"type":"paragraph","children":[{"type":"span","value":"운영체제가 세그멘트를 구현할 때에는 단편화 해결을 위해 압축을 사용할 수 있음\n➡️ "},{"item":"177405298","meta":[{"id":"target","value":"_blank"}],"type":"itemLink","children":[{"type":"span","value":"세그멘테이션"}]},{"type":"span","value":" 내용 참고"}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"2️⃣ 저수준 기법들"}]},{"type":"heading","level":3,"children":[{"type":"span","value":"분할과 병합"}]},{"type":"paragraph","children":[{"type":"span","value":"빈 공간 리스트: 힙에 있는 빈 공간들의 집합"}]},{"type":"paragraph","children":[{"type":"span","value":"30바이트의 힙이 있다고 가정하자."}]},{"code":"┌──────────┬────────────┬────────────┐\n│   free   │    used    │    free    │\n└──────────┴────────────┴────────────┘\n0          10           20           30","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"이 힙의 빈 공간 리스트는 다음과 같이 나타날 수 있다."}]},{"code":"       ┌─────────┐   ┌──────────┐\n       │ addr: 0 │   │ addr: 20 │\nhead → │         │ → │          │ → NULL\n       │ len: 10 │   │ len: 10  │\n       └─────────┘   └──────────┘","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"이 예시의 경우 10바이트를 초과하는 모든 요청은 실패하여 NULL을 반환한다.\n10바이트에 대한 요청은 둘 중 하나의 빈 청크를 사용하여 쉽게 충족된다.\n이때, "},{"type":"span","marks":["underline"],"value":"10바이트보다 적은 요청"},{"type":"span","value":"에 대해서는 어떤 일이 일어날까?"}]},{"type":"paragraph","children":[{"type":"span","value":"메모리를 1바이트만 요청했다고 가정 ➡️ 할당기(allocator)는 "},{"type":"span","marks":["highlight"],"value":"분할(splitting)"},{"type":"span","value":" 작업을 수행"}]},{"type":"paragraph","children":[{"type":"span","value":"이는 "},{"type":"span","marks":["highlight"],"value":"요청을 만족시킬 수 있는 빈 청크를 찾아 둘로 분할"},{"type":"span","value":"한 후 "},{"type":"span","marks":["highlight"],"value":"첫 번째 청크는 호출자에게 반환"},{"type":"span","value":"하고 "},{"type":"span","marks":["highlight"],"value":"두 번째 청크는 리스트"},{"type":"span","value":"에 남게하는 작업"}]},{"type":"paragraph","children":[{"type":"span","value":"위의 예시에서 할당기가 두 번째 원소를 사용하여 요청을 충족시키기로 한 경우 최종적으로 빈 공간 리스트는 다음과 같이 바뀐다."}]},{"code":"       ┌─────────┐   ┌──────────┐\n       │ addr: 0 │   │ addr: 21 │\nhead → │         │ → │          │ → NULL\n       │ len: 10 │   │ len: 9   │\n       └─────────┘   └──────────┘","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"이와 같이 기본적인 리스트의 모습은 바뀌지 않고 분할이 수행된 원소의 구성 값이 바뀐 것을 알 수 있다."}]},{"type":"paragraph","children":[{"type":"span","value":"⭐ 이처럼 "},{"type":"span","marks":["highlight"],"value":"요청이 특정 빈 청크의 크기보다 작은 경우 분할 기법을 사용"},{"type":"span","value":"한다."}]},{"type":"paragraph","children":[{"type":"span","value":"이러한 분할에 동반되는 기법은 빈 공간의 "},{"type":"span","marks":["highlight"],"value":"병합(coalescing)"},{"type":"span","value":"이다."}]},{"type":"paragraph","children":[{"type":"span","value":"다시 위의 첫 예시를 가지고 와보자."}]},{"code":"┌──────────┬────────────┬────────────┐\n│   free   │    used    │    free    │\n└──────────┴────────────┴────────────┘\n0          10           20           30","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"이 상태에서 응용 프로그램이 "},{"type":"span","marks":["code"],"value":"free(10)"},{"type":"span","value":"을 호출하여 힙의 중간에 존재하는 공간을 반환하는 경우"}]},{"code":"       ┌──────────┐   ┌─────────┐   ┌──────────┐\n       │ addr: 10 │   │ addr: 0 │   │ addr: 20 │\nhead → │          │ → │         │ → │          │ → NULL\n       │ len: 10  │   │ len: 10 │   │ len: 10  │\n       └──────────┘   └─────────┘   └──────────┘","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"빈 공간 리스트는 위와 같이 나타날 수 있는데, 이때 발생할 수 있는 문제점을 살펴보자."}]},{"type":"paragraph","children":[{"type":"span","value":"힙 전체가 비어 있지만, 10바이트 길이의 청크 3개로 나누어져 있다.\n➡️ 사용자가 20바이트를 요청하는 경우 실패 반환"}]},{"type":"paragraph","children":[{"type":"span","value":"⭐ 할당기는 이 문제를 방지하기 위해 "},{"type":"span","marks":["highlight"],"value":"메모리 청크가 반환될 때 빈 공간들을 병합"}]},{"type":"paragraph","children":[{"type":"span","value":"💡 아이디어\n메모리 청크 반환 시 "},{"type":"span","marks":["highlight"],"value":"해제되는 청크의 주소와 바로 인접한 빈 청크들이 존재하는 경우 하나의 더 큰 빈 청크로 병합"},{"type":"span","value":"한다."}]},{"type":"paragraph","children":[{"type":"span","value":"병합 수행 후 최종 리스트는 다음과 같이 바뀐다."}]},{"code":"       ┌─────────┐\n       │ addr: 0 │\nhead → │         │ → NULL\n       │ len: 30 │\n       └─────────┘","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"이 상태는 할당이 한 번도 일어나지 않은 최초의 힙 리스트와 동일하다."}]},{"type":"paragraph","children":[{"type":"span","value":"병합 기법을 통해 "},{"type":"span","marks":["highlight"],"value":"할당기가 큰 빈 공간을 응용 프로그램에게 제공할 수 있다는 것을 더욱 보장"},{"type":"span","value":"할 수 있다."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"할당된 공간의 크기 파악"}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"free(void *ptr)"},{"type":"span","value":" 인터페이스 ➡️ 크기를 매개변수로 받지 않음."}]},{"type":"paragraph","children":[{"type":"span","value":"포인터가 인자로 전달되면 "},{"type":"span","marks":["code"],"value":"malloc"},{"type":"span","value":" 라이브러리는 해제되는 메모리 영역의 크기를 신속히 파악하여 그 공간을 빈 공간 리스트에 추가시킬 수 있다고 가정\n➡️ 이 작업을 위해 대부분의 할당기는 추가 정보를 "},{"type":"span","marks":["highlight"],"value":"헤더(header)"},{"type":"span","value":" 블럭에 저장"}]},{"type":"paragraph","children":[{"type":"span","value":"헤더 블럭은 메모리에 유지되며 보통 해제된 청크 바로 직전에 위치"}]},{"type":"paragraph","children":[{"type":"span","value":"다음의 예시를 살펴보자."}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"ptr"},{"type":"span","value":"이 크기 20바이트의 할당된 블럭을 가리키고 있다. "},{"type":"span","marks":["code"],"value":"ptr = malloc(20);"}]},{"code":"      ┌────────────────┐ ┐\n      │                │ │\n      │                │ │ The header used by malloc library\n      │                │ │\nptr → ├────────────────┤ ┤\n      │                │ │\n      │                │ │\n      │                │ │ The 20 bytes returned to caller\n      │                │ │\n      │                │ │\n      └────────────────┘ ┘","type":"code"},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"헤더는 적어도 할당된 공간의 크기는 저장"},{"type":"span","value":"해야하며, 해제 속도를 향상시키기 위한 추가의 포인터, 부가적인 무결성 검사를 제공하기 위한 매직 넘버 및 기타 정보를 저장할 수 있다.\n🔖 "},{"type":"span","marks":["emphasis"],"value":"매직 넘버: 상수로 선언하지 않은 숫자를 의미하며, 코드를 작성한 사람이 아니고서는 그 의미를 파악하기 어렵기 때문에 매직이라는 수식어가 붙게 되었다."}]},{"type":"paragraph","children":[{"type":"span","value":"예를 들어, 다음과 같이 헤더를 가정하는 경우"}]},{"code":"typedef struct __header_t {\n  int size;\n  int magic;\n} header_t;","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"헤더는 다음과 같이 표현할 수 있다."}]},{"code":"hptr → ┌────────────────┐\n       │ size:       20 │\n       ├────────────────┤\n       │ magic: 1234567 │\n ptr → ├────────────────┤ ┐\n       │                │ │\n       │                │ │\n       │                │ │ The 20 bytes returned to caller\n       │                │ │\n       │                │ │\n       └────────────────┘ ┘","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"사용자가 free(ptr)을 호출하면 라이브러리는 헤더의 시작 위치를 파악하기 위해 간단한 포인터 연산을 한다."}]},{"code":"void free(void *ptr) {\n  header_t *hptr = (void *)ptr − sizeof(header_t);\n  ...","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"헤더를 가리키는 포인터를 얻어 낸 후, 라이브러리는 매직 넘버가 기대하는 값과 일치하는지 비교하여 "},{"type":"span","marks":["highlight"],"value":"안전성 검사(sanity check)"},{"type":"span","value":"를 실시한다.("},{"type":"span","marks":["code"],"value":"assert(hptr->magic == 1234567)"},{"type":"span","value":")"}]},{"type":"paragraph","children":[{"type":"span","value":"그 후 새로 해제된 영역의 크기를 계산한다. (헤더의 크기 + 영역의 크기)\n➡️ 빈 영역의 크기 = 헤더의 크기 + 사용자에게 할당된 영역의 크기"}]},{"type":"paragraph","children":[{"type":"span","value":"N 바이트의 메모리 청크 요청 ➡️ "},{"type":"span","marks":["highlight"],"value":"라이브러리는 (빈 청크의 크기 N + 헤더의 크기)인 청크를 탐색"}]},{"type":"heading","level":3,"children":[{"type":"span","value":"빈 공간 리스트 내장"}]},{"type":"paragraph","children":[{"type":"span","value":"이러한 빈 공간 리스트를 실제로 어떻게 구현할 수 있을까?"}]},{"type":"paragraph","children":[{"type":"span","value":"새로운 노드를 위한 공간이 필요할 때 ➡️ "},{"type":"span","marks":["code"],"value":"malloc()"},{"type":"span","value":" 호출\nBut, 메모리 할당 라이브러리 루틴에서는 이것이 불가능"}]},{"type":"paragraph","children":[{"type":"span","value":"4096바이트 크기의 메모리 청크가 있다고 가정하자.(= 4KB 힙)"}]},{"type":"paragraph","children":[{"type":"span","value":"리스트 노드를 다음과 같이 표현할 수 있을 때, 이 메모리 청크를 빈 공간 리스트로 관리하기 위한 과정을 살펴보자."}]},{"code":"typedef struct __node_t {\n  int size;\n  struct __node_t *next;\n} node_t;","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":" 🧹 먼저 "},{"type":"span","marks":["highlight"],"value":"리스트를 초기화"},{"type":"span","value":" 한다.(초기에 4096 - 헤더 크기 길이의 항목 하나를 가짐.)"}]},{"type":"paragraph","children":[{"type":"span","value":"힙을 시스템 콜 "},{"type":"span","marks":["code"],"value":"mmap()"},{"type":"span","value":"을 호출하여 얻어진 영역에 구축된다고 가정할 때, 힙을 초기화하고 힙에 빈 공간 리스트의 첫 번째 원소를 넣는 코드는 다음과 같다."}]},{"code":"// mmap()이 빈 공간의 청크에 대한 포인터를 반환\nnode_t *head = mmap(NULL, 4096, PROT_READ|PROT_WRITE,\n                    MAP_ANON|MAP_PRIVATE, −1, 0);\nhead−>size = 4096 − sizeof(node_t);\nhead−>next = NULL;","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"위 코드 실행 후 리스트는 크기 4088(4096-8(node_t))의 항목 하나만을 가지게 된다."}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"head"},{"type":"span","value":" 포인터가 가리키는 이 영역의 시작 주소를 16KB라고 가정하면 힙의 모양은 다음과 같다."}]},{"code":"head → ┌────────────────┐ [virtual address: 16KB]\n       │ size:     4088 │ header: size field\n       ├────────────────┤\n       │ next:        0 │ header: next field(NULL is 0)\n ptr → ├────────────────┤ ┐\n       │                │ │\n       │                │ │\n               ...        │ The rest of the 4KB chunk\n       │                │ │\n       │                │ │\n       └────────────────┘ ┘","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"이때, 100바이트 메모리 청크가 요청된다면 라이브러리는 먼저 충분한 크기의 청크를 찾는다.\n➡️ 현 시점에서는 하나의 빈 청크(크기: 4088)만 존재하므로 해당 청크가 선택됨."}]},{"type":"paragraph","children":[{"type":"span","value":"✂️ 선택된 청크를 "},{"type":"span","marks":["highlight"],"value":"(빈 영역의 크기 + 헤더의 크기)를 충족하는 청크와 나머지 빈 청크 두 개로 분할"},{"type":"span","value":"한다."}]},{"type":"paragraph","children":[{"type":"span","value":"헤더의 크기를 8바이트라고 가정하면 힙의 공간 모습은 다음과 비슷할 것이다."}]},{"code":"       ┌────────────────┐ [virtual address: 16KB]\n       │ size:      100 │ \n       ├────────────────┤\n       │ magic: 1234567 │ \n ptr → ├────────────────┤ ┐\n       │                │ │\n       │                │ │\n               ...        │ The 100 bytes now allocated\n       │                │ │\n       │                │ │\nhead → ├────────────────┤ ┘\n       │ size:     3980 │ \n       ├────────────────┤\n       │ next:        0 │ \n       ├────────────────┤ ┐\n       │                │ │\n       │                │ │\n               ...        │ The free 3980 byte chunk\n       │                │ │\n       │                │ │\n       └────────────────┘ ┘","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"즉, 108바이트를 할당하고 할당 영역을 가리키는 포인터(위의 "},{"type":"span","marks":["code"],"value":"ptr"},{"type":"span","value":")를 반환한다."}]},{"type":"paragraph","children":[{"type":"span","value":"할당된 공간 직전의 8바이트에는 헤더 정보가 담기는데, 이 정보는 "},{"type":"span","marks":["code"],"value":"free()"},{"type":"span","value":"시 활용된다."}]},{"type":"paragraph","children":[{"type":"span","value":"다음으로는 아래와 같이 호출 프로그램에 의해 사용 중인 3개의 100바이트 영역이 존재하는 상황에서 프로그램이 "},{"type":"span","marks":["code"],"value":"free()"},{"type":"span","value":"를 통해 일부 메모리를 반환하는 경우를 살펴보자."}]},{"code":"       ┌────────────────┐ [virtual address: 16KB]\n       │ size:      100 │ \n       ├────────────────┤\n       │ magic: 1234567 │ \n       ├────────────────┤ ┐\n       │                │ │\n       │                │ │\n               ...        │ 100 bytes still allocated\n       │                │ │\n       │                │ │\n       ├────────────────┤ ┘   \n       │ size:      100 │ \n       ├────────────────┤\n       │ magic: 1234567 │ \nsptr → ├────────────────┤ ┐\n       │                │ │\n       │                │ │\n               ...        │ 100 bytes still allocated\n       │                │ │  (but about to be freed)\n       │                │ │\n       ├────────────────┤ ┘\n       │ size:      100 │ \n       ├────────────────┤\n       │ magic: 1234567 │ \n       ├────────────────┤ ┐\n       │                │ │\n       │                │ │\n               ...        │ 100 bytes now allocated\n       │                │ │\n       │                │ │\nhead → ├────────────────┤ ┘\n       │ size:     3764 │ \n       ├────────────────┤\n       │ next:        0 │ \n       ├────────────────┤ ┐\n       │                │ │\n       │                │ │\n               ...        │ The free 3764 byte chunk\n       │                │ │\n       │                │ │\n       └────────────────┘ ┘","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"응용 프로그램은 이제 "},{"type":"span","marks":["code"],"value":"free(16500)"},{"type":"span","value":"을 호출하여 할당 영역 중 가운데 청크를 반환한다.\n➡️ 16500("},{"type":"span","marks":["code"],"value":"sptr"},{"type":"span","value":") = 16384(시작 주소) + 108(이전 메모리 청크) + 8(해체 청크의 헤더)"}]},{"type":"paragraph","children":[{"type":"span","value":"라이브러리는 빈 공간의 크기를 파악한 후 빈 청크를 빈 공간 리스트에 삽입한다."}]},{"type":"paragraph","children":[{"type":"span","value":"이때, 빈 공간 리스트의 헤드 쪽에 삽입한다고 가정하면 공간의 모양은 다음과 같아진다."}]},{"code":"       ┌────────────────┐ [virtual address: 16KB]\n       │ size:      100 │ \n       ├────────────────┤\n       │ magic: 1234567 │ \n       ├────────────────┤ ┐\n       │                │ │\n       │                │ │\n               ...        │ The 100 bytes still allocated\n       │                │ │\n       │                │ │\nhead → ├────────────────┤ ┘   \n       │ size:      100 │ \n       ├────────────────┤\n       │ next:    16708 │ ───────────────────────────────┐\nsptr → ├────────────────┤                                │\n       │                │                                │\n       │                │                                │\n               ...          (now a free chunk of memory) │\n       │                │                                │     \n       │                │                                │\n       ├────────────────┤                                │\n       │ size:      100 │                                │\n       ├────────────────┤                                │\n       │ magic: 1234567 │                                │\n       ├────────────────┤ ┐                              │\n       │                │ │                              │\n       │                │ │                              │\n               ...        │ 100 bytes now allocated      │\n       │                │ │                              │\n       │                │ │                              │\n       ├────────────────┤ ┘                              │\n       │ size:     3764 │←───────────────────────────────┘\n       ├────────────────┤\n       │ next:        0 │ \n       ├────────────────┤ ┐\n       │                │ │\n       │                │ │\n               ...        │ The free 3764 byte chunk\n       │                │ │\n       │                │ │\n       └────────────────┘ ┘","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"이제 빈 공간 리스트는 순서대로 작은 빈 청크(100바이트), 큰 빈 청크(3764바이트)로 구성된다.\n➡️ ⚠️ 단편화가 발생한다!"}]},{"type":"paragraph","children":[{"type":"span","value":"여기서 마지막 2개의 사용 중인 청크가 해제된다고 할 때, 병합이 없다면 작은 단편으로 이루어진 빈 공간 리스트가 될 것이다.\n➡️ 따라서 "},{"type":"span","marks":["highlight"],"value":"리스트를 순회하며 인접한 청크를 병합"},{"type":"span","value":"하여 이를 해결한다."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"힙의 확장"}]},{"type":"paragraph","children":[{"type":"span","value":"힙 공간이 부족한 경우에는 어떻게 해야 할까?\n➡️ 가장 쉬운 방법: 단순히 실패를 반환하는 것(경우에 따라 유일한 대안일 수 있음.)"}]},{"type":"paragraph","children":[{"type":"span","value":"대부분의 전통적인 할당기 ➡️ 적은 크기의 힙으로 시작하여 모두 소진하면 운영체제로부터 더 많은 메모리를 요청"}]},{"type":"paragraph","children":[{"type":"span","value":"할당기는 힙을 확장하기 위하여 특정 시스템 콜(예: "},{"type":"span","marks":["code"],"value":"sbrk"},{"type":"span","value":") 호출 후 확장된 영역에서 새로운 청크를 할당"}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"sbrk"},{"type":"span","value":" 요청을 수행하기 위해 운영체제는 빈 물리 페이지를 찾아 요청 프로세스의 주소 공간에 매핑한 후, 새로운 힙의 마지막 주소를 반환"}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"3️⃣ 기본 전략"}]},{"type":"paragraph","children":[{"type":"span","value":"이상적인 할당기 = "},{"type":"span","marks":["highlight"],"value":"빠른 속도 & 단편화 최소"}]},{"type":"paragraph","children":[{"type":"span","value":"하지만 할당과 해제 요청 스트림은 무작위(프로그래머에 의해 결정)로 이루어지기 때문에 어느 특정 전략도 경우에 따라 성능이 매우 좋지 않을 수 있음."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"최적 적합(Best Fit)"}]},{"type":"paragraph","children":[{"type":"span","value":"최적 적합 전략은 다음과 같다."}]},{"type":"paragraph","children":[{"type":"span","value":"[1] 빈 공간 리스트를 검색하여 "},{"type":"span","marks":["highlight"],"value":"요청한 크기와 같거나 더 큰 빈 메모리 청크를 찾는다."}]},{"type":"paragraph","children":[{"type":"span","value":"[2] "},{"type":"span","marks":["highlight"],"value":"후보자 그룹 중 가장 작은 크기의 청크(최적 청크)를 반환"},{"type":"span","value":"한다."}]},{"type":"paragraph","children":[{"type":"span","value":"최소 적합이라고도 불리며, "},{"type":"span","marks":["highlight"],"value":"빈 공간 리스트를 한 번만 순회하면 반환할 정확한 블럭을 찾을 수 있다."}]},{"type":"paragraph","children":[{"type":"span","value":"공간의 낭비를 줄이고자 고안된 방법이지만, 그에 따른 비용이 수반된다.\n➡️ 정교하지 않은 구현은 엄청난 성능 저하를 초래(항상 전체를 검색하는 경우)"}]},{"type":"heading","level":3,"children":[{"type":"span","value":"최악 적합(Worst Fit)"}]},{"type":"paragraph","children":[{"type":"span","marks":["underline"],"value":"최적 적합의 반대 방식"},{"type":"span","value":"으로 "},{"type":"span","marks":["highlight"],"value":"가장 큰 빈 청크를 찾아 요청된 크기 만큼만 반환"},{"type":"span","value":"하고 남는 부분은 빈 공간 리스트에 계속 유지한다."}]},{"type":"paragraph","children":[{"type":"span","value":"최적 적합 방식에서 발생할 수 있는 많은 작은 청크들 대신 커다란 빈 청크를 남기려고 시도하지만, 빈 공간 전체를 탐색해야 하므로 역시 높은 비용이 수반된다."}]},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 대부분의 연구에서 엄청난 단편화가 발생하면서 오버헤드도 여전히 크다는 것을 보임."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"최초 적합(First Fit)"}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"요청보다 큰 첫 번째 블럭을 찾아서 요청만큼 반환"},{"type":"span","value":"한다.\n➡️ ✅ 속도가 빠르다는 것이 장점(항상 리스트 전체를 탐색할 필요X)"}]},{"type":"paragraph","children":[{"type":"span","value":"그러나 때때로 리스트의 시작에 크기가 작은 객체가 많이 생길 수 있음.\n➡️ 할당기가 빈 공간 리스트의 순서를 관리하는 방법이 쟁점\n➡️ 이러한 한 가지 방법으로 "},{"type":"span","marks":["highlight"],"value":"주소-기반 정렬(address-based ordering)"},{"type":"span","value":"이 있다."}]},{"type":"paragraph","children":[{"type":"span","value":"주소-기반 정렬 사용 시 리스트를 주소로 정렬하여 병합을 쉽게 하고, 단편화를 감소시킬 수 있다."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"다음 적합(Next Fit)"}]},{"type":"paragraph","children":[{"type":"span","value":"항상 리스트의 처음부터 탐색하는 대신 "},{"type":"span","marks":["highlight"],"value":"마지막으로 찾았던 원소를 가리키는 추가의 포인터"},{"type":"span","value":"를 유지\n➡️ 빈 공간 탐색을 리스트 전체에 더 균등하게 분산"}]},{"type":"paragraph","children":[{"type":"span","value":"다음 적합 알고리즘은 "},{"type":"span","marks":["highlight"],"value":"리스트의 첫 부분에만 단편이 집중적으로 발생하는 것을 방지"}]},{"type":"paragraph","children":[{"type":"span","value":"전체 탐색을 하지 않으므로 최초 적합의 성능과 비슷함."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"4️⃣ 다른 접근법"}]},{"type":"paragraph","children":[{"type":"span","value":"기본적인 접근 방식 외 메모리 할당을 향상시키기 위한 기술과 알고리즘들을 살펴보자."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"개별 리스트"}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"특정 응용 프로그램이 한두 개 자주 요청하는 크기"},{"type":"span","value":"가 있다면, 그 크기의 객체를 관리하기 위한 "},{"type":"span","marks":["highlight"],"value":"별도의 리스트를 유지"},{"type":"span","value":"한다.\n➡️ ✅ 특정 크기의 요청을 위한 메모리 청크를 유지함으로써 단편화 가능성이 상당히 줄어듬.\n➡️ ✅ 요청된 크기의 청크만이 존재하므로 할당과 해제 요청을 신속히 처리할 수 있음."}]},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 그러나 지정된 크기의 메모리 풀과 일반적인 풀에 얼마만큼의 메모리를 할당해야 할까?\n➡️ 특수 목적 할당기인 "},{"type":"span","marks":["highlight"],"value":"슬랩 할당기(slab allocator)"},{"type":"span","value":"를 통해 해결"}]},{"type":"paragraph","children":[{"type":"span","value":"다른 모든 요청은 더 일반적인 메모리 할당기에게 전달된다."}]},{"type":"paragraph","children":[{"type":"span","value":"[슬랩 할당기의 동작]"}]},{"type":"paragraph","children":[{"type":"span","value":"[1] 커널 부팅 시 커널 객체를 위한 여러 "},{"type":"span","marks":["highlight"],"value":"객체 캐시(object cache)"},{"type":"span","value":"를 할당\n"},{"type":"span","marks":["emphasis"],"value":"🔖 커널 객체: 파일 시스템 inode 등 자주 요청되는 자료 구조들을 일컬음.\n🔖 객체 캐시: 지정된 크기의 객체들로 구성된 빈 공간 리스트로 메모리 할당 및 해제 요청을 빠르게 서비스 하기 위해 사용됨."}]},{"type":"paragraph","children":[{"type":"span","value":"[2] 기존에 할당된 캐시 공간이 부족하면 상위 메모리 할당기에게 추가 "},{"type":"span","marks":["highlight"],"value":"슬랩"},{"type":"span","value":"을 요청\n🛸 요청의 전체 크기는 페이지 크기의 정수배"}]},{"type":"paragraph","children":[{"type":"span","value":"[3] 반대로 슬랩 내 객체들에 대한 참조 횟수가 0이 되면 상위 메모리는 이 슬랩을 회수할 수 있음.\n🛸 VM 시스템이 더 많은 메모리를 필요할 때 실제 회수가 일어남."}]},{"type":"paragraph","children":[{"type":"span","value":"빈 객체들을 사전에 초기화된 상태로 유지\n➡️ 개별 리스트 방식보다 우수"}]},{"type":"paragraph","children":[{"type":"span","value":"반납된 객체들을 초기화된 상태로 리스트에 유지\n➡️ 객체당 잦은 초기화와 반납의 작업을 피할 수 있으므로 오버헤드를 현저히 감소"}]},{"type":"heading","level":3,"children":[{"type":"span","value":"버디 할당"}]},{"type":"paragraph","children":[{"type":"span","value":"빈 공간의 합병은 할당기의 매우 중요한 기능 ➡️ 합병을 간단히 하는 방법들이 설계됨."}]},{"type":"paragraph","children":[{"type":"span","value":"이러한 예 중 하나가 "},{"type":"span","marks":["highlight"],"value":"이진 버디 할당기(binary buddy allocator)"}]},{"type":"paragraph","children":[{"type":"span","value":"빈 메모리는 처음에 개념적으로 크기 2^N인 하나의 큰 공간으로 생각됨."}]},{"type":"paragraph","children":[{"type":"span","value":"메모리 요청 발생 시, "},{"type":"span","marks":["highlight"],"value":"(요청한 공간의 크기 < 찾고자 하는 크기)를 만족하는 동안 빈 공간을 2개로 계속 분할"},{"type":"span","value":"한다."}]},{"type":"paragraph","children":[{"type":"span","value":"64KB의 빈 공간에서 7KB의 블럭을 할당하는 예시를 살펴보자."}]},{"code":"┌───────────────────────────────────────────────┐\n│                     64KB                      │\n└───────────────────────────────────────────────┘\n           ↓                        ↓\n┌───────────────────────┬───────────────────────┐\n│         32KB          │          32KB         │\n└───────────────────────┴───────────────────────┘\n      ↓           ↓\n┌───────────┬───────────┐\n│   16KB    │   16KB    │\n└───────────┴───────────┘\n   ↓     ↓\n┌─────┬─────┐\n│ 8KB │ 8KB │\n└─────┴─────┘","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"이와 같이 빈 공간을 2개로 분할한 후 왼쪽의 8KB 블럭이 할당되어 사용자에게 반환된다."}]},{"type":"paragraph","children":[{"type":"span","value":"이 방식은 "},{"type":"span","marks":["underline"],"value":"2의 거듭제곱 크기 만큼의 블럭만 할당"},{"type":"span","value":"할 수 있으므로 "},{"type":"span","marks":["highlight"],"value":"내부 단편화"},{"type":"span","value":"로 인한 문제가 두드러질 수 있음에 유의해야 한다."}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"버디 할당의 아름다움은 블럭이 해제될 때 나타난다."}]},{"type":"paragraph","children":[{"type":"span","value":"8KB 블럭을 빈 공간 리스트에 반환하는 경우를 살펴보자."}]},{"type":"paragraph","children":[{"type":"span","value":"[1] 할당기는 \"버디\" 8KB가 비어 있는지 확인한다."}]},{"type":"paragraph","children":[{"type":"span","value":"[2] 비어 있다면 두 블럭을 병합하여 16KB 블럭으로 만든다."}]},{"type":"paragraph","children":[{"type":"span","value":"[3] 할당기는 다음 16KB의 버디가 비어 있는지 확인한다."}]},{"type":"paragraph","children":[{"type":"span","value":"[4] 비어 있다면 이 두 블럭을 다시 합병한다."}]},{"type":"paragraph","children":[{"type":"span","value":"[5] 위의 과정을 재귀적으로 트리를 따라 전체 빈 공간이 복원되거나 버디가 사용 중이라는 것이 밝혀질 때까지 수행한다."}]},{"type":"paragraph","children":[{"type":"span","value":"버디 할당이 잘 작동하는 이유 ➡️ 특정 블럭의 버디를 결정하는 것이 쉬움."}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"각 버디 쌍의 주소는 오직 한 비트만 다름."},{"type":"span","value":"\n➡️ 어느 위치의 비트가 다른가는 버디 트리의 수준에 따라 달라짐."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"기타 아이디어"}]},{"type":"paragraph","children":[{"type":"span","value":"앞선 접근 방식들의 한 가지 문제점 ➡️ "},{"type":"span","marks":["highlight"],"value":"확장성"}]},{"type":"paragraph","children":[{"type":"span","value":"빈 공간들의 개수가 늘어남에 따라 리스트 검색이 매우 느려질 수 있음."}]},{"type":"paragraph","children":[{"type":"span","value":"좀 더 정교한 할당기는 복잡한 자료 구조를 사용하여 이 비용을 줄임.\n➡️ 균형 이진 트리, 스플레이 트리, 부분 정렬 트리 등이 있음."}]},{"type":"paragraph","children":[{"type":"span","value":"현대의 시스템은 멀티프로세서 및 멀티쓰레드로 작동됨.\n➡️ 멀티프로세서를 위해 할당기를 최적화하는 노력들이 많이 있었음."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"📚 참고 문헌"}]},{"type":"paragraph","children":[{"url":"https://pages.cs.wisc.edu/~remzi/OSTEP/vm-freespace.pdf","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"Operating Systems: Three Easy Pieces ― 17: Free-Space Management"}]}]},{"type":"paragraph","children":[{"url":"https://pages.cs.wisc.edu/~remzi/OSTEP/Korean/17-vm-freespace.pdf","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"운영체제 아주 쉬운 세 가지 이야기 ― 20: 빈 공간 관리"}]}]}]}}}}},"pageContext":{"id":"179076819","locale":"ko-KR"}},"staticQueryHashes":["1034768456","1118752904","2342916782","2757196681","3415878905","3879866231","4195094990"]}