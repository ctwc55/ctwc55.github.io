{"componentChunkName":"component---src-templates-article-jsx","path":"/blog/development/os-free-space-management","result":{"data":{"datoCmsMiscTextString":{"locale":"ko-KR","updatedAtText":"업데이트됨","nextReadText":"관련있는 게시물"},"datoCmsBlogPost":{"locale":"ko-KR","originalId":"179076819","title":"[운영체제][OSTEP] 빈 공간 관리","seo":{"seoTitle":"[운영체제][OSTEP] 빈 공간 관리","seoDescription":"메모리의 빈 공간을 관리하는 방법에 대해 공부해봅니다.","seoImage":{"seoImageUrl":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format"}},"subtitle":"메모리의 빈 공간을 관리하는 방법에 대해 공부해봅니다.","coverImage":{"coverImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&w=860","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.25&w=860 215w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.5&w=860 430w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&w=860 860w","sizes":"(min-width: 860px) 860px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgLCgoLDhMVDhcNDh0VDxUSGhYdHSIVFhUaKysjGh0oHSEWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLCgUFEBAOEC8oIhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIAAwAGAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAFAQQGAP/EAB0QAAEEAgMAAAAAAAAAAAAAAAEAAgMEESEFEjL/xAAWAQADAAAAAAAAAAAAAAAAAAAAAQP/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwDD1KM1uPLjpIRUI4GZc4aRXH25hTOHqqbth7yDIVIiXI2IQzqCoREhL/RyuQH/2Q=="},"width":860,"height":430}},"meta":{"updatedAt":"2023-07-30T01:28:04.444+09:00","firstPublishedAt":"2023-07-23T16:30:25.940+09:00"},"categoryLink":{"title":"개발 공부","id":"4743072"},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorPictureData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 60px) 60px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgWEQ8LDhgYDhUNDhgNDw8NFxUdGBYfFhUaHysjGikoHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OHBANHDUcIig7NS81NS81MjUvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAFAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAABQYHAv/EAB4QAAICAgMBAQAAAAAAAAAAAAABAgMFBgQRQXEi/8QAFQEBAQAAAAAAAAAAAAAAAAAABAP/xAAaEQACAwEBAAAAAAAAAAAAAAAAAQIDEhMR/9oADAMBAAIRAxEAPwDT8/1LHSK/r67scevSfz99VXBkm/Cva/zKle/pCc/JoRXWsFujxvygcLI1pAXqQTmjONm2RzpceyCwmwxpsbbADWJdBFbeCfe2wXoAGpIL6z//2Q=="},"width":60,"height":60}}},"relatedPosts":[{"id":"177405298","meta":{"updatedAt":"2023-07-18T23:24:51.666+09:00"},"categoryLink":{"title":"개발 공부"},"coverImage":{"gatsbyImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.09&w=860 75w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.18&w=860 150w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860 300w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.7&w=860 600w","sizes":"(min-width: 300px) 300px, 100vw"}},"layout":"constrained","width":300,"height":120},"squaredImage":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.06&fit=crop&fp-x=0.5&fp-y=0.5&w=430 25w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.12&fit=crop&fp-x=0.5&fp-y=0.5&w=430 50w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430 100w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.47&fit=crop&fp-x=0.5&fp-y=0.5&w=430 200w","sizes":"(min-width: 100px) 100px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBhINEBAQCggUDg0IDgcHFh0JFhEYFxUZGCIVFhUaHysjGh0oHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OEg4REC8dFhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAGAMBIgACEQEDEQH/xAAaAAEBAAIDAAAAAAAAAAAAAAAABAUGAQID/8QAHRAAAgICAwEAAAAAAAAAAAAAAAIDBAEREhQVBf/EABYBAQEBAAAAAAAAAAAAAAAAAAADAf/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/ANASs2WLoaraMl1o0O241wSYlSHjgHM9hVAEFr6bKSemzAAeclpnAAH/2Q=="},"width":100,"height":100}},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.11&w=77 8w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 30px) 30px, 100vw"}},"layout":"constrained","width":30,"height":30}}},"subtitle":"대용량 주소 공간을 지원하는 방법에 대해 공부해봅니다.","title":"[운영체제][OSTEP] 세그멘테이션"}],"structuredBody":{"blocks":[],"links":[{"id":"177405298"}],"value":{"schema":"dast","document":{"type":"root","children":[{"type":"heading","level":2,"children":[{"type":"span","value":"🚪 들어가며"}]},{"type":"paragraph","children":[{"type":"span","value":"빈 공간 관리가 어려운 경우: 관리하는 공간이 "},{"type":"span","marks":["highlight"],"value":"가변-크기 빈 공간들의 집합"},{"type":"span","value":"으로 구성된 경우\nex1) 사용자-수준 메모리 할당 라이브러리("},{"type":"span","marks":["code"],"value":"malloc()"},{"type":"span","value":", "},{"type":"span","marks":["code"],"value":"free()"},{"type":"span","value":")\nex2) "},{"type":"span","marks":["underline"],"value":"세그멘테이션"},{"type":"span","value":"으로 물리 메모리를 관리하는 운영체제\n➡️ 위 예시들과 같은 경우 "},{"type":"span","marks":["highlight"],"value":"외부 단편화"},{"type":"span","value":" 존재"}]},{"type":"paragraph","children":[{"type":"span","value":"(빈 공간들의 전체 크기) > (요청된 크기) 이더라도 하나의 연속된 영역 존재X 일 경우\n➡️ 요청 실패"}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"1️⃣ 가정"}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"malloc()"},{"type":"span","value":"과 "},{"type":"span","marks":["code"],"value":"free()"},{"type":"span","value":"에서 제공하는 것과 같은 기본 인터페이스를 가정"}]},{"type":"heading","level":3,"children":[{"type":"span","value":"void *malloc(size_t size)"}]},{"type":"paragraph","children":[{"type":"span","value":"인자: 응용 프로그램의 요청 바이트 수\n반환: 요청된 크기와 같거나 큰 영역을 가리키는 void 포인터"}]},{"type":"heading","level":3,"children":[{"type":"span","value":"void free(void *ptr)"}]},{"type":"paragraph","children":[{"type":"span","value":"인자: 포인터\n반환: 해당 영역을 해제"}]},{"type":"paragraph","children":[{"type":"span","value":"위의 루틴들을 포함하는 라이브러리가 관리하는 공간: "},{"type":"span","marks":["highlight"],"value":"힙(heap)"}]},{"type":"paragraph","children":[{"type":"span","value":"힙의 "},{"type":"span","marks":["highlight"],"value":"빈 공간"},{"type":"span","value":" 관리: 일반적인 "},{"type":"span","marks":["highlight"],"value":"링크드리스트"},{"type":"span","value":" 사용(반드시 리스트일 필요X)"}]},{"type":"paragraph","children":[{"type":"span","value":"할당된 메모리 > 요청한 메모리\n➡️ 할당 청크의 내부에서 낭비가 발생: "},{"type":"span","marks":["highlight"],"value":"내부 단편화"}]},{"type":"paragraph","children":[{"type":"span","value":"클라이언트에게 할당된 메모리는 다른 위치로 재배치될 수 없다고 가정\n➡️ ⚠️ 단편화 해결에 유용하게 사용되는 빈 공간의 "},{"type":"span","marks":["highlight"],"value":"압축"},{"type":"span","value":"은 이 경우 "},{"type":"span","marks":["underline"],"value":"사용 불가능"}]},{"type":"paragraph","children":[{"type":"span","value":"운영체제가 세그멘트를 구현할 때에는 단편화 해결을 위해 압축을 사용할 수 있음\n➡️ "},{"item":"177405298","meta":[{"id":"target","value":"_blank"}],"type":"itemLink","children":[{"type":"span","value":"세그멘테이션"}]},{"type":"span","value":" 내용 참고"}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"2️⃣ 저수준 기법들"}]},{"type":"heading","level":3,"children":[{"type":"span","value":"분할과 병합"}]},{"type":"paragraph","children":[{"type":"span","value":"빈 공간 리스트: 힙에 있는 빈 공간들의 집합"}]},{"type":"paragraph","children":[{"type":"span","value":"30바이트의 힙이 있다고 가정하자."}]},{"code":"┌──────────┬────────────┬────────────┐\n│   free   │    used    │    free    │\n└──────────┴────────────┴────────────┘\n0          10           20           30","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"이 힙의 빈 공간 리스트는 다음과 같이 나타날 수 있다."}]},{"code":"       ┌─────────┐   ┌──────────┐\n       │ addr: 0 │   │ addr: 20 │\nhead → │         │ → │          │ → NULL\n       │ len: 10 │   │ len: 10  │\n       └─────────┘   └──────────┘","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"이 예시의 경우 10바이트를 초과하는 모든 요청은 실패하여 NULL을 반환한다.\n10바이트에 대한 요청은 둘 중 하나의 빈 청크를 사용하여 쉽게 충족된다.\n이때, "},{"type":"span","marks":["underline"],"value":"10바이트보다 적은 요청"},{"type":"span","value":"에 대해서는 어떤 일이 일어날까?"}]},{"type":"paragraph","children":[{"type":"span","value":"메모리를 1바이트만 요청했다고 가정 ➡️ 할당기(allocator)는 "},{"type":"span","marks":["highlight"],"value":"분할(splitting)"},{"type":"span","value":" 작업을 수행"}]},{"type":"paragraph","children":[{"type":"span","value":"이는 "},{"type":"span","marks":["highlight"],"value":"요청을 만족시킬 수 있는 빈 청크를 찾아 둘로 분할"},{"type":"span","value":"한 후 "},{"type":"span","marks":["highlight"],"value":"첫 번째 청크는 호출자에게 반환"},{"type":"span","value":"하고 "},{"type":"span","marks":["highlight"],"value":"두 번째 청크는 리스트"},{"type":"span","value":"에 남게하는 작업"}]},{"type":"paragraph","children":[{"type":"span","value":"위의 예시에서 할당기가 두 번째 원소를 사용하여 요청을 충족시키기로 한 경우 최종적으로 빈 공간 리스트는 다음과 같이 바뀐다."}]},{"code":"       ┌─────────┐   ┌──────────┐\n       │ addr: 0 │   │ addr: 21 │\nhead → │         │ → │          │ → NULL\n       │ len: 10 │   │ len: 9   │\n       └─────────┘   └──────────┘","type":"code"},{"type":"paragraph","children":[{"type":"span","marks":["strikethrough"],"value":"이와 같이 기본적인 리스트의 모습은 바뀌지 않고 분할이 수행된 원소의 구성 값이 바뀐 것을 알 수 있다."}]},{"type":"paragraph","children":[{"type":"span","value":"⭐ 이처럼 "},{"type":"span","marks":["highlight"],"value":"요청이 특정 빈 청크의 크기보다 작은 경우 분할 기법을 사용"},{"type":"span","value":"한다."}]},{"type":"paragraph","children":[{"type":"span","value":"이러한 분할에 동반되는 기법은 빈 공간의 "},{"type":"span","marks":["highlight"],"value":"병합(coalescing)"},{"type":"span","value":"이다."}]},{"type":"paragraph","children":[{"type":"span","value":"다시 위의 첫 예시를 가지고 와보자."}]},{"code":"┌──────────┬────────────┬────────────┐\n│   free   │    used    │    free    │\n└──────────┴────────────┴────────────┘\n0          10           20           30","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"이 상태에서 응용 프로그램이 "},{"type":"span","marks":["code"],"value":"free(10)"},{"type":"span","value":"을 호출하여 힙의 중간에 존재하는 공간을 반환하는 경우"}]},{"code":"       ┌──────────┐   ┌─────────┐   ┌──────────┐\n       │ addr: 10 │   │ addr: 0 │   │ addr: 20 │\nhead → │          │ → │         │ → │          │ → NULL\n       │ len: 10  │   │ len: 10 │   │ len: 10  │\n       └──────────┘   └─────────┘   └──────────┘","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"빈 공간 리스트는 위와 같이 나타날 수 있는데, 이때 발생할 수 있는 문제점을 살펴보자."}]},{"type":"paragraph","children":[{"type":"span","value":"힙 전체가 비어 있지만, 10바이트 길이의 청크 3개로 나누어져 있다.\n➡️ 사용자가 20바이트를 요청하는 경우 실패 반환"}]},{"type":"paragraph","children":[{"type":"span","value":"⭐ 할당기는 이 문제를 방지하기 위해 "},{"type":"span","marks":["highlight"],"value":"메모리 청크가 반환될 때 빈 공간들을 병합"}]},{"type":"paragraph","children":[{"type":"span","value":"💡 아이디어\n메모리 청크 반환 시 "},{"type":"span","marks":["highlight"],"value":"해제되는 청크의 주소와 바로 인접한 빈 청크들이 존재하는 경우 하나의 더 큰 빈 청크로 병합"},{"type":"span","value":"한다."}]},{"type":"paragraph","children":[{"type":"span","value":"병합 수행 후 최종 리스트는 다음과 같이 바뀐다."}]},{"code":"       ┌─────────┐\n       │ addr: 0 │\nhead → │         │ → NULL\n       │ len: 30 │\n       └─────────┘","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"이 상태는 할당이 한 번도 일어나지 않은 최초의 힙 리스트와 동일하다."}]},{"type":"paragraph","children":[{"type":"span","value":"병합 기법을 통해 "},{"type":"span","marks":["highlight"],"value":"할당기가 큰 빈 공간을 응용 프로그램에게 제공할 수 있다는 것을 더욱 보장"},{"type":"span","value":"할 수 있다."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"할당된 공간의 크기 파악"}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"free(void *ptr)"},{"type":"span","value":" 인터페이스 ➡️ 크기를 매개변수로 받지 않음."}]},{"type":"paragraph","children":[{"type":"span","value":"포인터가 인자로 전달되면 "},{"type":"span","marks":["code"],"value":"malloc"},{"type":"span","value":" 라이브러리는 해제되는 메모리 영역의 크기를 신속히 파악하여 그 공간을 빈 공간 리스트에 추가시킬 수 있다고 가정\n➡️ 이 작업을 위해 대부분의 할당기는 추가 정보를 "},{"type":"span","marks":["highlight"],"value":"헤더(header)"},{"type":"span","value":" 블럭에 저장"}]},{"type":"paragraph","children":[{"type":"span","value":"헤더 블럭은 메모리에 유지되며 보통 해제된 청크 바로 직전에 위치"}]},{"type":"paragraph","children":[{"type":"span","value":"다음의 예시를 살펴보자."}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"ptr"},{"type":"span","value":"이 크기 20바이트의 할당된 블럭을 가리키고 있다. "},{"type":"span","marks":["code"],"value":"ptr = malloc(20);"}]},{"code":"      ┌────────────────┐ ┐\n      │                │ │\n      │                │ ├ The header used by malloc library\n      │                │ │\nptr → ├────────────────┤ ┤\n      │                │ │\n      │                │ │\n      │                │ ├ The 20 bytes returned to caller\n      │                │ │\n      │                │ │\n      └────────────────┘ ┘","type":"code"},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"헤더는 적어도 할당된 공간의 크기는 저장"},{"type":"span","value":"해야하며, 해제 속도를 향상시키기 위한 추가의 포인터, 부가적인 무결성 검사를 제공하기 위한 매직 넘버 및 기타 정보를 저장할 수 있다.\n🔖 "},{"type":"span","marks":["emphasis"],"value":"매직 넘버: 상수로 선언하지 않은 숫자를 의미하며, 코드를 작성한 사람이 아니고서는 그 의미를 파악하기 어렵기 때문에 매직이라는 수식어가 붙게 되었다."}]},{"type":"paragraph","children":[{"type":"span","value":"예를 들어, 다음과 같이 헤더를 가정하는 경우"}]},{"code":"typedef struct __header_t {\n  int size;\n  int magic;\n} header_t;","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"헤더는 다음과 같이 표현할 수 있다."}]},{"code":"hptr → ┌────────────────┐\n       │ size:       20 │\n       ├────────────────┤\n       │ magic: 1234567 │\n ptr → ├────────────────┤ ┐\n       │                │ │\n       │                │ │\n       │                │ ├ The 20 bytes returned to caller\n       │                │ │\n       │                │ │\n       └────────────────┘ ┘","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"사용자가 free(ptr)을 호출하면 라이브러리는 헤더의 시작 위치를 파악하기 위해 간단한 포인터 연산을 한다."}]},{"code":"void free(void *ptr) {\n  header_t *hptr = (void *)ptr − sizeof(header_t);\n  ...","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"헤더를 가리키는 포인터를 얻어 낸 후, 라이브러리는 매직 넘버가 기대하는 값과 일치하는지 비교하여 "},{"type":"span","marks":["highlight"],"value":"안전성 검사(sanity check)"},{"type":"span","value":"를 실시한다.("},{"type":"span","marks":["code"],"value":"assert(hptr->magic == 1234567)"},{"type":"span","value":")"}]},{"type":"paragraph","children":[{"type":"span","value":"그 후 새로 해제된 영역의 크기를 계산한다. (헤더의 크기 + 영역의 크기)\n➡️ 빈 영역의 크기 = 헤더의 크기 + 사용자에게 할당된 영역의 크기"}]},{"type":"paragraph","children":[{"type":"span","value":"N 바이트의 메모리 청크 요청 ➡️ "},{"type":"span","marks":["highlight"],"value":"라이브러리는 (빈 청크의 크기 N + 헤더의 크기)인 청크를 탐색"}]},{"type":"heading","level":3,"children":[{"type":"span","value":"빈 공간 리스트 내장"}]},{"type":"paragraph","children":[{"type":"span","value":"이러한 빈 공간 리스트를 실제로 어떻게 구현할 수 있을까?"}]},{"type":"paragraph","children":[{"type":"span","value":"새로운 노드를 위한 공간이 필요할 때 ➡️ "},{"type":"span","marks":["code"],"value":"malloc()"},{"type":"span","value":" 호출\nBut, 메모리 할당 라이브러리 루틴에서는 이것이 불가능"}]},{"type":"paragraph","children":[{"type":"span","value":"4096바이트 크기의 메모리 청크가 있다고 가정하자.(= 4KB 힙)"}]},{"type":"paragraph","children":[{"type":"span","value":"리스트 노드를 다음과 같이 표현할 수 있을 때, 이 메모리 청크를 빈 공간 리스트로 관리하기 위한 과정을 살펴보자."}]},{"code":"typedef struct __node_t {\n  int size;\n  struct __node_t *next;\n} node_t;","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":" 🧹 먼저 "},{"type":"span","marks":["highlight"],"value":"리스트를 초기화"},{"type":"span","value":" 한다.(초기에 4096 - 헤더 크기 길이의 항목 하나를 가짐.)"}]},{"type":"paragraph","children":[{"type":"span","value":"힙을 시스템 콜 "},{"type":"span","marks":["code"],"value":"mmap()"},{"type":"span","value":"을 호출하여 얻어진 영역에 구축된다고 가정할 때, 힙을 초기화하고 힙에 빈 공간 리스트의 첫 번째 원소를 넣는 코드는 다음과 같다."}]},{"code":"// mmap()이 빈 공간의 청크에 대한 포인터를 반환\nnode_t *head = mmap(NULL, 4096, PROT_READ|PROT_WRITE,\n                    MAP_ANON|MAP_PRIVATE, −1, 0);\nhead−>size = 4096 − sizeof(node_t);\nhead−>next = NULL;","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"위 코드 실행 후 리스트는 크기 4088(4096-8(node_t))의 항목 하나만을 가지게 된다."}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"head"},{"type":"span","value":" 포인터가 가리키는 이 영역의 시작 주소를 16KB라고 가정하면 힙의 모양은 다음과 같다."}]},{"code":"head → ┌────────────────┐ [virtual address: 16KB]\n       │ size:     4088 │ header: size field\n       ├────────────────┤\n       │ next:        0 │ header: next field(NULL is 0)\n ptr → ├────────────────┤ ┐\n       │                │ │\n       │                │ │\n               ...        ├ The rest of the 4KB chunk\n       │                │ │\n       │                │ │\n       └────────────────┘ ┘","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"이때, 100바이트 메모리 청크가 요청된다면 라이브러리는 먼저 충분한 크기의 청크를 찾는다.\n➡️ 현 시점에서는 하나의 빈 청크(크기: 4088)만 존재하므로 해당 청크가 선택됨."}]},{"type":"paragraph","children":[{"type":"span","value":"✂️ 선택된 청크를 "},{"type":"span","marks":["highlight"],"value":"(빈 영역의 크기 + 헤더의 크기)를 충족하는 청크와 나머지 빈 청크 두 개로 분할"},{"type":"span","value":"한다."}]},{"type":"paragraph","children":[{"type":"span","value":"헤더의 크기를 8바이트라고 가정하면 힙의 공간 모습은 다음과 비슷할 것이다."}]},{"code":"       ┌────────────────┐ [virtual address: 16KB]\n       │ size:      100 │ \n       ├────────────────┤\n       │ magic: 1234567 │ \n ptr → ├────────────────┤ ┐\n       │                │ │\n       │                │ │\n               ...        ├ The 100 bytes now allocated\n       │                │ │\n       │                │ │\nhead → ├────────────────┤ ┘\n       │ size:     3980 │ \n       ├────────────────┤\n       │ next:        0 │ \n       ├────────────────┤ ┐\n       │                │ │\n       │                │ │\n               ...        ├ The free 3980 byte chunk\n       │                │ │\n       │                │ │\n       └────────────────┘ ┘","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"즉, 108바이트를 할당하고 할당 영역을 가리키는 포인터(위의 "},{"type":"span","marks":["code"],"value":"ptr"},{"type":"span","value":")를 반환한다."}]},{"type":"paragraph","children":[{"type":"span","value":"할당된 공간 직전의 8바이트에는 헤더 정보가 담기는데, 이 정보는 "},{"type":"span","marks":["code"],"value":"free()"},{"type":"span","value":"시 활용된다."}]},{"type":"paragraph","children":[{"type":"span","value":"다음으로는 아래와 같이 호출 프로그램에 의해 사용 중인 3개의 100바이트 영역이 존재하는 상황에서 프로그램이 "},{"type":"span","marks":["code"],"value":"free()"},{"type":"span","value":"를 통해 일부 메모리를 반환하는 경우를 살펴보자."}]},{"code":"       ┌────────────────┐ [virtual address: 16KB]\n       │ size:      100 │ \n       ├────────────────┤\n       │ magic: 1234567 │ \n       ├────────────────┤ ┐\n       │                │ │\n       │                │ │\n               ...        ├ 100 bytes still allocated\n       │                │ │\n       │                │ │\n       ├────────────────┤ ┘   \n       │ size:      100 │ \n       ├────────────────┤\n       │ magic: 1234567 │ \nsptr → ├────────────────┤ ┐\n       │                │ │\n       │                │ │\n               ...        ├ 100 bytes still allocated\n       │                │ │  (but about to be freed)\n       │                │ │\n       ├────────────────┤ ┘\n       │ size:      100 │ \n       ├────────────────┤\n       │ magic: 1234567 │ \n       ├────────────────┤ ┐\n       │                │ │\n       │                │ │\n               ...        ├ 100 bytes now allocated\n       │                │ │\n       │                │ │\nhead → ├────────────────┤ ┘\n       │ size:     3764 │ \n       ├────────────────┤\n       │ next:        0 │ \n       ├────────────────┤ ┐\n       │                │ │\n       │                │ │\n               ...        ├ The free 3764 byte chunk\n       │                │ │\n       │                │ │\n       └────────────────┘ ┘","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"응용 프로그램은 이제 "},{"type":"span","marks":["code"],"value":"free(16500)"},{"type":"span","value":"을 호출하여 할당 영역 중 가운데 청크를 반환한다.\n➡️ 16500("},{"type":"span","marks":["code"],"value":"sptr"},{"type":"span","value":") = 16384(시작 주소) + 108(이전 메모리 청크) + 8(해체 청크의 헤더)"}]},{"type":"paragraph","children":[{"type":"span","value":"라이브러리는 빈 공간의 크기를 파악한 후 빈 청크를 빈 공간 리스트에 삽입한다."}]},{"type":"paragraph","children":[{"type":"span","value":"이때, 빈 공간 리스트의 헤드 쪽에 삽입한다고 가정하면 공간의 모양은 다음과 같아진다."}]},{"code":"       ┌────────────────┐ [virtual address: 16KB]\n       │ size:      100 │ \n       ├────────────────┤\n       │ magic: 1234567 │ \n       ├────────────────┤ ┐\n       │                │ │\n       │                │ │\n               ...        ├ The 100 bytes still allocated\n       │                │ │\n       │                │ │\nhead → ├────────────────┤ ┘   \n       │ size:      100 │ \n       ├────────────────┤\n       │ next:    16708 │ ───────────────────────────────┐\nsptr → ├────────────────┤                                │\n       │                │                                │\n       │                │                                │\n               ...          (now a free chunk of memory) │\n       │                │                                │     \n       │                │                                │\n       ├────────────────┤                                │\n       │ size:      100 │                                │\n       ├────────────────┤                                │\n       │ magic: 1234567 │                                │\n       ├────────────────┤ ┐                              │\n       │                │ │                              │\n       │                │ │                              │\n               ...        ├ 100 bytes now allocated      │\n       │                │ │                              │\n       │                │ │                              │\n       ├────────────────┤ ┘                              │\n       │ size:     3764 │←───────────────────────────────┘\n       ├────────────────┤\n       │ next:        0 │ \n       ├────────────────┤ ┐\n       │                │ │\n       │                │ │\n               ...        ├ The free 3764 byte chunk\n       │                │ │\n       │                │ │\n       └────────────────┘ ┘","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"이제 빈 공간 리스트는 순서대로 작은 빈 청크(100바이트), 큰 빈 청크(3764바이트)로 구성된다.\n➡️ ⚠️ 단편화가 발생한다!"}]},{"type":"paragraph","children":[{"type":"span","value":"여기서 마지막 2개의 사용 중인 청크가 해제된다고 할 때, 병합이 없다면 작은 단편으로 이루어진 빈 공간 리스트가 될 것이다.\n➡️ 따라서 "},{"type":"span","marks":["highlight"],"value":"리스트를 순회하며 인접한 청크를 병합"},{"type":"span","value":"하여 이를 해결한다."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"힙의 확장"}]},{"type":"paragraph","children":[{"type":"span","value":"힙 공간이 부족한 경우에는 어떻게 해야 할까?\n➡️ 가장 쉬운 방법: 단순히 실패를 반환하는 것(경우에 따라 유일한 대안일 수 있음.)"}]},{"type":"paragraph","children":[{"type":"span","value":"대부분의 전통적인 할당기 ➡️ 적은 크기의 힙으로 시작하여 모두 소진하면 운영체제로부터 더 많은 메모리를 요청"}]},{"type":"paragraph","children":[{"type":"span","value":"할당기는 힙을 확장하기 위하여 특정 시스템 콜(예: "},{"type":"span","marks":["code"],"value":"sbrk"},{"type":"span","value":") 호출 후 확장된 영역에서 새로운 청크를 할당"}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"sbrk"},{"type":"span","value":" 요청을 수행하기 위해 운영체제는 빈 물리 페이지를 찾아 요청 프로세스의 주소 공간에 매핑한 후, 새로운 힙의 마지막 주소를 반환"}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"3️⃣ 기본 전략"}]},{"type":"paragraph","children":[{"type":"span","value":"이상적인 할당기 = "},{"type":"span","marks":["highlight"],"value":"빠른 속도 & 단편화 최소"}]},{"type":"paragraph","children":[{"type":"span","value":"하지만 할당과 해제 요청 스트림은 무작위(프로그래머에 의해 결정)로 이루어지기 때문에 어느 특정 전략도 경우에 따라 성능이 매우 좋지 않을 수 있음."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"최적 적합(Best Fit)"}]},{"type":"paragraph","children":[{"type":"span","value":""}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"4️⃣"}]}]}}}}},"pageContext":{"id":"179076819","locale":"ko-KR"}},"staticQueryHashes":["1034768456","1118752904","2342916782","2757196681","3415878905","3879866231","4195094990"]}