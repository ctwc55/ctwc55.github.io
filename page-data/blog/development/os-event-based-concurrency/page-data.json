{"componentChunkName":"component---src-templates-article-jsx","path":"/blog/development/os-event-based-concurrency","result":{"data":{"datoCmsMiscTextString":{"locale":"ko-KR","updatedAtText":"업데이트됨","nextReadText":"관련있는 게시물"},"datoCmsBlogPost":{"locale":"ko-KR","originalId":"201762509","title":"[운영체제][OSTEP] 이벤트 기반의 병행성","seo":{"seoTitle":"[운영체제][OSTEP] 이벤트 기반의 병행성","seoDescription":"쓰레드 없이 병행 서버를 개발하는 방법에 대해 공부해봅니다.","seoImage":{"seoImageUrl":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format"}},"subtitle":"쓰레드 없이 병행 서버를 개발하는 방법에 대해 공부해봅니다.","coverImage":{"coverImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&w=860","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.25&w=860 215w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.5&w=860 430w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&w=860 860w","sizes":"(min-width: 860px) 860px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgLCgoLDhMVDhcNDh0VDxUSGhYdHSIVFhUaKysjGh0oHSEWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLCgUFEBAOEC8oIhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIAAwAGAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAFAQQGAP/EAB0QAAEEAgMAAAAAAAAAAAAAAAEAAgMEESEFEjL/xAAWAQADAAAAAAAAAAAAAAAAAAAAAQP/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwDD1KM1uPLjpIRUI4GZc4aRXH25hTOHqqbth7yDIVIiXI2IQzqCoREhL/RyuQH/2Q=="},"width":860,"height":430}},"meta":{"updatedAt":"2023-09-25T23:39:19.679+09:00","firstPublishedAt":"2023-09-24T14:52:11.197+09:00"},"categoryLink":{"title":"개발 공부","id":"4743072"},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorPictureData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 60px) 60px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgWEQ8LDhgYDhUNDhgNDw8NFxUdGBYfFhUaHysjGikoHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OHBANHDUcIig7NS81NS81MjUvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAFAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAABQYHAv/EAB4QAAICAgMBAQAAAAAAAAAAAAABAgMFBgQRQXEi/8QAFQEBAQAAAAAAAAAAAAAAAAAABAP/xAAaEQACAwEBAAAAAAAAAAAAAAAAAQIDEhMR/9oADAMBAAIRAxEAPwDT8/1LHSK/r67scevSfz99VXBkm/Cva/zKle/pCc/JoRXWsFujxvygcLI1pAXqQTmjONm2RzpceyCwmwxpsbbADWJdBFbeCfe2wXoAGpIL6z//2Q=="},"width":60,"height":60}}},"relatedPosts":[{"id":"200585869","meta":{"updatedAt":"2023-09-24T14:53:16.155+09:00"},"categoryLink":{"title":"개발 공부"},"coverImage":{"gatsbyImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.09&w=860 75w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.18&w=860 150w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860 300w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.7&w=860 600w","sizes":"(min-width: 300px) 300px, 100vw"}},"layout":"constrained","width":300,"height":120},"squaredImage":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.06&fit=crop&fp-x=0.5&fp-y=0.5&w=430 25w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.12&fit=crop&fp-x=0.5&fp-y=0.5&w=430 50w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430 100w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.47&fit=crop&fp-x=0.5&fp-y=0.5&w=430 200w","sizes":"(min-width: 100px) 100px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBhINEBAQCggUDg0IDgcHFh0JFhEYFxUZGCIVFhUaHysjGh0oHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OEg4REC8dFhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAGAMBIgACEQEDEQH/xAAaAAEBAAIDAAAAAAAAAAAAAAAABAUGAQID/8QAHRAAAgICAwEAAAAAAAAAAAAAAAIDBAEREhQVBf/EABYBAQEBAAAAAAAAAAAAAAAAAAADAf/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/ANASs2WLoaraMl1o0O241wSYlSHjgHM9hVAEFr6bKSemzAAeclpnAAH/2Q=="},"width":100,"height":100}},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.11&w=77 8w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 30px) 30px, 100vw"}},"layout":"constrained","width":30,"height":30}}},"subtitle":"일반적인 병행성 관련 오류들을 어떻게 처리하는지 공부해봅니다.","title":"[운영체제][OSTEP] 병행성 관련 오류"}],"structuredBody":{"blocks":[],"links":[],"value":{"schema":"dast","document":{"type":"root","children":[{"type":"heading","level":2,"children":[{"type":"span","value":"🚪 들어가며"}]},{"type":"paragraph","children":[{"type":"span","value":"GUI 기반의 프로그램이나 인터넷 서버에서는 다른 스타일의 병행 프로그래밍이 사용됨.\n➡️ "},{"type":"span","marks":["highlight"],"value":"이벤트 기반의 병행성(event-based concurrency)"}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"node.js"},{"type":"span","value":"와 같은 서버 프레임워크에서 사용됨.\n➡️ 시작점은 C와 유닉스 시스템"}]},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 이벤트 기반의 병행성은 두 개의 문제를 갖고 있음."}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"멀티 쓰레드 프로그램에서 올바르게 사용하는 것이 매우 어려움."}]},{"type":"paragraph","children":[{"type":"span","value":"➡️ 락 누락, 교착 상태 등"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"멀티 쓰레드 프로그램에서는 개발자가 쓰레드 스케줄링에 대한 제어권을 전혀 갖고 있지 않음."}]},{"type":"paragraph","children":[{"type":"span","value":"➡️ 운영체제가 합리적으로 스케줄링하기만을 기대"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"따라서 "},{"type":"span","marks":["highlight"],"value":"쓰레드 없이 병행 서버를 구현"},{"type":"span","value":"할 때, "},{"type":"span","marks":["highlight"],"value":"병행성을 유지하면서 각종 문제들을 피하는 방법"},{"type":"span","value":"에 대해서 알아보자."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"1️⃣ 기본 개념: 이벤트 루프"}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"이벤트 기반의 병행성"},{"type":"span","value":": 특정 사건(\"이벤트\")의 발생을 대기\n➡️ 사건이 발생하면, 사건의 종류를 파악한 후 I/O을 요청하거나 추후 처리를 위한 다른 이벤트 발생 등의 작업을 수행"}]},{"type":"paragraph","children":[{"type":"span","value":"먼저, 고전적인 이벤트 기반의 서버가 어떻게 생겼는지 살펴보자."}]},{"code":"while (1) {\n  events = getEvents();\n  for (e in events)\n    processEvent(e);\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"이벤트 루프(event loop)"},{"type":"span","value":"라는 단순한 구조를 기반으로 짜여 있음.\n➡️ 루프내에서 사건 발생을 대기하다가 이벤트가 발생하면 하나씩 처리"}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"이벤트 핸들러(event handler)"},{"type":"span","value":": 이벤트를 처리하는 코드"}]},{"type":"paragraph","children":[{"type":"span","value":"⭐ 이벤트의 처리가 시스템의 유일한 작업\n➡️ "},{"type":"span","marks":["highlight"],"value":"다음에 처리할 이벤트를 결정하는 것이 스케줄링과 동일한 효과"}]},{"type":"paragraph","children":[{"type":"span","value":"✅ 스케줄링을 제어할 수 있는 기능이 이벤트 기반 방법의 큰 장점 중 하나"}]},{"type":"paragraph","children":[{"type":"span","value":"그런데 발생한 이벤트가 무슨 이벤트인지 어떻게 판단할까?\n➡️ 네트워크나 디스크 I/O의 경우(어떤 디스크 요청이 완료?) 특히 쉽지 않음."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"2️⃣ 중요 API: select() (또는 poll())"}]},{"type":"paragraph","children":[{"type":"span","value":"대부분의 시스템은 "},{"type":"span","marks":["code"],"value":"select()"},{"type":"span","value":" 또는 "},{"type":"span","marks":["code"],"value":"poll()"},{"type":"span","value":" 시스템 콜을 기본 API로서 제공\n➡️ 도착한 I/O들 중 주목할 만한 것이 있는지를 검사\n➡️ 예를 들면, 웹 서버 같은 네트워크 응용 프로그램이 자신이 처리할 패킷의 도착 여부를 검사"}]},{"type":"paragraph","children":[{"type":"span","value":"Mac OS X가 제공하는 메뉴얼은 "},{"type":"span","marks":["code"],"value":"select()"},{"type":"span","value":"를 다음과 같이 설명"}]},{"code":"int select(int nfds,\n           fd_set *restrict readfds,\n           fd_set *restrict writefds,\n           fd_set *restrict errorfds,\n           struct timeval *restrict timeout);","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"인자들을 통해 전달된 I/O 디스크립터(descriptor) 집합들을 검사해서 각 디스크립터들에 해당하는 입출력 디바이스가 읽을 준비가 되었는지, 쓸 준비가 되었는지, 처리해야할 예외 조건이 발생했는지 등을 파악함."}]},{"type":"paragraph","children":[{"type":"span","value":"다음과 같은 순서로 진행된다."}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"각 집합의 첫 번째 "},{"type":"span","marks":["code"],"value":"nfds"},{"type":"span","value":" 개의 디스크립터들(0~nfds-1)을 검사"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"select"},{"type":"span","value":"는 집합을 가리키는 각 포인터들을 준비된 디스크립터들의 집합으로 교체"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"select()"},{"type":"span","value":"는 전체집합에서 준비된 디스크립터들의 총 개수를 반환"}]}]}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"select()"},{"type":"span","value":"에 대해 두 가지 알아두어야 할 사항이 있다."}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"select()"},{"type":"span","value":"를 이용하면 디스크립터에 대한 읽기 가능여부, 쓰기 가능여부를 검사할 수 있다."}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"전자는 처리해야 할 패킷의 도착 여부를 파악할 수 있도록 함."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"후자는 서비스가 응답전송이 가능한 시점을 파악하도록 함."}]}]}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"timeout"},{"type":"span","value":" 인자의 존재"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"일반적으로는 "},{"type":"span","marks":["code"],"value":"NULL"},{"type":"span","value":"로 설정"}]},{"type":"paragraph","children":[{"type":"span","value":"➡️ "},{"type":"span","marks":["code"],"value":"select()"},{"type":"span","value":"는 디스크립터가 준비될 때까지 무한정 대기"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"오류에 대비하도록 설계된 서버들의 경우 "},{"type":"span","marks":["code"],"value":"timeout"},{"type":"span","value":" 값을 설정해 두기도 함."}]},{"type":"paragraph","children":[{"type":"span","value":"➡️ 널리 사용되는 방법: 0으로 설정하여 즉시 리턴하도록 함."}]}]}]}]}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"poll()"},{"type":"span","value":" 시스템 콜도 이와 유사함."}]},{"type":"paragraph","children":[{"type":"span","value":"이러한 기본 함수로 non-blocking event loop를 만들어, 패킷 도착을 확인하고, 소켓에서 메시지를 읽고 필요에 응답할 수 있도록 해줌."}]},{"type":"paragraph","children":[{"type":"span","value":"💡 "},{"type":"span","marks":["highlight"],"value":"차단(blocking)과 비차단(non-blocking) 인터페이스"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"차단(또는 "},{"type":"span","marks":["highlight"],"value":"동기(synchronous)"},{"type":"span","value":") 인터페이스"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"호출자에게 리턴하기 전에 자신의 작업을 모두 처리"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"차단 호출은 "},{"type":"span","marks":["highlight"],"value":"주로 I/O 때문에 발생"}]}]}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"비차단(또는 "},{"type":"span","marks":["highlight"],"value":"비동기(asynchronous)"},{"type":"span","value":") 인터페이스"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"작업을 시작하기는 하지만, 즉시 반환하기 때문에 처리되어야 하는 일이 백그라운드에서 완료가 됨."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"모든 프로그래밍(멀티 쓰레드 프로그래밍 등) 스타일에서 사용될 수 있음."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"이벤트 기반의 프로그래밍 방식에서는 필수"},{"type":"span","value":"적임."}]},{"type":"paragraph","children":[{"type":"span","value":"➡️ 차단 방식의 시스템 콜(blocking call)이 전체 시스템을 멈출 수 있기 때문"}]}]}]}]}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"3️⃣ select()의 사용"}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"select()"},{"type":"span","value":"를 이용해 어떤 네트워크 디스크립터에 메시지가 도착했는지를 파악하는 경우를 살펴보자."}]},{"code":"#include <stdio.h>\n#include <stdlib.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <unistd.h>\n\nint main(void) {\n  // 여러 개의 소켓을 열고 설정(여기엔 나타나 있지 않음)\n  // 주 반복문\n  while () {\n    // fd_set를 모두 0으로 초기화함\n    fd_set readFDs;\n    FD_ZERO(&readFDs);\n    \n    // 이제 이 서버가 관심 있어 하는\n    // 디스크립터들의 bit를 설정\n    // (단순함을 위해서, min부터 max까지)\n    int fd;\n    for (fd = minFD; fd < maxFD; fd++)\n      FD_SET(fd, &readFDs);\n    \n    // 선택을 함\n    int rc = select(maxFD+, &readFDs, NULL, NULL, NULL);\n    \n    // FD_ISSET()를 사용하여 실제 데이터 사용 여부 검사\n    int fd;\n    for (fd = minFD; fd < maxFD; fd++)\n      if (FD_ISSET(fd, &readFDs))\n        processFD(fd);\n  }\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"이 코드는 다음과 같은 방식으로 동작한다."}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"초기화 후 서버는 무한 루프에 진입"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"루프 내에서 "},{"type":"span","marks":["code"],"value":"FD_ZERO()"},{"type":"span","value":" 매크로를 사용하여 파일 디스크립터들을 초기화"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"FD_SET()"},{"type":"span","value":"를 사용하여 "},{"type":"span","marks":["code"],"value":"minFD"},{"type":"span","value":"에서 "},{"type":"span","marks":["code"],"value":"maxFD"},{"type":"span","value":"까지의 파일 디스크립터 집합에 포함"}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"이 집합은 서버가 보고 있는 모든 네트워크 소켓 같은 것들을 나타낼 수 있음."}]}]}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"마지막으로 서버는 "},{"type":"span","marks":["code"],"value":"select()"},{"type":"span","value":"를 호출하여 데이터가 도착한 소켓이 있는지 검사"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"반복문 내의 FD_ISSET()를 사용하여 이벤트 서버는 어떤 디스크립터들이 준비된 데이터를 갖고 있는지를 알 수 있으며 도착하는 데이터를 처리할 수 있게 됨."}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"🛸 물론, 실제 서버는 이보다 더 복잡함.\n➡️ 디스크 작업이나 메시지를 보내는 시점, 그 외 세부 사항들을 결정하는 로직이 필요"}]},{"type":"paragraph","children":[{"type":"span","value":"💡 이벤트 기반의 서버 내에서는 블럭을 하지 말자"}]},{"type":"paragraph","children":[{"type":"span","value":"이벤트 기반 서버는 작업의 스케줄링을 정밀하게 제어할 수 있음.\n➡️ 정밀한 제어를 위해서는 "},{"type":"span","marks":["highlight"],"value":"호출자가 실행한 것을 차단할 수 있는 어떠한 호출도 있어서는 안 됨."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"4️⃣ 왜 간단한가? 락이 필요 없음"}]},{"type":"paragraph","children":[{"type":"span","value":"단일 CPU를 사용하는 이벤트 기반의 응용 프로그램에서는 병행 프로그램을 다룰 때 나타났던 문제들은 더 이상 보이지 않음.\n➡️ "},{"type":"span","marks":["highlight"],"value":"매 순간에 단 하나의 이벤트"},{"type":"span","value":"만 다루기 때문에 "},{"type":"span","marks":["highlight"],"value":"락을 획득하거나 해제해야 할 필요가 없기 때문"}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"이벤트 기반의 서버는 단 하나의 쓰레드"},{"type":"span","value":"만 갖고 있으므로 다른 쓰레드에 의해서 인터럽트에 걸릴 수가 없음.\n➡️ 쓰레드 프로그램에서 흔한 병행성 버그는 기본적인 이벤트 기반 접근법에서는 나타나지 않음."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"5️⃣ 문제: 블로킹 시스템 콜(Blocking System Call)"}]},{"type":"paragraph","children":[{"type":"span","value":"그렇다면 차단될 수도 있는 시스템 콜을 불러야 하는 이벤트가 있다면 어떻게 할까?"}]},{"type":"paragraph","children":[{"type":"span","value":"예를 들어 디스크에서 데이터를 읽어서 그 내용을 사용자에게 전달하는 요청을 생각해보자."}]},{"type":"paragraph","children":[{"type":"span","value":"서버는 다음과 같이 동작할 것이다."}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"이벤트 핸들러가 "},{"type":"span","marks":["code"],"value":"open()"},{"type":"span","value":" 시스템 콜을 사용하여 파일을 연다."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"read()"},{"type":"span","value":" 명령어를 사용하여 파일을 읽는다."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"파일을 읽어서 메모리에 탑재한 후 서버는 그 결과를 사용자에게 전달한다."}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"open()과 read() 모두 저장 장치에 I/O 요청을 보내야 한다면, 이 요청을 처리하기 위해서 오랜 시간이 필요하다."}]},{"type":"paragraph","children":[{"type":"span","value":"✅ 쓰레드 기반 서버는 이것이 문제가 되지 않는다.\n➡️ 한 쓰레드가 I/O를 대기하면 다른 쓰레드가 실행되며 서버가 계속 동작할 수 있기 때문\n➡️ I/O 처리와 다른 연산이 자연스럽게 "},{"type":"span","marks":["highlight"],"value":"겹쳐지는 현상(overlap)"},{"type":"span","value":"이 쓰레드 기반 프로그래밍의 장점"}]},{"type":"paragraph","children":[{"type":"span","value":"반면 이벤트 기반의 접근법에서는 쓰레드가 없고 단순히 이벤트 루프만 존재한다.\n➡️ 이벤트 핸들러가 블로킹 콜을 호출하면 서버 전체가 오직 그 일을 처리하기 위해 명령어가 끝날 때까지 다른 것들을 차단한다."}]},{"type":"paragraph","children":[{"type":"span","value":"이벤트 루프가 블록되면 시스템은 유휴 상태가 된다.\n➡️ ⚠️ 심각한 자원 낭비 발생"}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"6️⃣ 해법: 비동기 I/O"}]},{"type":"paragraph","children":[{"type":"span","value":"앞선 한계를 극복하기 위해 여러 현대의 운영체제들이 "},{"type":"span","marks":["highlight"],"value":"I/O 요청을 디스크로 내려보낼 수 있는 새로운 방법을 개발"},{"type":"span","value":"함.\n➡️ 일반적으로 "},{"type":"span","marks":["highlight"],"value":"비동기 I/O(asynchronous I/O)"},{"type":"span","value":"라고 부름."}]},{"type":"paragraph","children":[{"type":"span","value":"이 인터페이스를 다음을 가능하게 해주었다."}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"프로그램이 I/O 요청 시, I/O 요청이 끝나기 전에 제어권을 즉시 다시 호출자에게 돌려줌."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"여러 종류의 I/O들이 완료 되었는지 판단"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"예를 들어 Mac OS X가 제공하는 인터페이스를 살펴보자."}]},{"type":"paragraph","children":[{"type":"span","value":"이 API는 "},{"type":"span","marks":["code"],"value":"struct aiocb"},{"type":"span","value":" 또는 전문 용어로 "},{"type":"span","marks":["highlight"],"value":"AIO 제어 블럭(AIO control block)"},{"type":"span","value":"이라고 불리는 기본적인 구조를 사용하고 있다."}]},{"type":"paragraph","children":[{"type":"span","value":"간단화한 구조는 다음과 같다."}]},{"code":"struct aiocb {\n  int           aio_fildes;     /* File descriptor */\n  off_t         aio_offset;     /* File offset */\n  volatile void *aio_buf;       /* Location of buffer */\n  size_t        aio_nbytes;     /* Length of transfer */\n};","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"파일에 대한 비동기 읽기 요청을 위해서 응용 프로그램은 먼저 이 자료 구조에"}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"읽고자 하는 파일의 파일 디스크립터("},{"type":"span","marks":["code"],"value":"aio_fildes"},{"type":"span","value":")"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"파일 내에서 위치("},{"type":"span","marks":["code"],"value":"aio_offset"},{"type":"span","value":")"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"요청의 길이("},{"type":"span","marks":["code"],"value":"aio_nbytes"},{"type":"span","value":")"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"읽기 결과로 얻은 데이터를 저장할 대상 메모리의 위치("},{"type":"span","marks":["code"],"value":"aio_buf"},{"type":"span","value":")"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"와 같은 정보를 채워 넣어야 한다."}]},{"type":"paragraph","children":[{"type":"span","value":"이렇게 자료 구조에 정보를 채운 후 응용 프로그램은 읽으려는 파일에 비동기 호출을 보낸다.\n➡️ Mac OS X에서는 간단한 "},{"type":"span","marks":["highlight"],"value":"비동기 읽기(asynchronous read)"},{"type":"span","value":" API를 사용"}]},{"code":"int aio_read(struct aiocb *aiocbp);","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"✅ 이 명령어를 통해 I/O 호출을 성공하면, 즉시 리턴을 하며 응용 프로그램(이벤트 기반의 서버 류)은 하던 일을 계속 진행할 수 있음."}]},{"type":"paragraph","children":[{"type":"span","value":"🤔 그렇다면 I/O가 종료되었다는 것을 어떻게 알 수 있을까?"}]},{"type":"paragraph","children":[{"type":"span","value":"🤔 또한 "},{"type":"span","marks":["code"],"value":"aio_buf"},{"type":"span","value":"가 가리키는 버퍼에 요청했던 데이터가 있다는 것을 어떻게 알 수 있을까?"}]},{"type":"paragraph","children":[{"type":"span","value":"이를 위해서는 API 하나가 필요하다.\n➡️ Mac OS X에서는 이 API를 "},{"type":"span","marks":["code"],"value":"aio_error()"},{"type":"span","value":"라고 함."}]},{"code":"int aio_error(const struct aiocb *aiocbp);","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"이 시스템 콜은 "},{"type":"span","marks":["code"],"value":"aiocbp"},{"type":"span","value":"에 의해 참조된 요청이 완료되었는지를 검사한다."}]},{"type":"paragraph","children":[{"type":"span","value":"✅ 완료되었다면 성공했다고 0을 리턴한다."}]},{"type":"paragraph","children":[{"type":"span","value":"🚫 실패했다면 "},{"type":"span","marks":["code"],"value":"EINPROGRESS"},{"type":"span","value":"을 반환한다."}]},{"type":"paragraph","children":[{"type":"span","value":"💡 모든 대기 중인 비동기 I/O는 주기적으로 "},{"type":"span","marks":["code"],"value":"aio_error()"},{"type":"span","value":" 시스템 콜로 시스템에 "},{"type":"span","marks":["highlight"],"value":"폴링(poll)"},{"type":"span","value":"하여 해당 I/O가 완료되었는지 확인할 수 있다."}]},{"type":"paragraph","children":[{"type":"span","value":"🤔 만약 어떤 시점에 수십/수백 개의 I/O 요청하는 프로그램이 있다면 어떻게 해야할까?\n➡️ 이 문제의 해결을 위해서 어떤 시스템들은 "},{"type":"span","marks":["highlight"],"value":"인터럽트"},{"type":"span","value":" 기반의 접근법을 제공"}]},{"type":"paragraph","children":[{"type":"span","value":"✅ 유닉스의 시그널(signal)을 사용하여 비동기 I/O가 완료되었다는 것을 응용 프로그램에게 알려주기 때문에 시스템에 반복적으로 완료 여부를 확인할 필요가 없다."}]},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 비동기 I/O가 없는 시스템에서는 제대로 된 이벤트 기반의 접근법을 구현할 수 없다.\n➡️ 대신 네트워크 패킷을 처리하기 위해 이벤트를 사용하고 대기 중인 I/O들을 처리하기 위해 쓰레드 풀을 사용하는 하이브리드 기법 등이 고안됨."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"7️⃣ 또 다른 문제점: 상태 관리"}]},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 이벤트 기반 접근법의 또 다른 문제점\n➡️ 전통적인 쓰레드 기반 코드보다 일반적으로 더 작성하기 복잡함."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"8️⃣"}]},{"type":"paragraph","children":[{"type":"span","value":""}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"📚 참고 문헌"}]},{"type":"paragraph","children":[{"url":"https://pages.cs.wisc.edu/~remzi/OSTEP/threads-events.pdf","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"Operating Systems: Three Easy Pieces ― 33: Event-based Concurrency (Advanced)"}]}]},{"type":"paragraph","children":[{"url":"https://pages.cs.wisc.edu/~remzi/OSTEP/Korean/33_threads-events.pdf","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"운영체제 아주 쉬운 세 가지 이야기 ― 36: 이벤트 기반의 병행성(고급)"}]}]}]}}}}},"pageContext":{"id":"201762509","locale":"ko-KR"}},"staticQueryHashes":["1034768456","1118752904","2342916782","2757196681","3415878905","3879866231","4195094990"]}