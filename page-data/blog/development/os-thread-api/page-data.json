{"componentChunkName":"component---src-templates-article-jsx","path":"/blog/development/os-thread-api","result":{"data":{"datoCmsMiscTextString":{"locale":"ko-KR","updatedAtText":"업데이트됨","nextReadText":"관련있는 게시물"},"datoCmsBlogPost":{"locale":"ko-KR","originalId":"187067258","title":"[운영체제][OSTEP] 쓰레드 API","seo":{"seoTitle":"[운영체제][OSTEP] 쓰레드 API","seoDescription":"쓰레드 API를 이용하여 쓰레드를 생성하고 제어하는 방법에 대해 공부해봅니다","seoImage":{"seoImageUrl":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format"}},"subtitle":"쓰레드 API를 이용하여 쓰레드를 생성하고 제어하는 방법에 대해 공부해봅니다","coverImage":{"coverImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&w=860","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.25&w=860 215w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.5&w=860 430w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&w=860 860w","sizes":"(min-width: 860px) 860px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgLCgoLDhMVDhcNDh0VDxUSGhYdHSIVFhUaKysjGh0oHSEWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLCgUFEBAOEC8oIhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIAAwAGAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAFAQQGAP/EAB0QAAEEAgMAAAAAAAAAAAAAAAEAAgMEESEFEjL/xAAWAQADAAAAAAAAAAAAAAAAAAAAAQP/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwDD1KM1uPLjpIRUI4GZc4aRXH25hTOHqqbth7yDIVIiXI2IQzqCoREhL/RyuQH/2Q=="},"width":860,"height":430}},"meta":{"updatedAt":"2023-08-16T18:32:44.562+09:00","firstPublishedAt":"2023-08-15T21:31:54.745+09:00"},"categoryLink":{"title":"개발 공부","id":"4743072"},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorPictureData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 60px) 60px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgWEQ8LDhgYDhUNDhgNDw8NFxUdGBYfFhUaHysjGikoHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OHBANHDUcIig7NS81NS81MjUvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAFAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAABQYHAv/EAB4QAAICAgMBAQAAAAAAAAAAAAABAgMFBgQRQXEi/8QAFQEBAQAAAAAAAAAAAAAAAAAABAP/xAAaEQACAwEBAAAAAAAAAAAAAAAAAQIDEhMR/9oADAMBAAIRAxEAPwDT8/1LHSK/r67scevSfz99VXBkm/Cva/zKle/pCc/JoRXWsFujxvygcLI1pAXqQTmjONm2RzpceyCwmwxpsbbADWJdBFbeCfe2wXoAGpIL6z//2Q=="},"width":60,"height":60}}},"relatedPosts":[{"id":"186104748","meta":{"updatedAt":"2023-08-15T22:03:04.145+09:00"},"categoryLink":{"title":"개발 공부"},"coverImage":{"gatsbyImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.09&w=860 75w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.18&w=860 150w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860 300w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.7&w=860 600w","sizes":"(min-width: 300px) 300px, 100vw"}},"layout":"constrained","width":300,"height":120},"squaredImage":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.06&fit=crop&fp-x=0.5&fp-y=0.5&w=430 25w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.12&fit=crop&fp-x=0.5&fp-y=0.5&w=430 50w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430 100w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.47&fit=crop&fp-x=0.5&fp-y=0.5&w=430 200w","sizes":"(min-width: 100px) 100px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBhINEBAQCggUDg0IDgcHFh0JFhEYFxUZGCIVFhUaHysjGh0oHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OEg4REC8dFhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAGAMBIgACEQEDEQH/xAAaAAEBAAIDAAAAAAAAAAAAAAAABAUGAQID/8QAHRAAAgICAwEAAAAAAAAAAAAAAAIDBAEREhQVBf/EABYBAQEBAAAAAAAAAAAAAAAAAAADAf/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/ANASs2WLoaraMl1o0O241wSYlSHjgHM9hVAEFr6bKSemzAAeclpnAAH/2Q=="},"width":100,"height":100}},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.11&w=77 8w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 30px) 30px, 100vw"}},"layout":"constrained","width":30,"height":30}}},"subtitle":"병행성과 쓰레드에 대해 공부해봅니다.","title":"[운영체제][OSTEP] 병행성과 쓰레드"}],"structuredBody":{"blocks":[],"links":[],"value":{"schema":"dast","document":{"type":"root","children":[{"type":"heading","level":2,"children":[{"type":"span","value":"1️⃣ 쓰레드 생성"}]},{"type":"paragraph","children":[{"type":"span","value":"멀티 쓰레드 프로그램 작성 시, 가정 먼저할 일은 새로운 쓰레드의 생성이다."}]},{"type":"paragraph","children":[{"type":"span","value":"쓰레드 생성을 위해서는 해당 인터페이스가 존재해야 한다. "},{"url":"https://ko.wikipedia.org/wiki/POSIX","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"POSIX"}]},{"type":"span","value":"에서는 다음과 같다."}]},{"code":"#include <pthread.h>\n\nint pthread_create(       pthread_t *      thread,\n                    const pthread_attr_t * attr,\n                          void *           (*start_routine)(void*),\n                          void *           arg);\r","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"thread"},{"type":"span","value":", "},{"type":"span","marks":["code"],"value":"attr"},{"type":"span","value":", "},{"type":"span","marks":["code"],"value":"start_routine"},{"type":"span","value":", "},{"type":"span","marks":["code"],"value":"arg"},{"type":"span","value":"라는 4개의 인자가 있다. 이를 하나씩 살펴보자."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"첫 번째 인자: thread"}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"pthread_t"},{"type":"span","value":" 타입 구조체를 가리키는 포인터로, 이 구조가 "},{"type":"span","marks":["highlight"],"value":"쓰레드와 상호작용하는 데 사용"},{"type":"span","value":"되므로 쓰레드 초기화 시 "},{"type":"span","marks":["code"],"value":"pthread_create()"},{"type":"span","value":"에 이 구조체를 전달한다."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"두 번째 인자: attr"}]},{"type":"paragraph","children":[{"type":"span","value":"쓰레드의 속성을 지정하는 데 사용하며, "},{"type":"span","marks":["highlight"],"value":"스택의 크기와 쓰레드의 스케줄링 우선순위 같은 정보를 지정"},{"type":"span","value":"하기 위해서 사용될 수 있다."}]},{"type":"paragraph","children":[{"type":"span","value":"개별 속성은 "},{"type":"span","marks":["code"],"value":"pthread_attr_init()"},{"type":"span","value":" 함수를 호출하여 초기화한다."}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"대부분의 경우에 디폴트 값"},{"type":"span","value":"(간단히 "},{"type":"span","marks":["code"],"value":"NULL"},{"type":"span","value":")을 지정하면 충분하다."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"세 번째 인자: (*start_routine)(void*)"}]},{"type":"paragraph","children":[{"type":"span","value":"이 쓰레드가 "},{"type":"span","marks":["highlight"],"value":"실행할 함수(함수 포인터)"},{"type":"span","value":"를 나타낸다."}]},{"type":"paragraph","children":[{"type":"span","value":"이때 전달하는 함수는 "},{"type":"span","marks":["code"],"value":"void *"},{"type":"span","value":"타입의 인자 한개를 전달받고, "},{"type":"span","marks":["code"],"value":"void *"},{"type":"span","value":"타입의 값을 반환한다."}]},{"type":"paragraph","children":[{"type":"span","value":"void 포인터 타입 대신 "},{"type":"span","marks":["code"],"value":"integer"},{"type":"span","value":"를 인자로 사용하는 루틴인 경우"}]},{"code":"int pthread_create(.... // 처음 두 인자는 동일함\n                    void * (*start_routine)(int),\n                    void * arg);","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"void 포인터 타입을 인자로 받지만, "},{"type":"span","marks":["code"],"value":"interger"},{"type":"span","value":" 타입을 반환하는 경우"}]},{"code":"int pthread_create(.... // 처음 두 인자는 동일함\n                    int    (*start_routine)(void*),\n                    void * arg);","type":"code","language":"c"},{"type":"heading","level":3,"children":[{"type":"span","value":"네 번째 인자: arg"}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"실행할 함수에게 전달할 인자"},{"type":"span","value":"를 나타낸다."}]},{"type":"paragraph","children":[{"type":"span","value":"void 포인터 타입이 필요한 이유\n➡️ 어떤 데이터 타입도 인자로 전달할 수 있음.\n➡️ 반환 값의 타입으로 사용하면 쓰레드는 어떤 타입의 결과도 반환 가능"}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"2️⃣ 쓰레드 종료"}]},{"type":"paragraph","children":[{"type":"span","value":"다른 쓰레드의 작업 완료를 기다려야 하는 경우\n➡️ POSIX 쓰레드에서는 "},{"type":"span","marks":["code"],"value":"pthread_join()"},{"type":"span","value":"을 호출"}]},{"code":"int pthread_join(pthread_t thread, void **value_ptr);","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"이 루틴은 "},{"type":"span","marks":["code"],"value":"thread"},{"type":"span","value":", "},{"type":"span","marks":["code"],"value":"**value_ptr"},{"type":"span","value":" 두 개의 인자를 받는다. 이를 하나씩 살펴보자."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"첫 번째 인자: thread"}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"pthread_t"},{"type":"span","value":" 타입의 인자로, "},{"type":"span","marks":["highlight"],"value":"어떤 쓰레드를 기다려야 하는지 명시"},{"type":"span","value":"한다.\n➡️ 해당 변수는 쓰레드 생성 루틴("},{"type":"span","marks":["code"],"value":"pthread_create()"},{"type":"span","value":")에 의해 초기화된다."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"두 번째 인자: **value_ptr"}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"반환 값에 대한 포인터"},{"type":"span","value":"로, 루틴이 임의의 데이터 타입을 반환할 수 있으므로 void에 대한 포인터 타입으로 정의한다."}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"pthread_join()"},{"type":"span","value":" 루틴은 전달된 인자의 값을 변경하기 때문에 값에 대한 포인터를 전달해야 한다."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"예시"}]},{"code":"#include <stdio.h>\n#include <pthread.h>\n#include <assert.h>\n#include <stdlib.h>\n\ntypedef struct __myarg_t {\n  int a;\n  int b;\n} myarg_t;\n\ntypedef struct __myret_t {\n  int x;\n  int y;\n} myret_t;\n\nvoid *mythread(void *arg) {\n  myarg_t *m = (myarg_t *) arg;\n  printf(\"%d %d\\n\", m−>a, m−>b);\n  myret_t *r = malloc(sizeof(myret_t));\n  r−>x = 1;\n  r−>y = 2;\n  return (void *) r;\n}\n\nint main(int argc, char *argv[]) \n{\n  int rc;\n  pthread_t p;\n  myret_t *m;\n  \n  myarg_t args;\n  args.a = 10;\n  args.b = 20;\n  Pthread_create(&p, NULL, mythread, &args);\n  Pthread_join(p, (void **) &m);\n  printf(\"returned %d %d\\n\", m−>x, m−>y);\n  return 0;\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"위의 예시에서는 기존 루틴들의 예상치 못한 값의 반환을 방지하기 위해 래퍼 함수("},{"type":"span","marks":["code"],"value":"Pthread_create()"},{"type":"span","value":", "},{"type":"span","marks":["code"],"value":"Pthread_join()"},{"type":"span","value":")를 사용하고 있음에 유의하자."}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"mythread()"},{"type":"span","value":"는 반환 값으로 "},{"type":"span","marks":["code"],"value":"myret_t"},{"type":"span","value":" 타입을 사용하고 있는데, 쓰레드가 실행을 마치면 반환한 값을 "},{"type":"span","marks":["code"],"value":"pthread_join()"},{"type":"span","value":"함수에서 받아 접근할 수 있다."}]},{"type":"paragraph","children":[{"type":"span","value":"만약 인자가 없는 쓰레드를 생성할 때에서는 "},{"type":"span","marks":["code"],"value":"NULL"},{"type":"span","value":"을 전달하여 쓰레드를 생성할 수도 있고, 반환 값이 필요 없다면 "},{"type":"span","marks":["code"],"value":"pthread_join()"},{"type":"span","value":"에 "},{"type":"span","marks":["code"],"value":"NULL"},{"type":"span","value":"을 전달할 수도 있다."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"그 외 기타"}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"pthread_create()"},{"type":"span","value":"를 사용하여 쓰레드 생성 직후 "},{"type":"span","marks":["code"],"value":"pthread_join()"},{"type":"span","value":"을 호출?\n➡️ 굳이 쓰레드를 사용할 필요가 없다..\n➡️ "},{"type":"span","marks":["highlight"],"value":"프로시저 호출(procedure call)"},{"type":"span","value":"을 하면 된다."}]},{"type":"paragraph","children":[{"type":"span","value":"💡 모든 멀티 쓰레드 코드가 조인 루틴을 사용하지는 않는다.\n➡️ 예를 들어, 웹서버에서 여러 개의 작업자 쓰레드 생성 후 사용자 요청을 받아 수행하는 경우"}]},{"type":"paragraph","children":[{"type":"span","value":"💡 특정 작업을 병렬적으로 실행하기 위해 쓰레드를 생성하는 병렬 프로그램의 경우\n➡️ 종료/계산의 다음 단계 전 병렬 수행 작업이 모두 완료되었는지 확인하기 위해 "},{"type":"span","marks":["code"],"value":"join"},{"type":"span","value":"을 사용"}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"3️⃣ 락"}]},{"type":"paragraph","children":[{"type":"span","value":"POSIX 쓰레드 라이브러리는 "},{"type":"span","marks":["highlight"],"value":"락(lock)"},{"type":"span","value":"을 통해 "},{"type":"span","marks":["highlight"],"value":"임계 영역에 대한 상호 배제 기법"},{"type":"span","value":"을 가능하게 해주는 함수를 제공한다."}]},{"type":"paragraph","children":[{"type":"span","value":"이러한 목적을 위하여 사용되는 가장 기본적인 루틴은 다음과 같이 쌍으로 이루어져 있다."}]},{"code":"int pthread_mutex_lock(pthread_mutex_t *mutex);\nint pthread_mutex_unlock(pthread_mutex_t *mutex);","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"다음의 예시와 함께 이를 살펴보자."}]},{"code":"// 락의 초기화\n// 방법1: 디폴트 값으로 설정\npthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;\n// 방법2: 동적으로 초기화\npthread_mutex_t lock;\nint rc = pthread_mutex_init(&lock, NULL);\nassert(rc == 0); // \n\n// 락 획득\npthread_mutex_lock(&lock);\nx = x + 1; // 또는 다른 임계 영역의 코드를 사용할 수 있음.\npthread_mutex_unlock(&lock);","type":"code","language":"c"},{"type":"heading","level":3,"children":[{"type":"span","value":"락의 초기화"}]},{"type":"paragraph","children":[{"type":"span","value":"먼저 락을 초기화하는 방법을 살펴보자."}]},{"type":"paragraph","children":[{"type":"span","value":"세 번째 줄처럼 정적으로 설정하는 방법이 있고, 5-6줄 처럼 동적으로 실행 중에 초기화(주로 사용)하는 방법이 있다."}]},{"type":"paragraph","children":[{"type":"span","value":"동적으로 초기화하는 경우 "},{"type":"span","marks":["code"],"value":"pthread_mutex_init()"},{"type":"span","value":"에는 두 개의 인자가 필요하다."}]},{"type":"paragraph","children":[{"type":"span","value":"첫 번째 인자: 락 자체의 주소\n두 번째 인자: 선택 가능한 속성("},{"type":"span","marks":["code"],"value":"NULL"},{"type":"span","value":"을 전달하면 디폴트 값 사용)"}]},{"type":"paragraph","children":[{"type":"span","value":"동적으로 초기화하는 경우 락 사용이 끝난 후 "},{"type":"span","marks":["code"],"value":"pthread_mutex_destroy()"},{"type":"span","value":"를 호출해주어야 한다."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"락 획득"}]},{"type":"paragraph","children":[{"type":"span","value":"다음으로 "},{"type":"span","marks":["code"],"value":"pthread_mutex_lock()"},{"type":"span","value":"가 호출되었을 때의 동작을 살펴보자."}]},{"type":"paragraph","children":[{"type":"span","value":"[✅ 다른 어떤 쓰레드도 락을 가지고 있지 않은 경우]\n호출한 쓰레드가 락을 얻어 임계 영역에 진입"}]},{"type":"paragraph","children":[{"type":"span","value":"[ 🚧  다른 쓰레드가 락을 가지고 있는 경우]\n락을 얻을 때까지 호출에서 리턴하지 않음.\n➡️ 리턴은 락을 가지고 있던 쓰레드가 언락(unlock)을 호출하여 락을 양도했음을 의미\n➡️ 많은 쓰레드들이 락 획득 함수에서 대기 중일 수 있음.\n➡️ 락을 획득한 쓰레드만이 언락을 호출해야 함."}]},{"type":"paragraph","children":[{"type":"span","value":"바로 "},{"type":"span","marks":["code"],"value":"pthread_mutex_lock()"},{"type":"span","value":"를 호출하는 경우 에러 발생 시 여러 쓰레드가 동시에 임계 영역에 들어갈 수 있으므로 아래와 같은 래퍼 함수를 활용하여 루틴이 성공적으로 처리되었는지 확인하자."}]},{"code":"// 이 방법을 써서 코드를 깔끔하게 유지하되 오류가 없는지 확인해야 한다.\n// 프로그램이 오류에도 문제가 없었을 때에만 사용하자.\nvoid Pthread_mutex_lock(pthread_mutex_t *mutex) {\n  int rc = pthread_mutex_lock(mutex);\n  assert(rc == 0);\n}","type":"code","language":"c"},{"type":"heading","level":3,"children":[{"type":"span","value":"기타 락 관련 루틴"}]},{"code":"int pthread_mutex_trylock(pthread_mutex_t *mutex);\nint pthread_mutex_timedlock(pthread_mutex_t *mutex,\n                            struct timespec *abs_timeout);","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"위의 두 함수는 락을 획득하는 데 사용된다."}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"trylock"},{"type":"span","value":" 버전은 락이 이미 사용 중이라면 실패 코드를 반환한다."}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"timedlock"},{"type":"span","value":"은 타임아웃이 끝나거나 락을 획득하거나 두 조건 중 하나가 발생하면 리턴한다.\n➡️ 타임아웃을 0으로 설정하면 "},{"type":"span","marks":["code"],"value":"trylock"},{"type":"span","value":"과 동일하게 동작한다."}]},{"type":"paragraph","children":[{"type":"span","value":"이 두 함수는 사용하지 않는 것이 좋지만, 락 획득 루틴에서 무한정 대기하는 상황을 피하기 위해서 사용되기도 함."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"4️⃣ 컨디션 변수"}]},{"type":"paragraph","children":[{"type":"span","value":"POSIX 쓰레드 라이브러리의 경우 분명하게 제공하는 주요 구성 요소로 "},{"type":"span","marks":["highlight"],"value":"컨디션 변수(condition variable)"},{"type":"span","value":"가 있다."}]},{"type":"paragraph","children":[{"type":"span","value":"컨디션 변수는 "},{"type":"span","marks":["highlight"],"value":"한 쓰레드가 계속 진행하기 전 다른 쓰레드의 동작을 대기하는 상황"},{"type":"span","value":"에서 "},{"type":"span","marks":["highlight"],"value":"쓰레드 사이에서 시그널 교환 메커니즘이 필요할 때"},{"type":"span","value":" 유용하게 사용될 수 있다."}]},{"type":"paragraph","children":[{"type":"span","value":"두 개의 기본 루틴은 다음과 같다."}]},{"code":"int pthread_cond_wait(pthread_cond_t *cond, \n                      pthread_mutex_t *mutex);\nint pthread_cond_signal(pthread_cond_t *cond);","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"💡 컨디션 변수의 사용을 위해서는 "},{"type":"span","marks":["highlight"],"value":"해당 컨디션 변수와 연결된 락이 ⭐반드시 존재"},{"type":"span","value":"해야 한다."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"5️⃣"}]},{"type":"paragraph","children":[{"type":"span","value":""}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"📚 참고 문헌"}]},{"type":"paragraph","children":[{"url":"https://pages.cs.wisc.edu/~remzi/OSTEP/threads-api.pdf","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"Operating Systems: Three Easy Pieces ― 27: Interlude: Thread API"}]}]},{"type":"paragraph","children":[{"url":"https://pages.cs.wisc.edu/~remzi/OSTEP/Korean/27_threads-api.pdf","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"운영체제 아주 쉬운 세 가지 이야기 ― 30: 막간 : 쓰레드 API"}]}]}]}}}}},"pageContext":{"id":"187067258","locale":"ko-KR"}},"staticQueryHashes":["1034768456","1118752904","2342916782","2757196681","3415878905","3879866231","4195094990"]}