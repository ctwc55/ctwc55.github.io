{"componentChunkName":"component---src-templates-article-jsx","path":"/blog/development/os-thread-api","result":{"data":{"datoCmsMiscTextString":{"locale":"ko-KR","updatedAtText":"업데이트됨","nextReadText":"관련있는 게시물"},"datoCmsBlogPost":{"locale":"ko-KR","originalId":"187067258","title":"[운영체제][OSTEP] 쓰레드 API","seo":{"seoTitle":"[운영체제][OSTEP] 쓰레드 API","seoDescription":"쓰레드 API를 이용하여 쓰레드를 생성하고 제어하는 방법에 대해 공부해봅니다","seoImage":{"seoImageUrl":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format"}},"subtitle":"쓰레드 API를 이용하여 쓰레드를 생성하고 제어하는 방법에 대해 공부해봅니다","coverImage":{"coverImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&w=860","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.25&w=860 215w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.5&w=860 430w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&w=860 860w","sizes":"(min-width: 860px) 860px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgLCgoLDhMVDhcNDh0VDxUSGhYdHSIVFhUaKysjGh0oHSEWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLCgUFEBAOEC8oIhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIAAwAGAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAFAQQGAP/EAB0QAAEEAgMAAAAAAAAAAAAAAAEAAgMEESEFEjL/xAAWAQADAAAAAAAAAAAAAAAAAAAAAQP/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwDD1KM1uPLjpIRUI4GZc4aRXH25hTOHqqbth7yDIVIiXI2IQzqCoREhL/RyuQH/2Q=="},"width":860,"height":430}},"meta":{"updatedAt":"2023-08-17T00:33:37.291+09:00","firstPublishedAt":"2023-08-15T21:31:54.745+09:00"},"categoryLink":{"title":"개발 공부","id":"4743072"},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorPictureData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 60px) 60px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgWEQ8LDhgYDhUNDhgNDw8NFxUdGBYfFhUaHysjGikoHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OHBANHDUcIig7NS81NS81MjUvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAFAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAABQYHAv/EAB4QAAICAgMBAQAAAAAAAAAAAAABAgMFBgQRQXEi/8QAFQEBAQAAAAAAAAAAAAAAAAAABAP/xAAaEQACAwEBAAAAAAAAAAAAAAAAAQIDEhMR/9oADAMBAAIRAxEAPwDT8/1LHSK/r67scevSfz99VXBkm/Cva/zKle/pCc/JoRXWsFujxvygcLI1pAXqQTmjONm2RzpceyCwmwxpsbbADWJdBFbeCfe2wXoAGpIL6z//2Q=="},"width":60,"height":60}}},"relatedPosts":[{"id":"186104748","meta":{"updatedAt":"2023-08-15T22:03:04.145+09:00"},"categoryLink":{"title":"개발 공부"},"coverImage":{"gatsbyImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.09&w=860 75w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.18&w=860 150w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860 300w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.7&w=860 600w","sizes":"(min-width: 300px) 300px, 100vw"}},"layout":"constrained","width":300,"height":120},"squaredImage":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.06&fit=crop&fp-x=0.5&fp-y=0.5&w=430 25w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.12&fit=crop&fp-x=0.5&fp-y=0.5&w=430 50w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430 100w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.47&fit=crop&fp-x=0.5&fp-y=0.5&w=430 200w","sizes":"(min-width: 100px) 100px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBhINEBAQCggUDg0IDgcHFh0JFhEYFxUZGCIVFhUaHysjGh0oHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OEg4REC8dFhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAGAMBIgACEQEDEQH/xAAaAAEBAAIDAAAAAAAAAAAAAAAABAUGAQID/8QAHRAAAgICAwEAAAAAAAAAAAAAAAIDBAEREhQVBf/EABYBAQEBAAAAAAAAAAAAAAAAAAADAf/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/ANASs2WLoaraMl1o0O241wSYlSHjgHM9hVAEFr6bKSemzAAeclpnAAH/2Q=="},"width":100,"height":100}},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.11&w=77 8w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 30px) 30px, 100vw"}},"layout":"constrained","width":30,"height":30}}},"subtitle":"병행성과 쓰레드에 대해 공부해봅니다.","title":"[운영체제][OSTEP] 병행성과 쓰레드"},{"id":"187813035","meta":{"updatedAt":"2023-08-17T16:09:01.232+09:00"},"categoryLink":{"title":"개발 공부"},"coverImage":{"gatsbyImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.09&w=860 75w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.18&w=860 150w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860 300w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.7&w=860 600w","sizes":"(min-width: 300px) 300px, 100vw"}},"layout":"constrained","width":300,"height":120},"squaredImage":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.06&fit=crop&fp-x=0.5&fp-y=0.5&w=430 25w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.12&fit=crop&fp-x=0.5&fp-y=0.5&w=430 50w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430 100w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.47&fit=crop&fp-x=0.5&fp-y=0.5&w=430 200w","sizes":"(min-width: 100px) 100px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBhINEBAQCggUDg0IDgcHFh0JFhEYFxUZGCIVFhUaHysjGh0oHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OEg4REC8dFhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAGAMBIgACEQEDEQH/xAAaAAEBAAIDAAAAAAAAAAAAAAAABAUGAQID/8QAHRAAAgICAwEAAAAAAAAAAAAAAAIDBAEREhQVBf/EABYBAQEBAAAAAAAAAAAAAAAAAAADAf/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/ANASs2WLoaraMl1o0O241wSYlSHjgHM9hVAEFr6bKSemzAAeclpnAAH/2Q=="},"width":100,"height":100}},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.11&w=77 8w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 30px) 30px, 100vw"}},"layout":"constrained","width":30,"height":30}}},"subtitle":"임계 영역에서의 원자적인 실행을 위한 락에 대해 공부해봅니다.","title":"[운영체제][OSTEP] 락"}],"structuredBody":{"blocks":[],"links":[],"value":{"schema":"dast","document":{"type":"root","children":[{"type":"heading","level":2,"children":[{"type":"span","value":"1️⃣ 쓰레드 생성"}]},{"type":"paragraph","children":[{"type":"span","value":"멀티 쓰레드 프로그램 작성 시, 가정 먼저할 일은 새로운 쓰레드의 생성이다."}]},{"type":"paragraph","children":[{"type":"span","value":"쓰레드 생성을 위해서는 해당 인터페이스가 존재해야 한다. "},{"url":"https://ko.wikipedia.org/wiki/POSIX","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"POSIX"}]},{"type":"span","value":"에서는 다음과 같다."}]},{"code":"#include <pthread.h>\n\nint pthread_create(       pthread_t *      thread,\n                    const pthread_attr_t * attr,\n                          void *           (*start_routine)(void*),\n                          void *           arg);\r","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"thread"},{"type":"span","value":", "},{"type":"span","marks":["code"],"value":"attr"},{"type":"span","value":", "},{"type":"span","marks":["code"],"value":"start_routine"},{"type":"span","value":", "},{"type":"span","marks":["code"],"value":"arg"},{"type":"span","value":"라는 4개의 인자가 있다. 이를 하나씩 살펴보자."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"첫 번째 인자: thread"}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"pthread_t"},{"type":"span","value":" 타입 구조체를 가리키는 포인터로, 이 구조가 "},{"type":"span","marks":["highlight"],"value":"쓰레드와 상호작용하는 데 사용"},{"type":"span","value":"되므로 쓰레드 초기화 시 "},{"type":"span","marks":["code"],"value":"pthread_create()"},{"type":"span","value":"에 이 구조체를 전달한다."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"두 번째 인자: attr"}]},{"type":"paragraph","children":[{"type":"span","value":"쓰레드의 속성을 지정하는 데 사용하며, "},{"type":"span","marks":["highlight"],"value":"스택의 크기와 쓰레드의 스케줄링 우선순위 같은 정보를 지정"},{"type":"span","value":"하기 위해서 사용될 수 있다."}]},{"type":"paragraph","children":[{"type":"span","value":"개별 속성은 "},{"type":"span","marks":["code"],"value":"pthread_attr_init()"},{"type":"span","value":" 함수를 호출하여 초기화한다."}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"대부분의 경우에 디폴트 값"},{"type":"span","value":"(간단히 "},{"type":"span","marks":["code"],"value":"NULL"},{"type":"span","value":")을 지정하면 충분하다."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"세 번째 인자: (*start_routine)(void*)"}]},{"type":"paragraph","children":[{"type":"span","value":"이 쓰레드가 "},{"type":"span","marks":["highlight"],"value":"실행할 함수(함수 포인터)"},{"type":"span","value":"를 나타낸다."}]},{"type":"paragraph","children":[{"type":"span","value":"이때 전달하는 함수는 "},{"type":"span","marks":["code"],"value":"void *"},{"type":"span","value":"타입의 인자 한개를 전달받고, "},{"type":"span","marks":["code"],"value":"void *"},{"type":"span","value":"타입의 값을 반환한다."}]},{"type":"paragraph","children":[{"type":"span","value":"void 포인터 타입 대신 "},{"type":"span","marks":["code"],"value":"integer"},{"type":"span","value":"를 인자로 사용하는 루틴인 경우"}]},{"code":"int pthread_create(.... // 처음 두 인자는 동일함\n                    void * (*start_routine)(int),\n                    void * arg);","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"void 포인터 타입을 인자로 받지만, "},{"type":"span","marks":["code"],"value":"interger"},{"type":"span","value":" 타입을 반환하는 경우"}]},{"code":"int pthread_create(.... // 처음 두 인자는 동일함\n                    int    (*start_routine)(void*),\n                    void * arg);","type":"code","language":"c"},{"type":"heading","level":3,"children":[{"type":"span","value":"네 번째 인자: arg"}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"실행할 함수에게 전달할 인자"},{"type":"span","value":"를 나타낸다."}]},{"type":"paragraph","children":[{"type":"span","value":"void 포인터 타입이 필요한 이유\n➡️ 어떤 데이터 타입도 인자로 전달할 수 있음.\n➡️ 반환 값의 타입으로 사용하면 쓰레드는 어떤 타입의 결과도 반환 가능"}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"2️⃣ 쓰레드 종료"}]},{"type":"paragraph","children":[{"type":"span","value":"다른 쓰레드의 작업 완료를 기다려야 하는 경우\n➡️ POSIX 쓰레드에서는 "},{"type":"span","marks":["code"],"value":"pthread_join()"},{"type":"span","value":"을 호출"}]},{"code":"int pthread_join(pthread_t thread, void **value_ptr);","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"이 루틴은 "},{"type":"span","marks":["code"],"value":"thread"},{"type":"span","value":", "},{"type":"span","marks":["code"],"value":"**value_ptr"},{"type":"span","value":" 두 개의 인자를 받는다. 이를 하나씩 살펴보자."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"첫 번째 인자: thread"}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"pthread_t"},{"type":"span","value":" 타입의 인자로, "},{"type":"span","marks":["highlight"],"value":"어떤 쓰레드를 기다려야 하는지 명시"},{"type":"span","value":"한다.\n➡️ 해당 변수는 쓰레드 생성 루틴("},{"type":"span","marks":["code"],"value":"pthread_create()"},{"type":"span","value":")에 의해 초기화된다."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"두 번째 인자: **value_ptr"}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"반환 값에 대한 포인터"},{"type":"span","value":"로, 루틴이 임의의 데이터 타입을 반환할 수 있으므로 void에 대한 포인터 타입으로 정의한다."}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"pthread_join()"},{"type":"span","value":" 루틴은 전달된 인자의 값을 변경하기 때문에 값에 대한 포인터를 전달해야 한다."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"예시"}]},{"code":"#include <stdio.h>\n#include <pthread.h>\n#include <assert.h>\n#include <stdlib.h>\n\ntypedef struct __myarg_t {\n  int a;\n  int b;\n} myarg_t;\n\ntypedef struct __myret_t {\n  int x;\n  int y;\n} myret_t;\n\nvoid *mythread(void *arg) {\n  myarg_t *m = (myarg_t *) arg;\n  printf(\"%d %d\\n\", m−>a, m−>b);\n  myret_t *r = malloc(sizeof(myret_t));\n  r−>x = 1;\n  r−>y = 2;\n  return (void *) r;\n}\n\nint main(int argc, char *argv[]) \n{\n  int rc;\n  pthread_t p;\n  myret_t *m;\n  \n  myarg_t args;\n  args.a = 10;\n  args.b = 20;\n  Pthread_create(&p, NULL, mythread, &args);\n  Pthread_join(p, (void **) &m);\n  printf(\"returned %d %d\\n\", m−>x, m−>y);\n  return 0;\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 위의 예시에서는 기존 루틴들의 예상치 못한 값의 반환을 방지하기 위해 래퍼 함수("},{"type":"span","marks":["code"],"value":"Pthread_create()"},{"type":"span","value":", "},{"type":"span","marks":["code"],"value":"Pthread_join()"},{"type":"span","value":")를 사용하고 있음에 유의하자."}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"mythread()"},{"type":"span","value":"는 반환 값으로 "},{"type":"span","marks":["code"],"value":"myret_t"},{"type":"span","value":" 타입을 사용하고 있는데, 쓰레드가 실행을 마치면 반환한 값을 "},{"type":"span","marks":["code"],"value":"pthread_join()"},{"type":"span","value":"함수에서 받아 접근할 수 있다."}]},{"type":"paragraph","children":[{"type":"span","value":"만약 인자가 없는 쓰레드를 생성할 때에서는 "},{"type":"span","marks":["code"],"value":"NULL"},{"type":"span","value":"을 전달하여 쓰레드를 생성할 수도 있고, 반환 값이 필요 없다면 "},{"type":"span","marks":["code"],"value":"pthread_join()"},{"type":"span","value":"에 "},{"type":"span","marks":["code"],"value":"NULL"},{"type":"span","value":"을 전달할 수도 있다."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"그 외 기타"}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"pthread_create()"},{"type":"span","value":"를 사용하여 쓰레드 생성 직후 "},{"type":"span","marks":["code"],"value":"pthread_join()"},{"type":"span","value":"을 호출?\n➡️ 굳이 쓰레드를 사용할 필요가 없다..\n➡️ "},{"type":"span","marks":["highlight"],"value":"프로시저 호출(procedure call)"},{"type":"span","value":"을 하면 된다."}]},{"type":"paragraph","children":[{"type":"span","value":"💡 모든 멀티 쓰레드 코드가 조인 루틴을 사용하지는 않는다.\n➡️ 예를 들어, 웹서버에서 여러 개의 작업자 쓰레드 생성 후 사용자 요청을 받아 수행하는 경우"}]},{"type":"paragraph","children":[{"type":"span","value":"💡 특정 작업을 병렬적으로 실행하기 위해 쓰레드를 생성하는 병렬 프로그램의 경우\n➡️ 종료/계산의 다음 단계 전 병렬 수행 작업이 모두 완료되었는지 확인하기 위해 "},{"type":"span","marks":["code"],"value":"join"},{"type":"span","value":"을 사용"}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"3️⃣ 락"}]},{"type":"paragraph","children":[{"type":"span","value":"POSIX 쓰레드 라이브러리는 "},{"type":"span","marks":["highlight"],"value":"락(lock)"},{"type":"span","value":"을 통해 "},{"type":"span","marks":["highlight"],"value":"임계 영역에 대한 상호 배제 기법"},{"type":"span","value":"을 가능하게 해주는 함수를 제공한다."}]},{"type":"paragraph","children":[{"type":"span","value":"이러한 목적을 위하여 사용되는 가장 기본적인 루틴은 다음과 같이 쌍으로 이루어져 있다."}]},{"code":"int pthread_mutex_lock(pthread_mutex_t *mutex);\nint pthread_mutex_unlock(pthread_mutex_t *mutex);","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"다음의 예시와 함께 이를 살펴보자."}]},{"code":"// 락의 초기화\n// 방법1: 디폴트 값으로 설정\npthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;\n// 방법2: 동적으로 초기화\npthread_mutex_t lock;\nint rc = pthread_mutex_init(&lock, NULL);\nassert(rc == 0); // 성공했는지 꼭 확인해야 한다!\n\n// 락 획득\npthread_mutex_lock(&lock);\nx = x + 1; // 또는 다른 임계 영역의 코드를 사용할 수 있음.\npthread_mutex_unlock(&lock);","type":"code","language":"c"},{"type":"heading","level":3,"children":[{"type":"span","value":"락의 초기화"}]},{"type":"paragraph","children":[{"type":"span","value":"먼저 락을 초기화하는 방법을 살펴보자."}]},{"type":"paragraph","children":[{"type":"span","value":"세 번째 줄처럼 정적으로 설정하는 방법이 있고, 5-6줄 처럼 동적으로 실행 중에 초기화(주로 사용)하는 방법이 있다."}]},{"type":"paragraph","children":[{"type":"span","value":"동적으로 초기화하는 경우 "},{"type":"span","marks":["code"],"value":"pthread_mutex_init()"},{"type":"span","value":"에는 두 개의 인자가 필요하다."}]},{"type":"paragraph","children":[{"type":"span","value":"첫 번째 인자: 락 자체의 주소\n두 번째 인자: 선택 가능한 속성("},{"type":"span","marks":["code"],"value":"NULL"},{"type":"span","value":"을 전달하면 디폴트 값 사용)"}]},{"type":"paragraph","children":[{"type":"span","value":"동적으로 초기화하는 경우 락 사용이 끝난 후 "},{"type":"span","marks":["code"],"value":"pthread_mutex_destroy()"},{"type":"span","value":"를 호출해주어야 한다."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"락 획득"}]},{"type":"paragraph","children":[{"type":"span","value":"다음으로 "},{"type":"span","marks":["code"],"value":"pthread_mutex_lock()"},{"type":"span","value":"가 호출되었을 때의 동작을 살펴보자."}]},{"type":"paragraph","children":[{"type":"span","value":"[✅ 다른 어떤 쓰레드도 락을 가지고 있지 않은 경우]\n호출한 쓰레드가 락을 얻어 임계 영역에 진입"}]},{"type":"paragraph","children":[{"type":"span","value":"[ 🚧  다른 쓰레드가 락을 가지고 있는 경우]\n락을 얻을 때까지 호출에서 리턴하지 않음.\n➡️ 리턴은 락을 가지고 있던 쓰레드가 언락(unlock)을 호출하여 락을 양도했음을 의미\n➡️ 많은 쓰레드들이 락 획득 함수에서 대기 중일 수 있음.\n➡️ 락을 획득한 쓰레드만이 언락을 호출해야 함."}]},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 바로 "},{"type":"span","marks":["code"],"value":"pthread_mutex_lock()"},{"type":"span","value":"를 호출하는 경우 에러 발생 시 여러 쓰레드가 동시에 임계 영역에 들어갈 수 있으므로 아래와 같은 래퍼 함수를 활용하여 루틴이 성공적으로 처리되었는지 확인하자."}]},{"code":"// 이 방법을 써서 코드를 깔끔하게 유지하되 오류가 없는지 확인해야 한다.\n// 프로그램이 오류에도 문제가 없었을 때에만 사용하자.\nvoid Pthread_mutex_lock(pthread_mutex_t *mutex) {\n  int rc = pthread_mutex_lock(mutex);\n  assert(rc == 0);\n}","type":"code","language":"c"},{"type":"heading","level":3,"children":[{"type":"span","value":"기타 락 관련 루틴"}]},{"code":"int pthread_mutex_trylock(pthread_mutex_t *mutex);\nint pthread_mutex_timedlock(pthread_mutex_t *mutex,\n                            struct timespec *abs_timeout);","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"위의 두 함수는 락을 획득하는 데 사용된다."}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"trylock"},{"type":"span","value":" 버전은 락이 이미 사용 중이라면 실패 코드를 반환한다."}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"timedlock"},{"type":"span","value":"은 타임아웃이 끝나거나 락을 획득하거나 두 조건 중 하나가 발생하면 리턴한다.\n➡️ 타임아웃을 0으로 설정하면 "},{"type":"span","marks":["code"],"value":"trylock"},{"type":"span","value":"과 동일하게 동작한다."}]},{"type":"paragraph","children":[{"type":"span","value":"이 두 함수는 사용하지 않는 것이 좋지만, 락 획득 루틴에서 무한정 대기하는 상황을 피하기 위해서 사용되기도 함."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"4️⃣ 컨디션 변수"}]},{"type":"paragraph","children":[{"type":"span","value":"POSIX 쓰레드 라이브러리의 경우 분명하게 제공하는 주요 구성 요소로 "},{"type":"span","marks":["highlight"],"value":"컨디션 변수(condition variable)"},{"type":"span","value":"가 있다."}]},{"type":"paragraph","children":[{"type":"span","value":"컨디션 변수는 "},{"type":"span","marks":["highlight"],"value":"한 쓰레드가 계속 진행하기 전 다른 쓰레드의 동작을 대기하는 상황"},{"type":"span","value":"에서 "},{"type":"span","marks":["highlight"],"value":"쓰레드 사이에서 시그널 교환 메커니즘이 필요할 때"},{"type":"span","value":" 유용하게 사용될 수 있다."}]},{"type":"paragraph","children":[{"type":"span","value":"두 개의 기본 루틴은 다음과 같다."}]},{"code":"int pthread_cond_wait(pthread_cond_t *cond, \n                      pthread_mutex_t *mutex);\nint pthread_cond_signal(pthread_cond_t *cond);","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"💡 컨디션 변수의 사용을 위해서는 "},{"type":"span","marks":["highlight"],"value":"해당 컨디션 변수와 연결된 락이 ⭐반드시 존재"},{"type":"span","value":"해야 한다."}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"pthread_cond_wait()"},{"type":"span","value":"는 호출 쓰레드를 sleep 상태로 만들고 다른 쓰레드로부터의 시그널을 대기한다.\n➡️ 📡 현재 sleep 중인 쓰레드가 관심 있는 무언가가 변경되면 시그널을 보낸다."}]},{"type":"paragraph","children":[{"type":"span","value":"다음에서 전형적인 용례를 살펴보자."}]},{"code":"pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t cond = PTHREAD_COND_INITIALIZER;\n\nPthread_mutex_lock(&lock);\nwhile (ready == 0)\n  Pthread_cond_wait(&cond, &lock);\nPthread_mutex_unlock(&lock);","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"위의 코드에서는 연관된 락과 컨디션 변수를 초기화한 후 "},{"type":"span","marks":["code"],"value":"ready"},{"type":"span","value":" 변수가 0인지 검사한다.\n➡️ "},{"type":"span","marks":["code"],"value":"ready"},{"type":"span","value":" 변수 값이 0이라면, 대기 루틴을 호출하고 sleep 상태가 된다.(다른 쓰레드를 기다림.)"}]},{"type":"paragraph","children":[{"type":"span","value":"이때, 다른 쓰레드에서 sleep 상태인 쓰레드를 깨우는 코드는 다음과 같다."}]},{"code":"Pthread_mutex_lock(&lock);\nready = 1;\nPthread_cond_signal(&cond);\nPthread_mutex_unlock(&lock);","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 위 코드에서 유의할 점을 살펴보자."}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"시그널을 보내고 전역 변수 "},{"type":"span","marks":["code"],"value":"ready"},{"type":"span","value":"를 수정할 때 반드시 락을 가지고 있어야 한다."}]},{"type":"paragraph","children":[{"type":"span","value":"➡️ "},{"type":"span","marks":["highlight"],"value":"경쟁 조건이 발생하지 않는다는 것을 보장"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["underline"],"value":"시그널 대기 함수"},{"type":"span","value":"에서는 락을 두 번째 인자로 받고 있지만, "},{"type":"span","marks":["underline"],"value":"시그널 보내기 함수"},{"type":"span","value":"에서는 조건만을 인자로 받는다."}]},{"type":"paragraph","children":[{"type":"span","value":"➡️ 시그널 대기 함수는 호출 쓰레드를 sleep 시키는 것 외에 락도 "},{"type":"span","marks":["highlight"],"value":"반납(release)"},{"type":"span","value":"해야 하기 때문"}]},{"type":"paragraph","children":[{"type":"span","value":"➡️ 락을 반납하지 않으면 깨울 쓰레드가 깨우기 위해 락을 얻을 수 없음.."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"pthread_cond_wait()"},{"type":"span","value":"는 깨어나서 리턴하기 직전에 락을 다시 획득한다."}]},{"type":"paragraph","children":[{"type":"span","value":"➡️ 이 함수를 실행한 쓰레드들은 처음 "},{"type":"span","marks":["highlight"],"value":"락 획득 시부터 마지막에 반납 시까지 항상 락을 획득한 상태로 실행된다는 것을 보장"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"대기하는 쓰레드가 조건을 검사할 때 "},{"type":"span","marks":["code"],"value":"if"},{"type":"span","value":" 문을 사용하는 대신 "},{"type":"span","marks":["code"],"value":"while"},{"type":"span","value":" 문을 사용한다."}]},{"type":"paragraph","children":[{"type":"span","value":"➡️ 만약 "},{"type":"span","marks":["code"],"value":"pthread"},{"type":"span","value":" 라이브러리에서 "},{"type":"span","marks":["underline"],"value":"변수를 제대로 갱신하지 않고 쓰레드를 깨우는 경우"},{"type":"span","value":" 재검사가 필요"}]},{"type":"paragraph","children":[{"type":"span","value":"➡️ 시그널의 도착을 변경 사실을 알리는 것이 아니라, 변경된 것 같으니 검사해보라는 정도의 힌트로 간주하는 것이 더 안전"}]}]}]},{"type":"heading","level":3,"children":[{"type":"span","value":"컨디션 변수 대신 간단한 플래그를 사용하면 안되나? ➡️ 🚫"}]},{"code":"// 대기 코드\nwhile (ready == 0); // 회전\n\n---------------------------\n\n// 시그널 보내기 코드\nready = 1;","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"🚫 위와 같이 바꾸어 구현해도 좋을 것 같지만 다음과 같은 이유로 "},{"type":"span","marks":["underline"],"value":"절대로 하면 안된다."}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"조건 검사를 위한 오랜 시간 반복문 실행 = CPU 사이클의 낭비 초래"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"오류가 발생하기 쉬움."}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"관련된 연구에 따르면 임시방편적인 동기화 방법을 사용한 경우, 대략 절반 정도가 버그를 유발함."}]}]}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"따라서 꼭 컨디션 변수를 사용하도록 하자."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"5️⃣ 컴파일과 실행"}]},{"type":"paragraph","children":[{"type":"span","value":"앞선 예시 코드들을 컴파일하기 위해서는 "},{"type":"span","marks":["code"],"value":"pthread.h"},{"type":"span","value":" 헤더를 포함시켜야 한다."}]},{"type":"paragraph","children":[{"type":"span","value":"다음과 같이 -pthread 플래그를 명령어 링크 옵션 부분에 추가하여 사용함으로써 "},{"type":"span","marks":["code"],"value":"pthread"},{"type":"span","value":" 라이브러리와 링크할 수 있도록 명시해야 한다."}]},{"code":"prompt> gcc −o main main.c −Wall −pthread","type":"code"},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"main.c"},{"type":"span","value":"가 "},{"type":"span","marks":["code"],"value":"pthread"},{"type":"span","value":" 헤더를 포함하고 있다면 병행 프로그램이 성공적으로 컴파일된다."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"✅ 쓰레드 API의 지침"}]},{"type":"paragraph","children":[{"type":"span","value":"마지막으로 POSIX 또는 다른 쓰레드 라이브러리를 사용하여 멀티 쓰레드 프로그램을 작성하는 데 있어 기억해야할 중요한 사항들을 짚어보자."}]},{"type":"paragraph","children":[{"type":"span","value":"[✒️ "},{"type":"span","marks":["highlight"],"value":"간단하게 작성하라."},{"type":"span","value":"]\n락을 획득하거나 쓰레드끼리 시그널을 주고 받는 코드는 가능한 간단해야 한다.\n➡️ 쓰레드 간의 복잡한 상호 동작은 버그를 만든다."}]},{"type":"paragraph","children":[{"type":"span","value":"[🏸"},{"type":"span","marks":["highlight"],"value":"쓰레드 간의 상호 동작을 최소로 하라."},{"type":"span","value":"]\n쓰레드끼리 상호 작용하는 방법의 개수를 최소로 해야 한다."}]},{"type":"paragraph","children":[{"type":"span","value":"[🧹 "},{"type":"span","marks":["highlight"],"value":"락과 컨디션 변수를 초기화하라."},{"type":"span","value":"]\n초기화하지 않고 사용하면 어떤 때는 동작하지만 때로는 매우 이상한 방식으로 실패할 수 있다."}]},{"type":"paragraph","children":[{"type":"span","value":"[🔄 "},{"type":"span","marks":["highlight"],"value":"반환 코드를 확인하라."},{"type":"span","value":"]\n반환 코드를 확인하지 않을 경우 기이하고 이해하기 어려운 동작을 초래할 수 있다."}]},{"type":"paragraph","children":[{"type":"span","value":"[🧨 "},{"type":"span","marks":["highlight"],"value":"쓰레드 간에 인자를 전달하고 반환받을 때는 조심해야 한다."},{"type":"span","value":"]\n특히, 스택에 할당된 변수에 대한 참조를 전달할 경우 뭔가 잘못하고 있을 확률이 높다."}]},{"type":"paragraph","children":[{"type":"span","value":"[🗄️ "},{"type":"span","marks":["highlight"],"value":"각 쓰레드는 개별적인 스택을 가진다."},{"type":"span","value":"]\n실행 중인 어떤 함수 내에 지역적으로 할당된 변수가 있다면 그 변수는 본질적으로 쓰레드 전용으로 사용되어야 하고 다른 쓰레드가 (쉽게) 접근할 수 없어야 한다.\n➡️ 쓰레드 간에 데이터를 공유하려면 힙에 할당하거나, 전역적으로 접근이 가능한 위치에 있어야 한다."}]},{"type":"paragraph","children":[{"type":"span","value":"[☄️ "},{"type":"span","marks":["highlight"],"value":"쓰레드 간에 시그널을 보내기 위해 항상 컨디션 변수를 사용하라."},{"type":"span","value":"]\n간단한 플래그 변수를 사용하지 않도록 한다."}]},{"type":"paragraph","children":[{"type":"span","value":"[📖 "},{"type":"span","marks":["highlight"],"value":"메뉴얼을 사용하라."},{"type":"span","value":"]\n특히 Linux에 "},{"type":"span","marks":["code"],"value":"pthread"},{"type":"span","value":"에 대한 설명에는 많은 정보가 있다."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"📚 참고 문헌"}]},{"type":"paragraph","children":[{"url":"https://pages.cs.wisc.edu/~remzi/OSTEP/threads-api.pdf","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"Operating Systems: Three Easy Pieces ― 27: Interlude: Thread API"}]}]},{"type":"paragraph","children":[{"url":"https://pages.cs.wisc.edu/~remzi/OSTEP/Korean/27_threads-api.pdf","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"운영체제 아주 쉬운 세 가지 이야기 ― 30: 막간: 쓰레드 API"}]}]}]}}}}},"pageContext":{"id":"187067258","locale":"ko-KR"}},"staticQueryHashes":["1034768456","1118752904","2342916782","2757196681","3415878905","3879866231","4195094990"]}