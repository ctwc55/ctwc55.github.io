{"componentChunkName":"component---src-templates-article-jsx","path":"/blog/development/os-concurrency-and-threads","result":{"data":{"datoCmsMiscTextString":{"locale":"ko-KR","updatedAtText":"업데이트됨","nextReadText":"관련있는 게시물"},"datoCmsBlogPost":{"locale":"ko-KR","originalId":"186104748","title":"[운영체제][OSTEP] 병행성과 쓰레드","seo":{"seoTitle":"[운영체제][OSTEP] 병행성과 쓰레드","seoDescription":"병행성과 쓰레드에 대해 공부해봅니다.","seoImage":{"seoImageUrl":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format"}},"subtitle":"병행성과 쓰레드에 대해 공부해봅니다.","coverImage":{"coverImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&w=860","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.25&w=860 215w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.5&w=860 430w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&w=860 860w","sizes":"(min-width: 860px) 860px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgLCgoLDhMVDhcNDh0VDxUSGhYdHSIVFhUaKysjGh0oHSEWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLCgUFEBAOEC8oIhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIAAwAGAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAFAQQGAP/EAB0QAAEEAgMAAAAAAAAAAAAAAAEAAgMEESEFEjL/xAAWAQADAAAAAAAAAAAAAAAAAAAAAQP/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwDD1KM1uPLjpIRUI4GZc4aRXH25hTOHqqbth7yDIVIiXI2IQzqCoREhL/RyuQH/2Q=="},"width":860,"height":430}},"meta":{"updatedAt":"2023-08-15T16:38:46.921+09:00","firstPublishedAt":"2023-08-14T15:19:47.269+09:00"},"categoryLink":{"title":"개발 공부","id":"4743072"},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorPictureData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 60px) 60px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgWEQ8LDhgYDhUNDhgNDw8NFxUdGBYfFhUaHysjGikoHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OHBANHDUcIig7NS81NS81MjUvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAFAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAABQYHAv/EAB4QAAICAgMBAQAAAAAAAAAAAAABAgMFBgQRQXEi/8QAFQEBAQAAAAAAAAAAAAAAAAAABAP/xAAaEQACAwEBAAAAAAAAAAAAAAAAAQIDEhMR/9oADAMBAAIRAxEAPwDT8/1LHSK/r67scevSfz99VXBkm/Cva/zKle/pCc/JoRXWsFujxvygcLI1pAXqQTmjONm2RzpceyCwmwxpsbbADWJdBFbeCfe2wXoAGpIL6z//2Q=="},"width":60,"height":60}}},"relatedPosts":[],"structuredBody":{"blocks":[],"links":[],"value":{"schema":"dast","document":{"type":"root","children":[{"type":"heading","level":2,"children":[{"type":"span","value":"🚪 들어가며"}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"쓰레드(thread)"},{"type":"span","value":": 어떠한 프로그램 내에서, 특히 프로세스 내에서 실행되는 흐름의 단위\n➡️ 프로그램 카운터(PC)와 연산을 위한 레지스터들을 가짐."}]},{"type":"paragraph","children":[{"type":"span","value":"멀티 쓰레드 프로그램\n➡️ 하나 이상의 실행 지점(여러 개의 PC 값)을 가짐.\n➡️ 각 쓰레드는 프로세스와 매우 유사하지만, 쓰레드들은 "},{"type":"span","marks":["highlight"],"value":"주소 공간을 공유"},{"type":"span","value":"하므로 동일한 값에 접근 가능\n➡️ "},{"type":"span","marks":["highlight"],"value":"쓰레드마다 스택이 할당되어 있음."},{"type":"span","value":"(아래의 예시 그림을 참고하자.)"}]},{"code":"Single-Threaded Address Space    Multi-Threaded Address Space\n \n 0 KB ┌──────────────┐             0 KB ┌──────────────┐\n      │ Program Code │                  │ Program Code │\n 1 KB ├──────────────┤             1 KB ├──────────────┤\n      │     Heap     │                  │     Heap     │\n 2 KB ├──────────────┤             2 KB ├──────────────┤\n      │       │      │                  │              │\n      │       │      │                  │    (free)    │\n      │       ↓      │                  │              │              \n      │    (free)    │                  ├──────────────┤\n      │       ↑      │                  │   Stack (2)  │\n      │       │      │                  ├──────────────┤\n      │       │      │                  │    (free)    │\n15 KB ├──────────────┤            15 KB ├──────────────┤\n      │     Stack    │                  │   Stack (1)  │\n16 KB └──────────────┘            16 KB └──────────────┘","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"💾 스택에서 할당되는 변수들이나 매개변수, 리턴 값, 그리고 그 외에 스택에 넣는 것들은 해당 쓰레드의 스택인 "},{"type":"span","marks":["highlight"],"value":"쓰레드-로컬 저장소(thread-local storage)"},{"type":"span","value":"에 저장된다."}]},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 쓰레드-로컬 저장소로 인해 주소 공간의 배치가 무너짐.\n➡️ 스택의 크기가 아주 크지 않아도 되므로 대부분의 경우에는 문제가 되지 않음.\n➡️ 그러나 재귀 호출을 아주 많이 한다면...🌀"}]},{"type":"paragraph","children":[{"type":"span","value":"💡 두 개의 쓰레드가 하나의 프로세서에서 실행 중인 경우\n➡️ 실행하고자 하는 쓰레드는 반드시 "},{"type":"span","marks":["highlight"],"value":"문맥 교환(context switch)"},{"type":"span","value":"을 통해서 실행 중인 쓰레드와 교체되어야 함."}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"쓰레드 제어 블럭(thread control block, TCB)"},{"type":"span","value":": 쓰레드들의 상태를 저장\n➡️ 프로세스 제어 블럭(PCB)와 유사\n➡️ 프로세스 문맥 교환과 달리 쓰레드 간의 "},{"type":"span","marks":["highlight"],"value":"문맥 교환 시 주소 공간을 그대로 사용(사용하고 있던 페이지 테이블을 그대로 사용)"}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"1️⃣ 예제: 쓰레드 생성"}]},{"type":"paragraph","children":[{"type":"span","value":""}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"2️⃣"}]},{"type":"paragraph","children":[{"type":"span","value":""}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"3️⃣"}]},{"type":"paragraph","children":[{"type":"span","value":""}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"4️⃣"}]},{"type":"paragraph","children":[{"type":"span","value":""}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"5️⃣"}]},{"type":"paragraph","children":[{"type":"span","value":""}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"6️⃣"}]},{"type":"paragraph","children":[{"type":"span","value":""}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"🧺 병행성과 쓰레드 정리 하기"}]},{"type":"paragraph","children":[{"type":"span","value":""}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"📚 참고 문헌"}]},{"type":"paragraph","children":[{"url":"https://pages.cs.wisc.edu/~remzi/OSTEP/vm-beyondphys.pdf","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"Operating Systems: Three Easy Pieces ― 21: Beyond Physical Memory: Mechanisms"}]}]},{"type":"paragraph","children":[{"url":"https://pages.cs.wisc.edu/~remzi/OSTEP/Korean/21_vm-beyondphys.pdf","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"운영체제 아주 쉬운 세 가지 이야기 ― 24: 물리 메모리 크기의 극복: 메커니즘"}]}]}]}}}}},"pageContext":{"id":"186104748","locale":"ko-KR"}},"staticQueryHashes":["1034768456","1118752904","2342916782","2757196681","3415878905","3879866231","4195094990"]}