{"componentChunkName":"component---src-templates-article-jsx","path":"/blog/development/os-concurrency-and-threads","result":{"data":{"datoCmsMiscTextString":{"locale":"ko-KR","updatedAtText":"업데이트됨","nextReadText":"관련있는 게시물"},"datoCmsBlogPost":{"locale":"ko-KR","originalId":"186104748","title":"[운영체제][OSTEP] 병행성과 쓰레드","seo":{"seoTitle":"[운영체제][OSTEP] 병행성과 쓰레드","seoDescription":"병행성과 쓰레드에 대해 공부해봅니다.","seoImage":{"seoImageUrl":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format"}},"subtitle":"병행성과 쓰레드에 대해 공부해봅니다.","coverImage":{"coverImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&w=860","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.25&w=860 215w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.5&w=860 430w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&w=860 860w","sizes":"(min-width: 860px) 860px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgLCgoLDhMVDhcNDh0VDxUSGhYdHSIVFhUaKysjGh0oHSEWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLCgUFEBAOEC8oIhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIAAwAGAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAFAQQGAP/EAB0QAAEEAgMAAAAAAAAAAAAAAAEAAgMEESEFEjL/xAAWAQADAAAAAAAAAAAAAAAAAAAAAQP/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwDD1KM1uPLjpIRUI4GZc4aRXH25hTOHqqbth7yDIVIiXI2IQzqCoREhL/RyuQH/2Q=="},"width":860,"height":430}},"meta":{"updatedAt":"2023-08-15T17:40:05.696+09:00","firstPublishedAt":"2023-08-14T15:19:47.269+09:00"},"categoryLink":{"title":"개발 공부","id":"4743072"},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorPictureData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 60px) 60px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgWEQ8LDhgYDhUNDhgNDw8NFxUdGBYfFhUaHysjGikoHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OHBANHDUcIig7NS81NS81MjUvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAFAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAABQYHAv/EAB4QAAICAgMBAQAAAAAAAAAAAAABAgMFBgQRQXEi/8QAFQEBAQAAAAAAAAAAAAAAAAAABAP/xAAaEQACAwEBAAAAAAAAAAAAAAAAAQIDEhMR/9oADAMBAAIRAxEAPwDT8/1LHSK/r67scevSfz99VXBkm/Cva/zKle/pCc/JoRXWsFujxvygcLI1pAXqQTmjONm2RzpceyCwmwxpsbbADWJdBFbeCfe2wXoAGpIL6z//2Q=="},"width":60,"height":60}}},"relatedPosts":[],"structuredBody":{"blocks":[],"links":[],"value":{"schema":"dast","document":{"type":"root","children":[{"type":"heading","level":2,"children":[{"type":"span","value":"🚪 들어가며"}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"쓰레드(thread)"},{"type":"span","value":": 어떠한 프로그램 내에서, 특히 프로세스 내에서 실행되는 흐름의 단위\n➡️ 프로그램 카운터(PC)와 연산을 위한 레지스터들을 가짐."}]},{"type":"paragraph","children":[{"type":"span","value":"멀티 쓰레드 프로그램\n➡️ 하나 이상의 실행 지점(여러 개의 PC 값)을 가짐.\n➡️ 각 쓰레드는 프로세스와 매우 유사하지만, 쓰레드들은 "},{"type":"span","marks":["highlight"],"value":"주소 공간을 공유"},{"type":"span","value":"하므로 동일한 값에 접근 가능\n➡️ "},{"type":"span","marks":["highlight"],"value":"쓰레드마다 스택이 할당되어 있음."},{"type":"span","value":"(아래의 예시 그림을 참고하자.)"}]},{"code":"Single-Threaded Address Space    Multi-Threaded Address Space\n \n 0 KB ┌──────────────┐             0 KB ┌──────────────┐\n      │ Program Code │                  │ Program Code │\n 1 KB ├──────────────┤             1 KB ├──────────────┤\n      │     Heap     │                  │     Heap     │\n 2 KB ├──────────────┤             2 KB ├──────────────┤\n      │       │      │                  │              │\n      │       │      │                  │    (free)    │\n      │       ↓      │                  │              │              \n      │    (free)    │                  ├──────────────┤\n      │       ↑      │                  │   Stack (2)  │\n      │       │      │                  ├──────────────┤\n      │       │      │                  │    (free)    │\n15 KB ├──────────────┤            15 KB ├──────────────┤\n      │     Stack    │                  │   Stack (1)  │\n16 KB └──────────────┘            16 KB └──────────────┘","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"💾 스택에서 할당되는 변수들이나 매개변수, 리턴 값, 그리고 그 외에 스택에 넣는 것들은 해당 쓰레드의 스택인 "},{"type":"span","marks":["highlight"],"value":"쓰레드-로컬 저장소(thread-local storage)"},{"type":"span","value":"에 저장된다."}]},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 쓰레드-로컬 저장소로 인해 주소 공간의 배치가 무너짐.\n➡️ 스택의 크기가 아주 크지 않아도 되므로 대부분의 경우에는 문제가 되지 않음.\n➡️ 그러나 재귀 호출을 아주 많이 한다면...🌀"}]},{"type":"paragraph","children":[{"type":"span","value":"💡 두 개의 쓰레드가 하나의 프로세서에서 실행 중인 경우\n➡️ 실행하고자 하는 쓰레드는 반드시 "},{"type":"span","marks":["highlight"],"value":"문맥 교환(context switch)"},{"type":"span","value":"을 통해서 실행 중인 쓰레드와 교체되어야 함."}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"쓰레드 제어 블럭(thread control block, TCB)"},{"type":"span","value":": 쓰레드들의 상태를 저장\n➡️ 프로세스 제어 블럭(PCB)와 유사\n➡️ 프로세스 문맥 교환과 달리 쓰레드 간의 "},{"type":"span","marks":["highlight"],"value":"문맥 교환 시 주소 공간을 그대로 사용(사용하고 있던 페이지 테이블을 그대로 사용)"}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"1️⃣ 예제: 쓰레드 생성"}]},{"type":"paragraph","children":[{"type":"span","value":"쓰레드1은 \"A\"를 출력하고, 쓰레드2는 \"B\"를 출력하는 독립적인 두 개의 쓰레드를 생성하는 프로그램을 실행시키는 상황을 가정해보자."}]},{"type":"paragraph","children":[{"type":"span","value":"코드는 다음과 같다."}]},{"code":"#include <stdio.h>\n#include <assert.h>\n#include <pthread.h>\n\nvoid *mythread(void *arg) {\n  printf(\"%s\\n\", (char *) arg);\n  return NULL;\n}\n\nint main(int argc, char *argv[]) \n{\n  pthread_t p1, p2;\n  int rc;\n  printf(\"main: begin\\n \");\n  rc = pthread_create(&p1, NULL, mythread, \"A\");\n  assert(rc &=& 0);\n  rc = pthread_create(&p2, NULL, mythread, \"B\");\n  assert(rc &=& 0);\n  // ᳦종료 할 수 있도록 대기 중인 쓰레드 병합하기\n  rc = pthread_join(p1, NULL); assert(rc &=& 0);\n  rc = pthread_join(p2, NULL); assert(rc &=& 0);\n  printf(\"main: end\\n\");\n  return 0;\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"동작은 다음 순서와 같다."}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"main()"},{"type":"span","value":"은 "},{"type":"span","marks":["code"],"value":"mythread()"},{"type":"span","value":"를 실행할 두 개의 쓰레드를 생성"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"각 "},{"type":"span","marks":["code"],"value":"mythread()"},{"type":"span","value":"는 서로 다른 인자를 전달 받음."}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"스케줄러의 동작에 따라 쓰레드는 생성 후 즉시 실행되거나, 준비(Ready) 상태에서 실행은 되지 않을 수 있음."}]}]}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"두 개의 쓰레드 생성 후 메인 쓰레드는 "},{"type":"span","marks":["code"],"value":"pthread_join()"},{"type":"span","value":"을 호출하여 특정 쓰레드의 동작 종료를 대기"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"위 프로그램의 가능한 실행 순서는 다음과 같을 수 있다."}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"main() ➡️ 쓰레드1 생성 ➡️ 쓰레드2 생성 ➡️ 쓰레드1 실행 ➡️ 쓰레드 2실행 ➡️ 종료"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"main() ➡️ 쓰레드1 생성 ➡️ 쓰레드1 실행 ➡️ 쓰레드2 생성 ➡️ 쓰레드 2실행 ➡️ 종료"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"..."}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"이외에도 쓰레드 1과 쓰레드 2가 순서대로 생성 되었더라도 스케줄러가 쓰레드2를 먼저 실행하면 \"B\", \"A\" 순서로 출력되는 경우가 있을 수 있다."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"쓰레드 생성 vs. 함수 호출"}]},{"type":"paragraph","children":[{"type":"span","value":"함수를 호출하는 경우, "},{"type":"span","marks":["highlight"],"value":"함수 실행 후 호출자(caller)에게 리턴"}]},{"type":"paragraph","children":[{"type":"span","value":"쓰레드를 생성하는 경우, 실행할 명령어들을 갖고 있는 새로운 쓰레드가 생성되고, "},{"type":"span","marks":["highlight"],"value":"생성된 쓰레드는 호출자와 별개로 실행"}]},{"type":"paragraph","children":[{"type":"span","value":"어떤 쓰레드가 언제 실행되는지 알기 어려움."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"2️⃣ 훨씬 더 어려운 이유: 데이터의 공유"}]},{"type":"paragraph","children":[{"type":"span","value":"전역 공유 변수를 갱신하는 두 개의 쓰레드에 대한 예시를 살펴보자."}]},{"type":"paragraph","children":[{"type":"span","value":"코드는 다음과 같다."}]},{"code":"#include <stdio.h>\n#include <pthread.h>\n#include \"mythreads.h\"\n\nstatic volatile int counter = 0;\n\n// mythread()\n// 반복문을 사용하여 단순히 1씩 더하기\n// 10,000,000을 변수 counter에 더하는 방법이 아니다.\n// 하지만, 문제가 무엇인지 명확하게 해준다.\nvoid *mythread(void *arg) {\n  printf(\"%s: begin\\n\", (char *) arg);\n  int i;\n  for (i = 0; i < 1e7; i++) {\n    counter = counter + 1;\n  }\n  printf(\"%s: done\\n\", (char *) arg);\n  return NULL;\n}\n\n// main()\n// 두 개의 쓰레드를 실행하고 (pthread_create)\n// 대기한다 (pthread_join)\nint main(int argc, char *argv[])\n{\n  pthread_t p1, p2;\n  printf(\"main: begin (counter = %d)\\n\", counter);\n  Pthread_create(&p1, NULL, mythread, \"A\");\n  Pthread_create(&p2, NULL, mythread, \"B\");\n  \n  // 쓰레드가 종료할 수 있도록 대기 중인 쓰레드를 병합한다\n  Pthread_join(p1, NULL);\n  Pthread_join(p2, NULL);\n  printf(\"main: done with both (counter = %d)\\n\", counter);\n  return 0;\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"위의 코드에서 "},{"type":"span","marks":["code"],"value":"Pthread_create()"},{"type":"span","value":"는 단순히 "},{"type":"span","marks":["code"],"value":"pthread_create()"},{"type":"span","value":"를 호출하고 리턴 값이 0인지 확인한다. 0이 아닌 경우 에러 메시지를 출력하고 종료한다.("},{"type":"span","marks":["code"],"value":"Pthread_join()"},{"type":"span","value":"도 마찬가지이다.)"}]},{"type":"paragraph","children":[{"type":"span","value":"각 작업자 쓰레드는 반목문 안에서 공유 변수인 "},{"type":"span","marks":["code"],"value":"counter"},{"type":"span","value":"에 수를 천만 번(1e7)더한다.\n➡️ 최종적으로 얻으려는 값은 20,000,000이다."}]},{"type":"paragraph","children":[{"type":"span","value":"우리가 기대한 실행 결과는 다음과 같다."}]},{"code":"prompt> gcc −o main main.c −Wall −pthread\nprompt> ./main\nmain: begin (counter = 0)\nA: begin\nB: begin\nA: done\nB: done\nmain: done with both (counter = 20000000)","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"하지만 단일 프로세서라 하더라도 때로는 아래와 같은 결과를 얻는다."}]},{"code":"prompt> ./main\nmain: begin (counter = 0)\nA: begin\nB: begin\nA: done\nB: done\nmain: done with both (counter = 19345221)","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"🤔 도대체 무슨 일이 벌어진 건지 알아보자."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"3️⃣ 제어 없는 스케줄링"}]},{"type":"paragraph","children":[{"type":"span","value":"왜 위와 같은 현상이 발생하는지 이해하려면 "},{"type":"span","marks":["code"],"value":"counter"},{"type":"span","value":" 갱신을 위해서 "},{"type":"span","marks":["highlight"],"value":"컴파일러가 생성한 코드의 실행 순서를 이해"},{"type":"span","value":"해야 한다."}]},{"type":"paragraph","children":[{"type":"span","value":"x86에서 "},{"type":"span","marks":["code"],"value":"counter"},{"type":"span","value":"를 증가하는 코드의 순서는 다음과 같다."}]},{"code":"mov 0x8049a1c, %eax\nadd $0x1, %eax\nmov %eax, 0x8049a1c","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"이 예제에서 사용하는 "},{"type":"span","marks":["code"],"value":"counter"},{"type":"span","value":" 변수의 위치의 주소는 "},{"type":"span","marks":["code"],"value":"0x8049a1c"},{"type":"span","value":"라고 가정한다."}]},{"type":"paragraph","children":[{"type":"span","value":"💡 이제 어떻게 문제가 발생하는지 살펴보자."}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"쓰레드1이 "},{"type":"span","marks":["code"],"value":"counter"},{"type":"span","value":"를 증가시키는 코드 영역에 진입한다."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"counter"},{"type":"span","value":"의 값이 50이었다고 가정하면, 50을 "},{"type":"span","marks":["code"],"value":"eax"},{"type":"span","value":"레지스터에 넣는다."}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"쓰레드1에 있어서 "},{"type":"span","marks":["code"],"value":"eax=50"},{"type":"span","value":"이 된다."}]}]}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"레지스터의 값에 1을 더하여 "},{"type":"span","marks":["code"],"value":"eax=51"},{"type":"span","value":"이 된다."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"타이머 인터럽트가 발생"},{"type":"span","value":"하여 운영체제가 실행 중이 쓰레드의 현재 상태를 쓰레드의 TCB에 저장한다."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"쓰레드2가 선택되어 "},{"type":"span","marks":["code"],"value":"counter"},{"type":"span","value":"를 증가시키는 똑같은 코드 영역에 진입한다."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"counter"},{"type":"span","value":"의 값은 아직 50이므로 첫 번째 명령어 실행 결과 쓰레드2의 "},{"type":"span","marks":["code"],"value":"eax"},{"type":"span","value":" 값은 50이다."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"eax"},{"type":"span","value":" 값을 1 증가시키고 다시 "},{"type":"span","marks":["code"],"value":"counter"},{"type":"span","value":"(주소 "},{"type":"span","marks":["code"],"value":"0x8049a1c"},{"type":"span","value":")에 저장한다."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"다시 "},{"type":"span","marks":["highlight"],"value":"문맥 교환이 발생"},{"type":"span","value":"하여 쓰레드1이 리턴하여 실행된다."}]}]}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"4️⃣"}]},{"type":"paragraph","children":[{"type":"span","value":""}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"5️⃣"}]},{"type":"paragraph","children":[{"type":"span","value":""}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"6️⃣"}]},{"type":"paragraph","children":[{"type":"span","value":""}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"🧺 병행성과 쓰레드 정리 하기"}]},{"type":"paragraph","children":[{"type":"span","value":""}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"📚 참고 문헌"}]},{"type":"paragraph","children":[{"url":"https://pages.cs.wisc.edu/~remzi/OSTEP/vm-beyondphys.pdf","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"Operating Systems: Three Easy Pieces ― 21: Beyond Physical Memory: Mechanisms"}]}]},{"type":"paragraph","children":[{"url":"https://pages.cs.wisc.edu/~remzi/OSTEP/Korean/21_vm-beyondphys.pdf","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"운영체제 아주 쉬운 세 가지 이야기 ― 24: 물리 메모리 크기의 극복: 메커니즘"}]}]}]}}}}},"pageContext":{"id":"186104748","locale":"ko-KR"}},"staticQueryHashes":["1034768456","1118752904","2342916782","2757196681","3415878905","3879866231","4195094990"]}