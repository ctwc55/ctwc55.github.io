{"componentChunkName":"component---src-templates-article-jsx","path":"/blog/development/os-locks","result":{"data":{"datoCmsMiscTextString":{"locale":"ko-KR","updatedAtText":"업데이트됨","nextReadText":"관련있는 게시물"},"datoCmsBlogPost":{"locale":"ko-KR","originalId":"187813035","title":"[운영체제][OSTEP] 락","seo":{"seoTitle":"[운영체제][OSTEP] 락","seoDescription":"임계 영역에서의 원자적인 실행을 위한 락에 대해 공부해봅니다.","seoImage":{"seoImageUrl":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format"}},"subtitle":"임계 영역에서의 원자적인 실행을 위한 락에 대해 공부해봅니다.","coverImage":{"coverImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&w=860","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.25&w=860 215w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.5&w=860 430w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&w=860 860w","sizes":"(min-width: 860px) 860px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgLCgoLDhMVDhcNDh0VDxUSGhYdHSIVFhUaKysjGh0oHSEWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLCgUFEBAOEC8oIhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIAAwAGAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAFAQQGAP/EAB0QAAEEAgMAAAAAAAAAAAAAAAEAAgMEESEFEjL/xAAWAQADAAAAAAAAAAAAAAAAAAAAAQP/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwDD1KM1uPLjpIRUI4GZc4aRXH25hTOHqqbth7yDIVIiXI2IQzqCoREhL/RyuQH/2Q=="},"width":860,"height":430}},"meta":{"updatedAt":"2023-08-22T22:47:51.945+09:00","firstPublishedAt":"2023-08-17T00:33:01.771+09:00"},"categoryLink":{"title":"개발 공부","id":"4743072"},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorPictureData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 60px) 60px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgWEQ8LDhgYDhUNDhgNDw8NFxUdGBYfFhUaHysjGikoHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OHBANHDUcIig7NS81NS81MjUvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAFAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAABQYHAv/EAB4QAAICAgMBAQAAAAAAAAAAAAABAgMFBgQRQXEi/8QAFQEBAQAAAAAAAAAAAAAAAAAABAP/xAAaEQACAwEBAAAAAAAAAAAAAAAAAQIDEhMR/9oADAMBAAIRAxEAPwDT8/1LHSK/r67scevSfz99VXBkm/Cva/zKle/pCc/JoRXWsFujxvygcLI1pAXqQTmjONm2RzpceyCwmwxpsbbADWJdBFbeCfe2wXoAGpIL6z//2Q=="},"width":60,"height":60}}},"relatedPosts":[{"id":"187067258","meta":{"updatedAt":"2023-08-17T00:33:37.291+09:00"},"categoryLink":{"title":"개발 공부"},"coverImage":{"gatsbyImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.09&w=860 75w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.18&w=860 150w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860 300w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.7&w=860 600w","sizes":"(min-width: 300px) 300px, 100vw"}},"layout":"constrained","width":300,"height":120},"squaredImage":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.06&fit=crop&fp-x=0.5&fp-y=0.5&w=430 25w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.12&fit=crop&fp-x=0.5&fp-y=0.5&w=430 50w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430 100w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.47&fit=crop&fp-x=0.5&fp-y=0.5&w=430 200w","sizes":"(min-width: 100px) 100px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBhINEBAQCggUDg0IDgcHFh0JFhEYFxUZGCIVFhUaHysjGh0oHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OEg4REC8dFhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAGAMBIgACEQEDEQH/xAAaAAEBAAIDAAAAAAAAAAAAAAAABAUGAQID/8QAHRAAAgICAwEAAAAAAAAAAAAAAAIDBAEREhQVBf/EABYBAQEBAAAAAAAAAAAAAAAAAAADAf/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/ANASs2WLoaraMl1o0O241wSYlSHjgHM9hVAEFr6bKSemzAAeclpnAAH/2Q=="},"width":100,"height":100}},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.11&w=77 8w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 30px) 30px, 100vw"}},"layout":"constrained","width":30,"height":30}}},"subtitle":"쓰레드 API를 이용하여 쓰레드를 생성하고 제어하는 방법에 대해 공부해봅니다","title":"[운영체제][OSTEP] 쓰레드 API"},{"id":"189836506","meta":{"updatedAt":"2023-08-25T00:29:04.258+09:00"},"categoryLink":{"title":"개발 공부"},"coverImage":{"gatsbyImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.09&w=860 75w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.18&w=860 150w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860 300w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.7&w=860 600w","sizes":"(min-width: 300px) 300px, 100vw"}},"layout":"constrained","width":300,"height":120},"squaredImage":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.06&fit=crop&fp-x=0.5&fp-y=0.5&w=430 25w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.12&fit=crop&fp-x=0.5&fp-y=0.5&w=430 50w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430 100w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.47&fit=crop&fp-x=0.5&fp-y=0.5&w=430 200w","sizes":"(min-width: 100px) 100px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBhINEBAQCggUDg0IDgcHFh0JFhEYFxUZGCIVFhUaHysjGh0oHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OEg4REC8dFhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAGAMBIgACEQEDEQH/xAAaAAEBAAIDAAAAAAAAAAAAAAAABAUGAQID/8QAHRAAAgICAwEAAAAAAAAAAAAAAAIDBAEREhQVBf/EABYBAQEBAAAAAAAAAAAAAAAAAAADAf/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/ANASs2WLoaraMl1o0O241wSYlSHjgHM9hVAEFr6bKSemzAAeclpnAAH/2Q=="},"width":100,"height":100}},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.11&w=77 8w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 30px) 30px, 100vw"}},"layout":"constrained","width":30,"height":30}}},"subtitle":"자료 구조에 락을 추가하여 쓰레드 사용에 안전한 구조를 만드는 방법에 대해 공부해봅니다.","title":"[운영체제][OSTEP] 락 기반의 병행 자료 구조"}],"structuredBody":{"blocks":[],"links":[],"value":{"schema":"dast","document":{"type":"root","children":[{"type":"heading","level":2,"children":[{"type":"span","value":"1️⃣ 락: 기본 개념"}]},{"code":"balance = balance + 1;","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"위와 같은 임계 영역을 다음과 같이 락으로 감싼 상황을 가정해보자."}]},{"code":"lock_t mutex; // 글로벌 변수로 선언된 락\n...\nlock(&mutex);\nbalance = balance + 1;\nunlock(&mutex);","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"위의 코드에서 나타나는 특징들을 하나씩 살펴보자."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"락은 하나의 변수이다."}]},{"type":"paragraph","children":[{"type":"span","value":"락을 사용하기 위해서는 "},{"type":"span","marks":["highlight"],"value":"락 변수를 먼저 선언"},{"type":"span","value":"해야 한다."}]},{"type":"paragraph","children":[{"type":"span","value":"락 변수는 "},{"type":"span","marks":["highlight"],"value":"락의 상태"},{"type":"span","value":"를 나타낸다.\n✅ "},{"type":"span","marks":["highlight"],"value":"사용 가능(available) 상태"},{"type":"span","value":"(해제(unlocked) 또는 free): 어느 쓰레드도 락을 갖고 있지 않은 상태\n🚫 "},{"type":"span","marks":["highlight"],"value":"사용 중(acquired)"},{"type":"span","value":": 임계 영역에서 정확히 하나의 쓰레드가 락을 획득한 상태"}]},{"type":"paragraph","children":[{"type":"span","value":"락 자료 구조에 락을 보유한 쓰레드에 대한 정보나 락을 대기하는 쓰레드들에 대한 정보를 저장할 수도 있음.\n➡️ 단, 락 사용자는 이러한 정보를 알 수 없음."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"lock( )과 unlock( ) 루틴"}]},{"type":"paragraph","children":[{"type":"span","value":"🔒 "},{"type":"span","marks":["code"],"value":"lock()"},{"type":"span","value":" 루틴 호출을 통해 락 획득을 시도\n➡️ 만약 어떤 쓰레드도 락을 갖고 있지 않다면, 락을 획득하여 임계 영역 내로 진입\n➡️ 임계 영역 내로 진입한 쓰레드를 락 "},{"type":"span","marks":["highlight"],"value":"소유자(owner)"},{"type":"span","value":"라고 부름.\n➡️ 락이 이미 사용 중이라면, "},{"type":"span","marks":["code"],"value":"lock()"},{"type":"span","value":" 함수가 리턴하지 않음."}]},{"type":"paragraph","children":[{"type":"span","value":"🔓 락 소유자가 "},{"type":"span","marks":["code"],"value":"unlock()"},{"type":"span","value":"을 호출\n➡️ 락은 다시 사용 가능한 상태가 됨.\n➡️ "},{"type":"span","marks":["code"],"value":"lock()"},{"type":"span","value":" 호출 후 대기 중이던 쓰레드가 있다면, 락을 획득하여 임계 영역 내로 진입"}]},{"type":"paragraph","children":[{"type":"span","value":"락은 프로그래머에게 스케줄링에 대한 최소한의 제어권을 제공"}]},{"type":"paragraph","children":[{"type":"span","value":"일반적으로 쓰레드는 프로그래머가 생성하고 운영체제가 제어\n➡️ 락은 쓰레드에 대한 제어권을 일부 이양 받을 수 있도록 해줌."}]},{"type":"paragraph","children":[{"type":"span","value":"💡 "},{"type":"span","marks":["highlight"],"value":"락으로 코드를 감싸서"},{"type":"span","value":" 프로그래머는 "},{"type":"span","marks":["highlight"],"value":"그 코드 내에서는 하나의 쓰레드만 동작하도록 보장"}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"2️⃣ Pthread 락"}]},{"type":"heading","level":3,"children":[{"type":"span","value":"Mutex"}]},{"type":"paragraph","children":[{"type":"span","value":"쓰레드 간에 "},{"type":"span","marks":["highlight"],"value":"상호 배제(mutual exclusion)"},{"type":"span","value":" 기능을 제공하므로 POSIX 라이브러리는 락을 "},{"type":"span","marks":["highlight"],"value":"mutex"},{"type":"span","value":"라고 부름."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"POSIX의 락 사용 방식"}]},{"type":"paragraph","children":[{"type":"span","value":"POSIX 방식에서는 "},{"type":"span","marks":["highlight"],"value":"변수 명을 지정하여 락과 언락 함수에 전달"},{"type":"span","value":"\n➡️ 다른 변수를 보호하기 위해서 "},{"type":"span","marks":["underline"],"value":"다른 락"},{"type":"span","value":"을 사용할 수도 있기 때문\n➡️ 💡 세밀한 락 사용 전략"}]},{"type":"paragraph","children":[{"type":"span","value":"["},{"type":"span","marks":["highlight"],"value":"거친(coarse-grained)"},{"type":"span","value":" 락 사용 전략]\n하나의 락이 임의의 임계 영역에 진입할 때마다 사용"}]},{"type":"paragraph","children":[{"type":"span","value":"["},{"type":"span","marks":["highlight"],"value":"세밀한(fine-grained)"},{"type":"span","value":" 락 사용 전략]\n서로 다른 데이터와 자료 구조를 보호하기 위해 여러 락을 사용\n➡️ 한 번에 여러 쓰레드가 서로 다른 락으로 보호된 코드 내에 각자가 진입 가능"}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"3️⃣ 락 구현"}]},{"type":"paragraph","children":[{"type":"span","value":"효율적인 락 = 낮은 비용 + 상호 배제 기법 제공 & 몇 가지 속성들"}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"사용 가능한 락"},{"type":"span","value":"을 만들기 위해서 "},{"type":"span","marks":["highlight"],"value":"하드웨어와 운영체제의 도움"},{"type":"span","value":"을 받아야 함."}]},{"type":"paragraph","children":[{"type":"span","value":"정교한 락 라이브러리를 제작하는 데 있어 운영체제가 관여하는 것은 무엇인지 알아보자."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"4️⃣ 락의 평가"}]},{"type":"paragraph","children":[{"type":"span","value":"락이 (잘) 동작하는지 평가하기 위한 기준을 정해야 한다."}]},{"type":"heading","level":3,"children":[{"type":"span","marks":["highlight"],"value":"상호 배제"},{"type":"span","value":"를 제대로 지원하는가"}]},{"type":"paragraph","children":[{"type":"span","value":"락의 가장 기본적인 역할이다."}]},{"type":"paragraph","children":[{"type":"span","value":"기본적으로 락이 동작하여 임계 영역 내로 "},{"type":"span","marks":["highlight"],"value":"다수의 쓰레드가 진입하는 것을 막을 수 있는지 검사"},{"type":"span","value":"해야 한다."}]},{"type":"heading","level":3,"children":[{"type":"span","marks":["highlight"],"value":"공정성(fairness)"}]},{"type":"paragraph","children":[{"type":"span","value":"쓰레드들이 락 획득에 있어 공정한 기회가 주어지는지 확인해야 한다."}]},{"type":"paragraph","children":[{"type":"span","value":"이 문제의 다른 관점: 좀 더 극단적인 상황을 평가\n➡️ 락을 전혀 얻지 못해 "},{"type":"span","marks":["highlight"],"value":"굶주리는(starve)"},{"type":"span","value":" 경우가 발생하는가?"}]},{"type":"heading","level":3,"children":[{"type":"span","marks":["highlight"],"value":"성능(performance)"}]},{"type":"paragraph","children":[{"type":"span","value":"특히, 락 사용 시간적 오버헤드를 평가해야 한다."}]},{"type":"paragraph","children":[{"type":"span","value":"⛏️ 경쟁이 전혀 없는 경우"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"하나의 쓰레드가 실행 중에 락을 획득하고 해제하는 과정에서 발생하는 부하는 얼마나 되는가?"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"⚔️ 여러 쓰레드가 단일 CPU 상에서 락을 획득하려고 경쟁하는 상황"}]},{"type":"paragraph","children":[{"type":"span","value":"♟️ 멀티 CPU 상황에서 락 경쟁 시의 성능"}]},{"type":"paragraph","children":[{"type":"span","value":"이처럼 서로 다른 상황의 성능을 평가하여야 다양한 락 기법들이 성능에 미치는 영향을 이해할 수 있음."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"5️⃣ 인터럽트 제어"}]},{"type":"paragraph","children":[{"type":"span","value":"초창기 단일 프로세스 시스템\n➡️ 상호 배제 지원을 위해 임계 영역 내에서는 "},{"type":"span","marks":["highlight"],"value":"인터럽트를 비활성화"},{"type":"span","value":"하는 방법을 사용"}]},{"code":"void lock() {\n  DisableInterrupts();\n}\nvoid unlock() {\n  EnableInterrupts();\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"이 경우 임계 영역 내의 코드에서는 인터럽트가 발생할 수 없기 때문에 "},{"type":"span","marks":["highlight"],"value":"원자적으로 실행"},{"type":"span","value":"될 수 있음."}]},{"type":"paragraph","children":[{"type":"span","value":"✅ 주요 장점: 단순하다.\n인터럽트가 발생하지 않으면, 코드가 실행 중에 다른 쓰레드가 중간에 끼어들지 않는다는 것을 보장"}]},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 단점1: 이를 요청하는 쓰레드에게 인터럽트 활성/비활성 "},{"type":"span","marks":["highlight"],"value":"특권(privileged)"},{"type":"span","value":" 연산 허가\n쓰레드가 이를 다른 목적으로 사용하지 않음을 "},{"type":"span","marks":["underline"],"value":"신뢰"},{"type":"span","value":"해야 함.\n➡️ 탐욕적(Greedy) 기법을 사용한 프로그램이 시작과 동시에 "},{"type":"span","marks":["code"],"value":"lock()"},{"type":"span","value":"을 호출하여 프로세서를 독점하는 경우.."}]},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 단점2: 멀티프로세서에서는 적용 불가\n여러 쓰레드가 여러 CPU에서 실행 중인 경우 각 쓰레드가 동일한 임계 영역에 진입하려고 시도할 수 있음.\n➡️ 특정 프로세서의 인터럽트 비활성화는 "},{"type":"span","marks":["highlight"],"value":"다른 프로세서에서 실행 중인 프로그램에는 전혀 영향을 주지 않음."}]},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 단점3: 인터럽트의 장시간 중지는 중요한 인터럽트의 시점을 놓칠 수 있음.\n때로는 시스템에 심각한 문제를 가져 올 수 있음.\n➡️ CPU가 저장 장치에서 읽기 요청을 마친 사실을 모르고 지나간다면 이를 기다리고 있는 프로세스는 언제 깨울 수 있을까.."}]},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 단점4: 비효율적이다.\n일반적인 명령어의 실행에 비해 인터럽트를 비활성화시키는 코드들은 최신의 CPU들에서는 느리게 실행되는 경향이 있음."}]},{"type":"paragraph","children":[{"type":"span","value":"💡 따라서 상호 배제를 위한 인터럽트 비활성화는 제한된 범위에서만 사용되어야 한다.\n➡️ 운영체제가 내부 자료 구조에 대한 원자적 연산을 위해 인터럽트를 비활성화하는 등\n➡️ 운영체제 내부에서는 신뢰라는 문제가 사라지므로 용인 가능"}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"6️⃣ Test-And-Set (Atomic Exchange)"}]},{"type":"paragraph","children":[{"type":"span","value":"멀티프로세서에서는 인터럽트를 중지시키는 것이 의미가 없음.\n➡️ 시스템 설계자들은 락 지원을 위한 하드웨어를 설계하기 시작함."}]},{"type":"paragraph","children":[{"type":"span","value":"💡 "},{"type":"span","marks":["highlight"],"value":"Test-And-Set"},{"type":"span","value":" 명령어 또는 "},{"type":"span","marks":["highlight"],"value":"원자적 교체(atomic exchange)"},{"type":"span","value":"\n➡️ 하드웨어 기법 중 기장 기본적인 기법"}]},{"type":"paragraph","children":[{"type":"span","value":"이해를 위해 먼저 아래의 코드를 살펴보자."}]},{"code":"typedef struct __lock_t { int flag; } lock_t;\n\nvoid init(lock_t *mutex) {\n  // 0 −> 락이 사용 가능함, 1 -> 락 사용 중\n  mutex−>flag = 0;\n}\n\nvoid lock(lock_t *mutex) {\n  while (mutex−>flag == 1); // flag 변수를 검사(TEST) 함\n  // spin−wait (do nothing)\n  mutex−>flag = 1; // 이제 설정(SET) 한다!\n}\n\nvoid unlock(lock_t *mutex) {\n  mutex−>flag = 0;\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"💡 간단한 변수("},{"type":"span","marks":["code"],"value":"flag"},{"type":"span","value":")를 사용하여 쓰레드가 락을 획득하였는지를 나타낸다."}]},{"type":"paragraph","children":[{"type":"span","value":"그러나 위의 코드에는 두 가지 문제가 있다."}]},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 문제1: 정확성\n위의 예시에서 적시에 인터럽트가 발생하면 두 쓰레드 모두 플래그를 1로 설정하는 경우가 생길 수 있음.\n➡️ 임계 영역에 두 쓰레드가 다 진입할 수 있음.\n➡️ 🚫 상호 배제 제공 실패"}]},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 문제2: 성능\n사용 중인 락을 대기할 때 "},{"type":"span","marks":["highlight"],"value":"spin-wait"},{"type":"span","value":"라는 방법을 사용\n➡️ 플래그의 값을 무한히 검사하므로, 다른 쓰레드가 락을 해제할 때까지 시간을 낭비\n➡️ 특히, 단일 프로세서에서 매우 손해가 큼.(적어도 문맥 교환이 있기 전까지는 락을 소유한 쓰레드조차 실행X)"}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"7️⃣ 진짜 돌아가는 스핀 락의 구현"}]},{"type":"paragraph","children":[{"type":"span","value":"앞선 아이디어는 하드웨어 지원 없이는 동작이 불가능\n➡️ 일부 시스템은 이 개념에 근간한 락 구현을 위한 (어셈블리) 명령어를 제공"}]},{"type":"paragraph","children":[{"type":"span","value":"아래와 같이 시스템마다 명령어의 이름은 다르지만,"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"SPARC: "},{"type":"span","marks":["code"],"value":"ldstub"},{"type":"span","value":"("},{"type":"span","marks":["code"],"value":"load/store unsigned byte"},{"type":"span","value":" 동작)"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"x86: "},{"type":"span","marks":["code"],"value":"xchg"},{"type":"span","value":"(원자적 교체 명령어)"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"기본적으로 동일한 일을 수행하며 일반적으로 "},{"type":"span","marks":["highlight"],"value":"Test-And-Set"},{"type":"span","value":"라고 불린다."}]},{"type":"paragraph","children":[{"type":"span","value":"다음의 C 코드의 일부를 사용하여 "},{"type":"span","marks":["code"],"value":"TestAndSet"},{"type":"span","value":"의 동작을 정의해 보자."}]},{"code":"int TestAndSet(int *old_ptr, int new) {\n  int old = *old_ptr; // old_ptr의 이전 값을 가져옴\n  *old_ptr = new;     // old_ptr에 'new'의 값을 저장함\n  return old;         // old의 값을 반환함\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"위의 코드를 통해 \"test and set\"이라고 불리는 이유를 알 수 있다.\n➡️ \"test\"하는(반환되는 값) 동시에 메모리에 새로운 값을 \"set\"하기 때문"}]},{"type":"paragraph","children":[{"type":"span","value":"✅ 핵심은 이 동작들이 "},{"type":"span","marks":["highlight"],"value":"원자적으로 수행"},{"type":"span","value":"된다는 것"}]},{"type":"paragraph","children":[{"type":"span","value":"이제 6️⃣의 예시 코드에서 "},{"type":"span","marks":["code"],"value":"lock()"},{"type":"span","value":" 함수를 다음과 같이 재작성하여 간단한 스핀 락(spin lock)을 만들 수 있다."}]},{"code":"void lock(lock_t *lock) {\n  while (TestAndSet(&lock−>flag, 1) == 1);\n  // 스핀(아무 일도 하지 않음)\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"💡 위의 락이 동작하는 이유를 다시 짚어보자."}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"한 쓰레드가 "},{"type":"span","marks":["code"],"value":"lock()"},{"type":"span","value":" 요청 시 아직 다른 어떤 쓰레드도 락을 보유하고 있지 않고 있음."}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"flag"},{"type":"span","value":" 값은 0"}]}]}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"해당 쓰레드가 "},{"type":"span","marks":["code"],"value":"TestAndSet(flag, 1)"},{"type":"span","value":"을 호출"}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"TestAndSet()"},{"type":"span","value":"은 "},{"type":"span","marks":["code"],"value":"flag"},{"type":"span","value":"의 이전 값인 0을 반환"}]}]}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"flag"},{"type":"span","value":" 값을 검사한 쓰레드는 "},{"type":"span","marks":["code"],"value":"while"},{"type":"span","value":" 문에서 "},{"type":"span","marks":["highlight"],"value":"회전하지 않고 락 획득"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"해당 쓰레드는 "},{"type":"span","marks":["highlight","code"],"value":"flag"},{"type":"span","marks":["highlight"],"value":" 값을 1로 설정하여 락을 보유하고 있음을 표시"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"임계 영역 내의 동작을 끝마치면 "},{"type":"span","marks":["highlight","code"],"value":"unlock()"},{"type":"span","marks":["highlight"],"value":"을 호출하여 "},{"type":"span","marks":["highlight","code"],"value":"flag"},{"type":"span","marks":["highlight"],"value":"를 다시 0으로 변경"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"락이 사용 중이어서 flag 값이 1인 경우의 동작도 생각해보자."}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"쓰레드가 "},{"type":"span","marks":["code"],"value":"lock()"},{"type":"span","value":"을 호출하여 "},{"type":"span","marks":["code"],"value":"TestAndSet(flag, 1)"},{"type":"span","value":" 루틴을 실행한다."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"이미 락을 다른 쓰레드가 보유하고 있으므로 예전 값으로 1을 반환하는 동시에 "},{"type":"span","marks":["code"],"value":"flag"},{"type":"span","value":"의 값을 다시 1로 설정한다."}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"락을 보유하고 있는 쓰레드가 있는 한 "},{"type":"span","marks":["code"],"value":"TestAndSet"},{"type":"span","value":"는 계속 1을 반환"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"대기 중인 쓰레드는 락이 해제될 때까지 계속 "},{"type":"span","marks":["code"],"value":"while"},{"type":"span","value":" 문을 반복"}]}]}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"락을 보유하고 있던 쓰레드가 "},{"type":"span","marks":["code"],"value":"flag"},{"type":"span","value":" 값을 0으로 변경"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"대기 중이던 쓰레드가 "},{"type":"span","marks":["code"],"value":"TestAndSet()"},{"type":"span","value":"를 호출하여 0을 받는 동시에 원자적으로 값을 1로 변경"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"임계 영역으로 진입"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"✅ 락의 값을 검사(test)하고 새로운 값으로 설정(set)하는 동작을 원자적 연산으로 만듦으로써 오직 하나의 쓰레드만 락을 획득할 수 있도록 만듦."}]},{"type":"paragraph","children":[{"type":"span","value":"💡 "},{"type":"span","marks":["highlight"],"value":"스핀 락"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"가장 기초적인 형태의 락"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"락을 획득할 때까지, CPU 사이클을 소모하면서 회전"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"단일 프로세서에서 이 방식을 제대로 사용하려면 선점형 스케줄러(preemptive scheduler)를 사용하여야 함."}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"선점형 스케줄러는 필요에 따라 다른 쓰레드가 실행될 수 있도록 타이머를 통해 쓰레드에 인터럽트를 발생시킬 수 있음."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"선점형 스케줄러가 아니라면 while 문을 회전하여 대기하는 쓰레드가 CPU를 영원히 독점"}]}]}]}]}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"8️⃣ 스핀 락 평가"}]},{"type":"paragraph","children":[{"type":"span","value":"락에서 가장 중요한 측면은 상호 배제의 "},{"type":"span","marks":["highlight"],"value":"정확성\n"},{"type":"span","value":"➡️ 스핀 락은 임의의 시간에 단 하나의 쓰레드만이 임계 영역에 진입할 수 있도록 함."}]},{"type":"paragraph","children":[{"type":"span","value":"하지만 스핀 락은 어떠한 "},{"type":"span","marks":["highlight"],"value":"공정성"},{"type":"span","value":"도 보장해줄 수 없음.\n➡️ while 문을 회전 중인 쓰레드는 경쟁에서 밀려 계속 그 상태에 남아 있을 수 있음."}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"성능"},{"type":"span","value":"을 평가하기 위해서는 몇 가지 경우를 생각해보아야 함."}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"단일 프로세서를 사용할 때 락을 획득하기 위해 경쟁하는 경우"}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"스핀 락이 갖는 성능 오버헤드는 상당히 클 수 있음."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"스케줄러가 락을 대기 중인 쓰레드들을 하나씩 깨우는 경우 할당받은 기간 동안 CPU 사이클을 낭비하면서 락을 획득하기 위해 대기"}]}]}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"여러 프로세서에 쓰레드가 퍼져 있는 경우"}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"스핀 락은 꽤 합리적으로 동작"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"락을 대기 중인 쓰레드가 락을 사용 중인 쓰레드와 다른 CPU에서 실행 중인 경우 "},{"type":"span","marks":["code"],"value":"while"},{"type":"span","value":" 문을 회전하면서 대기하는 것은 그렇게 많은 사이클을 낭비하지 않음."}]}]}]}]}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"9️⃣ Compare-And-Swap"}]},{"type":"paragraph","children":[{"type":"span","value":"또 다른 하드웨어 기법으로 "},{"type":"span","marks":["highlight"],"value":"Compare-And-Swap"},{"type":"span","value":"(SPARC)/"},{"type":"span","marks":["highlight"],"value":"Compare-And-Exchange"},{"type":"span","value":"(x86)가 있다."}]},{"code":"int CompareAndSwap(int *ptr, int expected, int new) {\n  int actual = *ptr;\n  if (actual == expected)\n    *ptr = new;\n  return actual;\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"💡 기본 개념은 "},{"type":"span","marks":["code"],"value":"ptr"},{"type":"span","value":"이 가리키고 있는 주소의 값이 "},{"type":"span","marks":["code"],"value":"expected"},{"type":"span","value":" 변수와 일치하는지 검사\n➡️ ✅ 만약 일치한다면 "},{"type":"span","marks":["code"],"value":"ptr"},{"type":"span","value":"이 가리키는 주소의 값을 새로운 값으로 변경\n➡️ 🚫 불일치한다면 아무 것도 하지 않음."}]},{"type":"paragraph","children":[{"type":"span","value":"위 방법은 Test-And-Set 방법과 동일한 방식으로 락을 만들 수 있음."}]},{"code":"void lock(lock_t *lock) {\n  while (CompareAndSwap(&lock−>flag, 0, 1) == 1);\n  // 회전\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"동작 또한 Test-And-Set과 유사하다."}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"flag"},{"type":"span","value":" 변수가 0인지 검사하고 만약 그렇다면 자동적으로 1로 바꾸어 락을 획득"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"다른 쓰레드가 락을 보유하고 있다면, 획득할 때까지 "},{"type":"span","marks":["code"],"value":"while"},{"type":"span","value":" 문에서 회전"}]}]}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"CompareAndSwap"},{"type":"span","value":" 명령어는 "},{"type":"span","marks":["code"],"value":"TestAndSet"},{"type":"span","value":" 명령어보다 더 강력\n➡️ "},{"type":"span","marks":["highlight"],"value":"대기없는 동기화(wait-free synchronization)"},{"type":"span","value":"를 다룰 때 진가가 나타남."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"🔟 Load-Linked 그리고 Store-Conditional"}]},{"type":"paragraph","children":[{"type":"span","value":"어떤 플랫폼은 임계 영역 진입 제어 함수를 제작하기 위한 명령어 쌍을 제공"}]},{"type":"paragraph","children":[{"type":"span","value":"MIPS 구조에서는 "},{"type":"span","marks":["highlight"],"value":"load-linked"},{"type":"span","value":"와 "},{"type":"span","marks":["highlight"],"value":"store-conditional"},{"type":"span","value":" 명령어를 앞뒤로 사용하여 락이나 기타 병행 연산을 위한 자료 구조를 만들 수 있음."}]},{"code":"int LoadLinked(int *ptr) {\n  return *ptr;\n}\n\nint StoreConditional(int *ptr, int value) {\n  if (no one has updated *ptr since the LoadLinked to this address) {\n    *ptr = value;\n    return 1; // 성공!\n  } else {\n    return 0; // 갱신을 실패함\n  }\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"load-linked"},{"type":"span","value":": 일반 로드 명령어와 같이 메모리 값을 레지스터에 저장"}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"store-conditional"},{"type":"span","value":": 동일한 주소에 다른 스토어가 없었던 경우에만 저장을 성공\n➡️ 저장이 성공하면, "},{"type":"span","marks":["code"],"value":"load-linked"},{"type":"span","value":"가 탑재했던 값을 갱신\n➡️ ✅ 성공한 경우에는 "},{"type":"span","marks":["code"],"value":"ptr"},{"type":"span","value":"이 가리키는 "},{"type":"span","marks":["code"],"value":"value"},{"type":"span","value":"의 값을 갱신하고 1을 반환\n➡️ 🚫 실패한 경우에는 갱신없이 0을 반환"}]},{"type":"paragraph","children":[{"type":"span","value":"다음은 "},{"type":"span","marks":["code"],"value":"load-linked"},{"type":"span","value":"와 "},{"type":"span","marks":["code"],"value":"store-conditional"},{"type":"span","value":"을 사용하여 락을 만드는 방법이다."}]},{"code":"void lock(lock_t *lock) {\n  while (1) {\n    while (LoadLinked(&lock−>flag) == 1);\n    // 0이 될 때까지 스핀\n    if (StoreConditional(&lock−>flag, 1) == 1)\n      return; // 1로 변경하는 것이 성공하였다면: 완료\n              // 아니라면: 처음부터 다시 시도\n  }\n}\n\nvoid unlock(lock_t *lock) {\n  lock−>flag = 0;\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"lock()"},{"type":"span","value":" 부분의 동작 순서는 다음과 같다."}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"쓰레드가 "},{"type":"span","marks":["code"],"value":"while"},{"type":"span","value":" 문을 돌며 "},{"type":"span","marks":["code"],"value":"flag"},{"type":"span","value":"가 0(락의 해제)이 되기를 기다린다."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"락이 획득 가능한 상태가 되면 쓰레드는 "},{"type":"span","marks":["code"],"value":"store-conditional"},{"type":"span","value":" 명령어로 락 획득을 시도한다."}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"✅ 성공 하는 경우"}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"쓰레드는 "},{"type":"span","marks":["code"],"value":"flag"},{"type":"span","value":" 값을 1로 변경하고 임계 영역 내로 진입한다."}]}]}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"🚫 실패 하는 경우"}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"다시 락을 획득할 수 있을 때까지 기다린다."}]}]}]}]}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"⭐ 그럼 이렇게 "},{"type":"span","marks":["code"],"value":"store-conditional"},{"type":"span","value":" 명령어가 실패하는 경우를 살펴보자."}]},{"type":"paragraph","children":[{"type":"span","value":"쓰레드가 "},{"type":"span","marks":["code"],"value":"lock()"},{"type":"span","value":"을 호출하여 "},{"type":"span","marks":["code"],"value":"load-linked"},{"type":"span","value":"를 통해 0을 반환 받은 후 "},{"type":"span","marks":["code","highlight"],"value":"store-conditional"},{"type":"span","marks":["highlight"],"value":" 명령어를 시도하기 전에 인터럽트"},{"type":"span","value":"에 걸린다고 생각해보자."}]},{"type":"paragraph","children":[{"type":"span","value":"이때 다른 쓰레드가 "},{"type":"span","marks":["code"],"value":"store-conditional"},{"type":"span","value":"을 통해 락 획득에 성공한다면?\n➡️"},{"type":"span","marks":["code"],"value":"store-conditional"},{"type":"span","value":"은 "},{"type":"span","marks":["highlight"],"value":"오직 하나의 쓰레드만 "},{"type":"span","marks":["highlight","code"],"value":"flag"},{"type":"span","marks":["highlight"],"value":" 값을 1로 설정 후 락을 획득"},{"type":"span","value":"할 수 있도록 하므로 인터럽트에 걸린 쓰레드는 다음 기회를 기다릴 수 밖에 없다.(즉, 실패) 😓"}]},{"type":"paragraph","children":[{"type":"span","value":"아래와 같이 "},{"type":"span","marks":["code"],"value":"lock()"},{"type":"span","value":"을 조금 더 간결하게 작성할 수 있다."}]},{"code":"void lock(lock_t *lock) {\n  while (LoadLinked(&lock−>flag) || !StoreConditional(&lock−>flag, 1));\n  // 회전\n}","type":"code","language":"c"},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"1️⃣1️⃣ Fetch-And-Add"}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"Fetch-And-Add"},{"type":"span","value":" 명령어는 "},{"type":"span","marks":["highlight"],"value":"원자적으로 특정 주소의 예전 값을 반환하면서 값을 증가"},{"type":"span","value":"시킨다."}]},{"code":"int FetchAndAdd(int *ptr) {\n  int old = *ptr;\n  *ptr = old + 1;\n  return old;\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"🎟️ "},{"type":"span","marks":["highlight"],"value":"티켓 락"},{"type":"span","value":"\nMellor-Crummey와 Scott이 제안한 것으로, 하나의 변수 만을 사용하는 대신 "},{"type":"span","marks":["highlight"],"value":"티켓(ticket)과 차례(turn) 조합을 사용하여 락"},{"type":"span","value":"을 만든다."}]},{"code":"typedef struct __lock_t {\n  int ticket;\n  int turn;\n} lock_t;\n\nvoid lock_init(lock_t *lock) {\n  lock−>ticket = 0;\n  lock−>turn = 0;\n}\n\nvoid lock(lock_t *lock) {\n  int myturn = FetchAndAdd(&lock−>ticket);\n  while (lock−>turn != myturn);\n  // 회전\n}\n\nvoid unlock(lock_t *lock) {\n  FetchAndAdd(&lock−>turn);\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"하나의 쓰레드가 락 획득을 원할 때, fetch-and-add(원자적으로 동작)를 실행한다.\n➡️ "},{"type":"span","marks":["highlight"],"value":"결과 값은 해당 쓰레드의 \"차례\"(myturn)"},{"type":"span","value":"을 나타낸다.\n➡️ "},{"type":"span","marks":["code"],"value":"myturn == lock->turn"},{"type":"span","value":"(전역 공유 변수) 조건에 부합하면 임계 영역에 진입"}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"unlock()"},{"type":"span","value":" 동작은 차례 변수의 값을 증가시켜서 대기 중인 다음 쓰레드가 존재한다면 임계 영역의 진입 차례를 넘겨준다."}]},{"type":"paragraph","children":[{"type":"span","value":"💡 이전까지의 접근 방법과 다른 점은 "},{"type":"span","marks":["highlight"],"value":"모든 쓰레드들이 각자의 순서에 따라 진행"},{"type":"span","value":"한다는 것\n➡️ 쓰레드가 티켓 값을 할당받았다면 미래의 어느 때에 실행되기 위해 스케줄되어 있다는 것"}]},{"type":"paragraph","children":[{"type":"span","value":"이전의 Test-And-Set의 경우 다른 쓰레드들은 락을 획득/해제하더라도 어떤 쓰레드는 계속 회전만하고 있을 수 있음."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"1️⃣2️⃣ 요약: 과도한 스핀"}]},{"type":"paragraph","children":[{"type":"span","value":"지금까지의 하드웨어 기반 락 ➡️ 간단하고 제대로 동작하지만, 효율적이지 않은 경우도 있음."}]},{"type":"paragraph","children":[{"type":"span","value":"N개의 쓰레드가 프로세서가 하나인 시스템에서 실행하는 경우"}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"한 쓰레드가 "},{"type":"span","marks":["highlight"],"value":"락을 보유한 상태에서 인터럽트"},{"type":"span","value":"에 걸림."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"다음 차례의 쓰레드는 락 획득을 시도 시 스핀 시작"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"다른 N-1 개의 쓰레드들 또한 할당된 CPU 시간 동안 비슷한 이유로 낭비"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"다시 락을 보유한 쓰레드 차례가 되면 락을 해제"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"하드웨어의 지원으로만은 이 문제를 해결할 수 없다.\n➡️ "},{"type":"span","marks":["highlight"],"value":"운영체제로부터의 지원"},{"type":"span","value":"이 추가로 필요"}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"1️⃣3️⃣ 간단한 접근법: 무조건 양보!"}]},{"type":"paragraph","children":[{"type":"span","value":"첫 번째 시도 ➡️ 락이 해제되기를 기다리며 스핀해야 하는 경우 "},{"type":"span","marks":["highlight"],"value":"자신에게 할당된 CPU를 다른 쓰레드에게 양보"}]},{"type":"paragraph","children":[{"type":"span","value":"다음은 Test-And-Set에 양보를 이용한 락을 적용한 코드이다.\n➡️ 운영체제에 자신이 할당받은 CPU 시간을 포기하고 다른 쓰레드가 실행될 수 있도록 하는 "},{"type":"span","marks":["code"],"value":"yield()"},{"type":"span","value":" 기법이 있다고 가정"}]},{"code":"void init() {\n  flag = 0;\n}\n\nvoid lock() {\n  while (TestAndSet(&flag, 1) == 1)\n    yield(); // CPU를 양보함\n}\n\nvoid unlock() {\n  flag = 0;\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"하나의 쓰레드는 다음과 같은 상태를 가질 수 있다."}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"실행 중(running)"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"준비(ready)"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"막힘(blocked)"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"양보(yield) 시스템 콜은 "},{"type":"span","marks":["highlight"],"value":"호출 쓰레드 상태를 실행 중(running) 상태에서 준비(ready) 상태로 변환"},{"type":"span","value":"하여 "},{"type":"span","marks":["highlight"],"value":"다른 쓰레드가 실행 중 상태로 전이"},{"type":"span","value":"하도록 한다.\n➡️ 양보 동작은 스케줄 대상에서 자신을 빼는 것("},{"type":"span","marks":["highlight"],"value":"deschedule"},{"type":"span","value":")이나 마찬가지"}]},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 단일 CPU에서 100개 정도의 쓰레드들이 락 획득을 위해 경쟁하는 경우\n나머지 99개의 쓰레드가 각자 "},{"type":"span","marks":["code"],"value":"lock()"},{"type":"span","value":"을 호출하고 CPU를 양보\n➡️ round-robin 스케줄러 사용 시 99개의 쓰레드가 run-and-yield 패턴으로 동작\n➡️ ✅ 99개의 시간 간격을 낭비하게 되는 회전 방식보다는 좀 더 좋음\n➡️ 🚫 여전히 문맥 교환 비용이 상당하며 낭비가 많음.\n➡️ 🚫 굶주림 문제(이 경우 무한한 양보)는 아직 고려하고 있지도 않음."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"1️⃣4️⃣ 큐의 사용: 스핀 대신 잠자기"}]},{"type":"paragraph","children":[{"type":"span","value":"어떤 쓰레드가 다음으로 락을 획득할지를 명시적으로 제어할 수 있어야 함.\n➡️ "},{"type":"span","marks":["highlight"],"value":"운영체제제로부터 적절한 지원과 큐를 이용한 대기 쓰레드들의 관리가 필요"}]},{"type":"paragraph","children":[{"type":"span","value":"Solaris의 방식을 통해 이를 알아보자."}]},{"type":"paragraph","children":[{"type":"span","value":"아래와 같은 두 개의 호출문이 있다."}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"park()"},{"type":"span","value":": 호출하는 쓰레드를 잠재우는 함수"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"unpark(threadID)"},{"type":"span","value":": threadID로 명시된 특정 쓰레드를 깨우는 함수"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"💡 위의 두 루틴은 이미 사용 중인 락을 요청하는 프로세스를 재우고 해당 락이 해제되면 깨우도록 하는 락을 제작하는 데 사용될 수 있다."}]},{"type":"paragraph","children":[{"type":"span","value":"다음 예시에서 두 가지를 시도해보자."}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Test-And-Set 개념을 락 대기자 전용 큐와 함께 사용하여 좀 더 효율적인 락을 제작"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"큐를 통해 다음 락 획득 대상을 제어하여 기아 현상을 피할 수 있도록 함."}]}]}]},{"code":"typedef struct __lock_t {\n  int flag;\n  int guard;\n  queue_t *q;\n} lock_t;\n\nvoid lock_init(lock_t *m) {\n  m->flag = 0;\n  m->guard = 0;\n  queue_init(m->q);\n}\n\nvoid lock(lock_t *m) {\n  while (TestAndSet(&m->guard, 1) == 1);\n  // 회전하면서 guard 락을 획득\n  if (m->flag == 0) {\n    m->flag = 1; // 락을 획득함\n    m->guard = 0;\n  } else {\n    queue_add(m->q, gettid());\n    m->guard = 0;\n    park();\n  }\n}\n\nvoid unlock(lock_t *m) {\n  while (TestAndSet(&m->guard, 1) == 1);\n  // 회전하면서 guard 락을 획득\n  if (queue_empty(m->q))\n    m->flag = 0; // 락을 포기함: 누구도 락을 원치 않음\n  else\n    unpark(queue_remove(m->q)); // 락을 획득함(다음 쓰레드를 위해!)\n  m->guard = 0;\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"위의 코드에서 나타나는 특징들을 살펴보자."}]},{"type":"paragraph","children":[{"type":"span","value":"[🛡️ "},{"type":"span","marks":["code"],"value":"guard"},{"type":"span","value":" 변수 ➡️ "},{"type":"span","marks":["code"],"value":"flag"},{"type":"span","value":", 큐의 삽입/삭제 동작을 스핀락으로 보호하는 데 사용]"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"이 방법은 회전 대기를 완전히 배제하지는 못했음."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"쓰레드는 락을 획득하거나 해제하는 과정에서 인터럽트에 걸릴 수 있음."}]},{"type":"paragraph","children":[{"type":"span","value":"➡️ 다른 쓰레드는 락의 해제를 기다리며 회전 대기하게 됨."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"사용자가 지정한 임계 영역에 진입하는 것이 아닌, 락과 언락 코드 내의 몇 개의 명령어만 수행하면 되므로 회전 대기 시간은 꽤 짧음."},{"type":"span","value":" ➡️ 합리적"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"[🔒 "},{"type":"span","marks":["code"],"value":"lock()"},{"type":"span","value":" 내에 추가된 동작]"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"lock()"},{"type":"span","value":" 호출 시 다른 쓰레드가 이미 락을 보유한 경우"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"gettid()"},{"type":"span","value":"를 호출하여 현재 실행 중인 쓰레드의 ID를 얻음"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"락 소유자의 큐에 자기 자신을 추가"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"guard"},{"type":"span","value":" 변수를 0으로 변경한 후에 CPU를 양보"}]}]}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"[☀️ 다른 쓰레드가 깨어났을 때 "},{"type":"span","marks":["code"],"value":"flag"},{"type":"span","value":" 변수가 0으로 설정되어 있지 않음.]"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"쓰레드가 깨어날 때는 마치 쓰레드가 "},{"type":"span","marks":["code"],"value":"park()"},{"type":"span","value":"에서 리턴하는 것과 같이 보임."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"하지만 그 시점에서 "},{"type":"span","marks":["code"],"value":"guard"},{"type":"span","value":" 락을 획득한 상태가 아님."}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"flag"},{"type":"span","value":" 변수의 값을 1로 변경하는 것을 시도조차 할 수 없음."}]}]}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"락을 획득하려는 다음 쓰레드로 직접 전달"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"그 사이에 "},{"type":"span","marks":["code"],"value":"flag"},{"type":"span","value":"는 0으로 바뀌지 않음."}]}]}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"[⚔️ "},{"type":"span","marks":["code"],"value":"park()"},{"type":"span","value":" 직전에 경쟁 조건이 발생]"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"한 쓰레드가 락이 사용 중인 이유로 "},{"type":"span","marks":["code"],"value":"park()"},{"type":"span","value":" 문을 수행하려는 상황"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"만약 그 직전에 락 소유자한테 CPU가 할당되는 경우 ➡️ ⚠️ 문제 발생"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"락을 보유한 쓰레드가 해당 락을 해제함."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"처음의 쓰레드가 "},{"type":"span","marks":["code"],"value":"park()"},{"type":"span","value":"를 수행하면 (잠재적으로) 깨어날 방법이 없음."}]},{"type":"paragraph","children":[{"type":"span","value":"➡️ "},{"type":"span","marks":["highlight"],"value":"깨우기/대기 경쟁(wakeup/waiting race)"}]}]}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"Solaris는 이 문제를 "},{"type":"span","marks":["highlight","code"],"value":"setpark()"},{"type":"span","marks":["highlight"],"value":" 시스템 콜을 추가하여 해결"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"이 루틴은 "},{"type":"span","marks":["highlight","code"],"value":"park()"},{"type":"span","marks":["highlight"],"value":"를 호출하기 직전이라는 것을 표시"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"이때 인터럽트가 수행되고 "},{"type":"span","marks":["highlight","code"],"value":"park()"},{"type":"span","marks":["highlight"],"value":" 호출 전 다른 쓰레드가 "},{"type":"span","marks":["highlight","code"],"value":"unpark()"},{"type":"span","marks":["highlight"],"value":"를 먼저 호출"}]},{"type":"paragraph","children":[{"type":"span","value":"➡️ "},{"type":"span","marks":["code"],"value":"park()"},{"type":"span","value":" 문은 sleep 하는 대신 바로 리턴"}]}]}]}]}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"lock()"},{"type":"span","value":" 내에 다음과 같이 "},{"type":"span","marks":["code"],"value":"setpark()"},{"type":"span","value":"를 추가하여 깨우기/대기 경쟁 문제를 해결한다."}]},{"code":"queue_add(m−>q, gettid());\nsetpark(); // 새로운 코드\nm−>guard = 0;","type":"code"},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"guard"},{"type":"span","value":" 변수의 역할을 커널에서 담당하는 것도 하나의 방법\n➡️ 커널은 락 해제와 실행 중인 쓰레드를 큐에서 제거하는 동작을 원자적으로 처리하기 위해 주의해야 함."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"1️⃣5️⃣ 다른 운영체제, 다른 지원"}]},{"type":"heading","level":3,"children":[{"type":"span","value":"Linux"}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"futex"},{"type":"span","value":"라는 것을 지원"}]},{"type":"paragraph","children":[{"type":"span","value":"futex는 특정 물리 메모리 주소와 연결되어 있으며 futex마다 커널 내부의 큐를 갖고 있음."}]},{"type":"paragraph","children":[{"type":"span","value":"호출자는 futex를 호출하여 필요에 따라 잠을 자거나 깨어날 수 있음."}]},{"type":"paragraph","children":[{"type":"span","value":"futex에는 두 개의 명령어가 제공됨."}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"futex_wait(address, expected)"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"address 값과 expected 값이 동일한 경우 쓰레드를 잠재움."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"같지 않은 경우 즉시 리턴함."}]}]}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"futex_wake(address)"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"큐에서 대기하고 있는 쓰레드 하나를 깨움."}]}]}]}]}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight","code"],"value":"nptl"},{"type":"span","value":" 라이브러리의 "},{"type":"span","marks":["code","highlight"],"value":"lowlevellock.h"},{"type":"span","value":"(gnu libc 라이브러리의 일부)를 살펴보자."}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"하나의 정수를 이용하여 락의 사용 중 여부(최상위 비트), 대기자 수(나머지 비트)를 표현"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"만약 락이 음수라면 락이 사용 중인 것을 나타냄."}]}]}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"경쟁이 없는 일반적인 경우에 대한 최적화 방법을 제시"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"단 하나의 쓰레드가 락을 획득하고 해제하는 경우"}]},{"type":"paragraph","children":[{"type":"span","value":"➡️ 원자적으로 비트 단위의 TestAndSet로 락을 획득하고 원자적 덧셈을 하여 락을 해제"}]}]}]}]}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"1️⃣6️⃣ 2단계 락"}]},{"type":"paragraph","children":[{"type":"span","value":"Linux의 기법에는 1960년 초에 있었던 Dahm 락을 시작으로 지금까지 간혹 사용되던 오래된 기법이 녹아있음.\n➡️ 요즘은 "},{"type":"span","marks":["highlight"],"value":"2단계 락(two-phase lock)"},{"type":"span","value":"이라고 불림."}]},{"type":"paragraph","children":[{"type":"span","value":"💡 락이 곧 해제될 것 같은 경우라면 회전 대기가 유용할 수 있다는 것에서 착안한 기법이다."}]},{"code":"void mutex_lock (int *mutex) {\n  int v;\n  /* 31번째 비트가 이미 초기화되어 있다. mutex를 이미 획득했다.\n    바로 리턴한다. (이것이 빠르게 실행하는 방법이다) */ \n  if (atomic_bit_test_set (mutex, 31) == 0)\n    return;\n  atomic_increment (mutex);\n  while (1) {\n    if (atomic_bit_test_set (mutex, 31) == 0) {\n      atomic_decrement (mutex);\n      return;\n    }\n    /* 이제 대기해야 한다. 먼저, 우리가 관찰 중인 futex 값이\n      실제로 음수 인지 확인해야 한다(잠겨있는 상태인지). */\n    v = *mutex;\n    if (v >= 0)\n      continue;\n    futex_wait (mutex, v);\n  }\n}\n\nvoid mutex_unlock (int *mutex) {\n  /* 필요충분 조건으로 관심 대상의 다른 쓰레드가 없는 경우에 한해서\n    0x80000000를 카운터에 더하면 0을 얻는다. */\n  if (atomic_add_zero (mutex, 0x80000000))\n    return;\n  \n  /* 이 mutex를 기다리는 다른 쓰레드가 있다면\n    그 쓰레드들을 깨운다. */\n  futex_wake (mutex);\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"첫 번째 단계 ➡️ 곧 락을 획득할 수 있을 것이라는 기대로 회전하며 기다린다."}]},{"type":"paragraph","children":[{"type":"span","value":"두 번째 단계 ➡️ 첫 번째 단계에서 락을 획득하지 못했다면 sleep 했다가 락이 해제된 후에 깨어난다."}]},{"type":"paragraph","children":[{"type":"span","value":"앞서 본 Linux의 락은 이러한 형태를 갖는 락이지만 한 번만 회전\n➡️ 일반화된 방법은 futex가 잠재우기 전에 일정 시간 동안 반복문 내에서 회전하도록 하는 것"}]},{"type":"paragraph","children":[{"type":"span","value":"💡 2단계 락은 두 개의 좋은 개념을 사용하여 개선된 하나를 만들어 내는 하이브리드 방식의 일종\n➡️ 하드웨어 환경, 쓰레드의 개수, 세부 작업량 등에 의존성이 있으므로 항상 좋다고 보기는 어려움."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"📚 참고 문헌"}]},{"type":"paragraph","children":[{"url":"https://pages.cs.wisc.edu/~remzi/OSTEP/threads-locks.pdf","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"Operating Systems: Three Easy Pieces ― 28: Locks"}]}]},{"type":"paragraph","children":[{"url":"https://pages.cs.wisc.edu/~remzi/OSTEP/Korean/28_threads-locks.pdf","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"운영체제 아주 쉬운 세 가지 이야기 ― 31: 락"}]}]}]}}}}},"pageContext":{"id":"187813035","locale":"ko-KR"}},"staticQueryHashes":["1034768456","1118752904","2342916782","2757196681","3415878905","3879866231","4195094990"]}