{"componentChunkName":"component---src-templates-article-jsx","path":"/blog/development/os-locks","result":{"data":{"datoCmsMiscTextString":{"locale":"ko-KR","updatedAtText":"업데이트됨","nextReadText":"관련있는 게시물"},"datoCmsBlogPost":{"locale":"ko-KR","originalId":"187813035","title":"[운영체제][OSTEP] 락","seo":{"seoTitle":"[운영체제][OSTEP] 락","seoDescription":"임계 영역에서의 원자적인 실행을 위한 락에 대해 공부해봅니다.","seoImage":{"seoImageUrl":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format"}},"subtitle":"임계 영역에서의 원자적인 실행을 위한 락에 대해 공부해봅니다.","coverImage":{"coverImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&w=860","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.25&w=860 215w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.5&w=860 430w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&w=860 860w","sizes":"(min-width: 860px) 860px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgLCgoLDhMVDhcNDh0VDxUSGhYdHSIVFhUaKysjGh0oHSEWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLCgUFEBAOEC8oIhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIAAwAGAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAFAQQGAP/EAB0QAAEEAgMAAAAAAAAAAAAAAAEAAgMEESEFEjL/xAAWAQADAAAAAAAAAAAAAAAAAAAAAQP/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwDD1KM1uPLjpIRUI4GZc4aRXH25hTOHqqbth7yDIVIiXI2IQzqCoREhL/RyuQH/2Q=="},"width":860,"height":430}},"meta":{"updatedAt":"2023-08-17T22:14:37.495+09:00","firstPublishedAt":"2023-08-17T00:33:01.771+09:00"},"categoryLink":{"title":"개발 공부","id":"4743072"},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorPictureData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 60px) 60px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgWEQ8LDhgYDhUNDhgNDw8NFxUdGBYfFhUaHysjGikoHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OHBANHDUcIig7NS81NS81MjUvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAFAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAABQYHAv/EAB4QAAICAgMBAQAAAAAAAAAAAAABAgMFBgQRQXEi/8QAFQEBAQAAAAAAAAAAAAAAAAAABAP/xAAaEQACAwEBAAAAAAAAAAAAAAAAAQIDEhMR/9oADAMBAAIRAxEAPwDT8/1LHSK/r67scevSfz99VXBkm/Cva/zKle/pCc/JoRXWsFujxvygcLI1pAXqQTmjONm2RzpceyCwmwxpsbbADWJdBFbeCfe2wXoAGpIL6z//2Q=="},"width":60,"height":60}}},"relatedPosts":[{"id":"187067258","meta":{"updatedAt":"2023-08-17T00:33:37.291+09:00"},"categoryLink":{"title":"개발 공부"},"coverImage":{"gatsbyImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.09&w=860 75w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.18&w=860 150w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860 300w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.7&w=860 600w","sizes":"(min-width: 300px) 300px, 100vw"}},"layout":"constrained","width":300,"height":120},"squaredImage":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.06&fit=crop&fp-x=0.5&fp-y=0.5&w=430 25w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.12&fit=crop&fp-x=0.5&fp-y=0.5&w=430 50w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430 100w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.47&fit=crop&fp-x=0.5&fp-y=0.5&w=430 200w","sizes":"(min-width: 100px) 100px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBhINEBAQCggUDg0IDgcHFh0JFhEYFxUZGCIVFhUaHysjGh0oHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OEg4REC8dFhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAGAMBIgACEQEDEQH/xAAaAAEBAAIDAAAAAAAAAAAAAAAABAUGAQID/8QAHRAAAgICAwEAAAAAAAAAAAAAAAIDBAEREhQVBf/EABYBAQEBAAAAAAAAAAAAAAAAAAADAf/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/ANASs2WLoaraMl1o0O241wSYlSHjgHM9hVAEFr6bKSemzAAeclpnAAH/2Q=="},"width":100,"height":100}},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.11&w=77 8w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 30px) 30px, 100vw"}},"layout":"constrained","width":30,"height":30}}},"subtitle":"쓰레드 API를 이용하여 쓰레드를 생성하고 제어하는 방법에 대해 공부해봅니다","title":"[운영체제][OSTEP] 쓰레드 API"}],"structuredBody":{"blocks":[],"links":[],"value":{"schema":"dast","document":{"type":"root","children":[{"type":"heading","level":2,"children":[{"type":"span","value":"1️⃣ 락: 기본 개념"}]},{"code":"balance = balance + 1;","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"위와 같은 임계 영역을 다음과 같이 락으로 감싼 상황을 가정해보자."}]},{"code":"lock_t mutex; // 글로벌 변수로 선언된 락\n...\nlock(&mutex);\nbalance = balance + 1;\nunlock(&mutex);","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"위의 코드에서 나타나는 특징들을 하나씩 살펴보자."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"락은 하나의 변수이다."}]},{"type":"paragraph","children":[{"type":"span","value":"락을 사용하기 위해서는 "},{"type":"span","marks":["highlight"],"value":"락 변수를 먼저 선언"},{"type":"span","value":"해야 한다."}]},{"type":"paragraph","children":[{"type":"span","value":"락 변수는 "},{"type":"span","marks":["highlight"],"value":"락의 상태"},{"type":"span","value":"를 나타낸다.\n✅ "},{"type":"span","marks":["highlight"],"value":"사용 가능(available) 상태"},{"type":"span","value":"(해제(unlocked) 또는 free): 어느 쓰레드도 락을 갖고 있지 않은 상태\n🚫 "},{"type":"span","marks":["highlight"],"value":"사용 중(acquired)"},{"type":"span","value":": 임계 영역에서 정확히 하나의 쓰레드가 락을 획득한 상태"}]},{"type":"paragraph","children":[{"type":"span","value":"락 자료 구조에 락을 보유한 쓰레드에 대한 정보나 락을 대기하는 쓰레드들에 대한 정보를 저장할 수도 있음.\n➡️ 단, 락 사용자는 이러한 정보를 알 수 없음."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"lock( )과 unlock( ) 루틴"}]},{"type":"paragraph","children":[{"type":"span","value":"🔒 "},{"type":"span","marks":["code"],"value":"lock()"},{"type":"span","value":" 루틴 호출을 통해 락 획득을 시도\n➡️ 만약 어떤 쓰레드도 락을 갖고 있지 않다면, 락을 획득하여 임계 영역 내로 진입\n➡️ 임계 영역 내로 진입한 쓰레드를 락 "},{"type":"span","marks":["highlight"],"value":"소유자(owner)"},{"type":"span","value":"라고 부름.\n➡️ 락이 이미 사용 중이라면, "},{"type":"span","marks":["code"],"value":"lock()"},{"type":"span","value":" 함수가 리턴하지 않음."}]},{"type":"paragraph","children":[{"type":"span","value":"🔓 락 소유자가 "},{"type":"span","marks":["code"],"value":"unlock()"},{"type":"span","value":"을 호출\n➡️ 락은 다시 사용 가능한 상태가 됨.\n➡️ "},{"type":"span","marks":["code"],"value":"lock()"},{"type":"span","value":" 호출 후 대기 중이던 쓰레드가 있다면, 락을 획득하여 임계 영역 내로 진입"}]},{"type":"paragraph","children":[{"type":"span","value":"락은 프로그래머에게 스케줄링에 대한 최소한의 제어권을 제공"}]},{"type":"paragraph","children":[{"type":"span","value":"일반적으로 쓰레드는 프로그래머가 생성하고 운영체제가 제어\n➡️ 락은 쓰레드에 대한 제어권을 일부 이양 받을 수 있도록 해줌."}]},{"type":"paragraph","children":[{"type":"span","value":"💡 "},{"type":"span","marks":["highlight"],"value":"락으로 코드를 감싸서"},{"type":"span","value":" 프로그래머는 "},{"type":"span","marks":["highlight"],"value":"그 코드 내에서는 하나의 쓰레드만 동작하도록 보장"}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"2️⃣ Pthread 락"}]},{"type":"heading","level":3,"children":[{"type":"span","value":"Mutex"}]},{"type":"paragraph","children":[{"type":"span","value":"쓰레드 간에 "},{"type":"span","marks":["highlight"],"value":"상호 배제(mutual exclusion)"},{"type":"span","value":" 기능을 제공하므로 POSIX 라이브러리는 락을 "},{"type":"span","marks":["highlight"],"value":"mutex"},{"type":"span","value":"라고 부름."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"POSIX의 락 사용 방식"}]},{"type":"paragraph","children":[{"type":"span","value":"POSIX 방식에서는 "},{"type":"span","marks":["highlight"],"value":"변수 명을 지정하여 락과 언락 함수에 전달"},{"type":"span","value":"\n➡️ 다른 변수를 보호하기 위해서 "},{"type":"span","marks":["underline"],"value":"다른 락"},{"type":"span","value":"을 사용할 수도 있기 때문\n➡️ 💡 세밀한 락 사용 전략"}]},{"type":"paragraph","children":[{"type":"span","value":"["},{"type":"span","marks":["highlight"],"value":"거친(coarse-grained)"},{"type":"span","value":" 락 사용 전략]\n하나의 락이 임의의 임계 영역에 진입할 때마다 사용"}]},{"type":"paragraph","children":[{"type":"span","value":"["},{"type":"span","marks":["highlight"],"value":"세밀한(fine-grained)"},{"type":"span","value":" 락 사용 전략]\n서로 다른 데이터와 자료 구조를 보호하기 위해 여러 락을 사용\n➡️ 한 번에 여러 쓰레드가 서로 다른 락으로 보호된 코드 내에 각자가 진입 가능"}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"3️⃣ 락 구현"}]},{"type":"paragraph","children":[{"type":"span","value":"효율적인 락 = 낮은 비용 + 상호 배제 기법 제공 & 몇 가지 속성들"}]},{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"사용 가능한 락"},{"type":"span","value":"을 만들기 위해서 "},{"type":"span","marks":["highlight"],"value":"하드웨어와 운영체제의 도움"},{"type":"span","value":"을 받아야 함."}]},{"type":"paragraph","children":[{"type":"span","value":"정교한 락 라이브러리를 제작하는 데 있어 운영체제가 관여하는 것은 무엇인지 알아보자."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"4️⃣ 락의 평가"}]},{"type":"paragraph","children":[{"type":"span","value":"락이 (잘) 동작하는지 평가하기 위한 기준을 정해야 한다."}]},{"type":"heading","level":3,"children":[{"type":"span","marks":["highlight"],"value":"상호 배제"},{"type":"span","value":"를 제대로 지원하는가"}]},{"type":"paragraph","children":[{"type":"span","value":"락의 가장 기본적인 역할이다."}]},{"type":"paragraph","children":[{"type":"span","value":"기본적으로 락이 동작하여 임계 영역 내로 "},{"type":"span","marks":["highlight"],"value":"다수의 쓰레드가 진입하는 것을 막을 수 있는지 검사"},{"type":"span","value":"해야 한다."}]},{"type":"heading","level":3,"children":[{"type":"span","marks":["highlight"],"value":"공정성(fairness)"}]},{"type":"paragraph","children":[{"type":"span","value":"쓰레드들이 락 획득에 있어 공정한 기회가 주어지는지 확인해야 한다."}]},{"type":"paragraph","children":[{"type":"span","value":"이 문제의 다른 관점: 좀 더 극단적인 상황을 평가\n➡️ 락을 전혀 얻지 못해 "},{"type":"span","marks":["highlight"],"value":"굶주리는(starve)"},{"type":"span","value":" 경우가 발생하는가?"}]},{"type":"heading","level":3,"children":[{"type":"span","marks":["highlight"],"value":"성능(performance)"}]},{"type":"paragraph","children":[{"type":"span","value":"특히, 락 사용 시간적 오버헤드를 평가해야 한다."}]},{"type":"paragraph","children":[{"type":"span","value":"⛏️ 경쟁이 전혀 없는 경우"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"하나의 쓰레드가 실행 중에 락을 획득하고 해제하는 과정에서 발생하는 부하는 얼마나 되는가?"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"⚔️ 여러 쓰레드가 단일 CPU 상에서 락을 획득하려고 경쟁하는 상황"}]},{"type":"paragraph","children":[{"type":"span","value":"♟️ 멀티 CPU 상황에서 락 경쟁 시의 성능"}]},{"type":"paragraph","children":[{"type":"span","value":"이처럼 서로 다른 상황의 성능을 평가하여야 다양한 락 기법들이 성능에 미치는 영향을 이해할 수 있음."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"5️⃣ 인터럽트 제어"}]},{"type":"paragraph","children":[{"type":"span","value":"초창기 단일 프로세스 시스템\n➡️ 상호 배제 지원을 위해 임계 영역 내에서는 "},{"type":"span","marks":["highlight"],"value":"인터럽트를 비활성화"},{"type":"span","value":"하는 방법을 사용"}]},{"code":"void lock() {\n  DisableInterrupts();\n}\nvoid unlock() {\n  EnableInterrupts();\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"이 경우 임계 영역 내의 코드에서는 인터럽트가 발생할 수 없기 때문에 "},{"type":"span","marks":["highlight"],"value":"원자적으로 실행"},{"type":"span","value":"될 수 있음."}]},{"type":"paragraph","children":[{"type":"span","value":"✅ 주요 장점: 단순하다.\n인터럽트가 발생하지 않으면, 코드가 실행 중에 다른 쓰레드가 중간에 끼어들지 않는다는 것을 보장"}]},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 단점1: 이를 요청하는 쓰레드에게 인터럽트 활성/비활성 "},{"type":"span","marks":["highlight"],"value":"특권(privileged)"},{"type":"span","value":" 연산 허가\n쓰레드가 이를 다른 목적으로 사용하지 않음을 "},{"type":"span","marks":["underline"],"value":"신뢰"},{"type":"span","value":"해야 함.\n➡️ 탐욕적(Greedy) 기법을 사용한 프로그램이 시작과 동시에 "},{"type":"span","marks":["code"],"value":"lock()"},{"type":"span","value":"을 호출하여 프로세서를 독점하는 경우.."}]},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 단점2: 멀티프로세서에서는 적용 불가\n여러 쓰레드가 여러 CPU에서 실행 중인 경우 각 쓰레드가 동일한 임계 영역에 진입하려고 시도할 수 있음.\n➡️ 특정 프로세서의 인터럽트 비활성화는 "},{"type":"span","marks":["highlight"],"value":"다른 프로세서에서 실행 중인 프로그램에는 전혀 영향을 주지 않음."}]},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 단점3: 인터럽트의 장시간 중지는 중요한 인터럽트의 시점을 놓칠 수 있음.\n때로는 시스템에 심각한 문제를 가져 올 수 있음.\n➡️ CPU가 저장 장치에서 읽기 요청을 마친 사실을 모르고 지나간다면 이를 기다리고 있는 프로세스는 언제 깨울 수 있을까.."}]},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 단점4: 비효율적이다.\n일반적인 명령어의 실행에 비해 인터럽트를 비활성화시키는 코드들은 최신의 CPU들에서는 느리게 실행되는 경향이 있음."}]},{"type":"paragraph","children":[{"type":"span","value":"💡 따라서 상호 배제를 위한 인터럽트 비활성화는 제한된 범위에서만 사용되어야 한다.\n➡️ 운영체제가 내부 자료 구조에 대한 원자적 연산을 위해 인터럽트를 비활성화하는 등\n➡️ 운영체제 내부에서는 신뢰라는 문제가 사라지므로 용인 가능"}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"6️⃣ Test-And-Set (Atomic Exchange)"}]},{"type":"paragraph","children":[{"type":"span","value":"멀티프로세서에서는 인터럽트를 중지시키는 것이 의미가 없음.\n➡️ 시스템 설계자들은 락 지원을 위한 하드웨어를 설계하기 시작함."}]},{"type":"paragraph","children":[{"type":"span","value":"💡 "},{"type":"span","marks":["highlight"],"value":"Test-And-Set"},{"type":"span","value":" 명령어 또는 "},{"type":"span","marks":["highlight"],"value":"원자적 교체(atomic exchange)"},{"type":"span","value":"\n➡️ 하드웨어 기법 중 기장 기본적인 기법"}]},{"type":"paragraph","children":[{"type":"span","value":"이해를 위해 먼저 아래의 코드를 살펴보자."}]},{"code":"typedef struct __lock_t { int flag; } lock_t;\n\nvoid init(lock_t *mutex) {\n  // 0 −> 락이 사용 가능함, 1 -> 락 사용 중\n  mutex−>flag = 0;\n}\n\nvoid lock(lock_t *mutex) {\n  while (mutex−>flag == 1); // flag 변수를 검사(TEST) 함\n  // spin−wait (do nothing)\n  mutex−>flag = 1; // 이제 설정(SET) 한다!\n}\n\nvoid unlock(lock_t *mutex) {\n  mutex−>flag = 0;\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"💡 간단한 변수("},{"type":"span","marks":["code"],"value":"flag"},{"type":"span","value":")를 사용하여 쓰레드가 락을 획득하였는지를 나타낸다."}]},{"type":"paragraph","children":[{"type":"span","value":"그러나 위의 코드에는 두 가지 문제가 있다."}]},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 문제1: 정확성\n위의 예시에서 적시에 인터럽트가 발생하면 두 쓰레드 모두 플래그를 1로 설정하는 경우가 생길 수 있음.\n➡️ 임계 영역에 두 쓰레드가 다 진입할 수 있음.\n➡️ 🚫 상호 배제 제공 실패"}]},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 문제2: 성능\n사용 중인 락을 대기할 때 "},{"type":"span","marks":["highlight"],"value":"spin-wait"},{"type":"span","value":"라는 방법을 사용\n➡️ 플래그의 값을 무한히 검사하므로, 다른 쓰레드가 락을 해제할 때까지 시간을 낭비\n➡️ 특히, 단일 프로세서에서 매우 손해가 큼.(적어도 문맥 교환이 있기 전까지는 락을 소유한 쓰레드조차 실행X)"}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"7️⃣ 진짜 돌아가는 스핀 락의 구현"}]},{"type":"paragraph","children":[{"type":"span","value":"앞선 아이디어는 하드웨어 지원 없이는 동작이 불가능\n➡️ 일부 시스템은 이 개념에 근간한 락 구현을 위한 (어셈블리) 명령어를 제공"}]},{"type":"paragraph","children":[{"type":"span","value":"아래와 같이 시스템마다 명령어의 이름은 다르지만,"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"SPARC: "},{"type":"span","marks":["code"],"value":"ldstub"},{"type":"span","value":"("},{"type":"span","marks":["code"],"value":"load/store unsigned byte"},{"type":"span","value":" 동작)"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"x86: "},{"type":"span","marks":["code"],"value":"xchg"},{"type":"span","value":"(원자적 교체 명령어)"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"기본적으로 동일한 일을 수행하며 일반적으로 "},{"type":"span","marks":["highlight"],"value":"Test-And-Set"},{"type":"span","value":"라고 불린다."}]},{"type":"paragraph","children":[{"type":"span","value":"다음의 C 코드의 일부를 사용하여 "},{"type":"span","marks":["code"],"value":"TestAndSet"},{"type":"span","value":"의 동작을 정의해 보자."}]},{"code":"int TestAndSet(int *old_ptr, int new) {\n  int old = *old_ptr; // old_ptr의 이전 값을 가져옴\n  *old_ptr = new;     // old_ptr에 'new'의 값을 저장함\n  return old;         // old의 값을 반환함\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":""}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"8️⃣"}]},{"type":"paragraph","children":[{"type":"span","value":""}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"9️⃣"}]},{"type":"paragraph","children":[{"type":"span","value":""}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"🔟"}]},{"type":"paragraph","children":[{"type":"span","value":""}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"1️⃣1️⃣"}]},{"type":"paragraph","children":[{"type":"span","value":""}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"1️⃣2️⃣"}]},{"type":"paragraph","children":[{"type":"span","value":""}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"1️⃣3️⃣"}]},{"type":"paragraph","children":[{"type":"span","value":""}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"1️⃣4️⃣"}]},{"type":"paragraph","children":[{"type":"span","value":""}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"1️⃣5️⃣"}]},{"type":"paragraph","children":[{"type":"span","value":""}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"1️⃣6️⃣"}]},{"type":"paragraph","children":[{"type":"span","value":""}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"📚 참고 문헌"}]},{"type":"paragraph","children":[{"url":"https://pages.cs.wisc.edu/~remzi/OSTEP/threads-locks.pdf","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"Operating Systems: Three Easy Pieces ― 28: Locks"}]}]},{"type":"paragraph","children":[{"url":"https://pages.cs.wisc.edu/~remzi/OSTEP/Korean/28_threads-locks.pdf","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"운영체제 아주 쉬운 세 가지 이야기 ― 31: 락"}]}]}]}}}}},"pageContext":{"id":"187813035","locale":"ko-KR"}},"staticQueryHashes":["1034768456","1118752904","2342916782","2757196681","3415878905","3879866231","4195094990"]}