{"componentChunkName":"component---src-templates-article-jsx","path":"/blog/development/os-condition-variables","result":{"data":{"datoCmsMiscTextString":{"locale":"ko-KR","updatedAtText":"업데이트됨","nextReadText":"관련있는 게시물"},"datoCmsBlogPost":{"locale":"ko-KR","originalId":"199240150","title":"[운영체제][OSTEP] 컨디션 변수","seo":{"seoTitle":"[운영체제][OSTEP] 컨디션 변수","seoDescription":"멀티 쓰레드 프로그램에서 쓰레드가 진행을 위해 컨디션 변수를 통해 특정 조건을 기다리는 방법에 대해 공부해봅니다.","seoImage":{"seoImageUrl":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format"}},"subtitle":"멀티 쓰레드 프로그램에서 쓰레드가 진행을 위해 컨디션 변수를 통해 특정 조건을 기다리는 방법에 대해 공부해봅니다.","coverImage":{"coverImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&w=860","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.25&w=860 215w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.5&w=860 430w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&w=860 860w","sizes":"(min-width: 860px) 860px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgLCgoLDhMVDhcNDh0VDxUSGhYdHSIVFhUaKysjGh0oHSEWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLCgUFEBAOEC8oIhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIAAwAGAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAFAQQGAP/EAB0QAAEEAgMAAAAAAAAAAAAAAAEAAgMEESEFEjL/xAAWAQADAAAAAAAAAAAAAAAAAAAAAQP/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwDD1KM1uPLjpIRUI4GZc4aRXH25hTOHqqbth7yDIVIiXI2IQzqCoREhL/RyuQH/2Q=="},"width":860,"height":430}},"meta":{"updatedAt":"2023-09-17T22:16:29.174+09:00","firstPublishedAt":"2023-09-15T14:11:39.492+09:00"},"categoryLink":{"title":"개발 공부","id":"4743072"},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorPictureData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 60px) 60px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgWEQ8LDhgYDhUNDhgNDw8NFxUdGBYfFhUaHysjGikoHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OHBANHDUcIig7NS81NS81MjUvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAFAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAABQYHAv/EAB4QAAICAgMBAQAAAAAAAAAAAAABAgMFBgQRQXEi/8QAFQEBAQAAAAAAAAAAAAAAAAAABAP/xAAaEQACAwEBAAAAAAAAAAAAAAAAAQIDEhMR/9oADAMBAAIRAxEAPwDT8/1LHSK/r67scevSfz99VXBkm/Cva/zKle/pCc/JoRXWsFujxvygcLI1pAXqQTmjONm2RzpceyCwmwxpsbbADWJdBFbeCfe2wXoAGpIL6z//2Q=="},"width":60,"height":60}}},"relatedPosts":[{"id":"189836506","meta":{"updatedAt":"2023-08-28T15:47:12.013+09:00"},"categoryLink":{"title":"개발 공부"},"coverImage":{"gatsbyImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.09&w=860 75w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.18&w=860 150w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.35&w=860 300w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?auto=format&dpr=0.7&w=860 600w","sizes":"(min-width: 300px) 300px, 100vw"}},"layout":"constrained","width":300,"height":120},"squaredImage":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430","srcSet":"https://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.06&fit=crop&fp-x=0.5&fp-y=0.5&w=430 25w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.12&fit=crop&fp-x=0.5&fp-y=0.5&w=430 50w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.24&fit=crop&fp-x=0.5&fp-y=0.5&w=430 100w,\nhttps://www.datocms-assets.com/66479/1686988115-ostep.jpg?ar=1&auto=format&crop=focalpoint&dpr=0.47&fit=crop&fp-x=0.5&fp-y=0.5&w=430 200w","sizes":"(min-width: 100px) 100px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBhINEBAQCggUDg0IDgcHFh0JFhEYFxUZGCIVFhUaHysjGh0oHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OEg4REC8dFhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAGAMBIgACEQEDEQH/xAAaAAEBAAIDAAAAAAAAAAAAAAAABAUGAQID/8QAHRAAAgICAwEAAAAAAAAAAAAAAAIDBAEREhQVBf/EABYBAQEBAAAAAAAAAAAAAAAAAAADAf/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/ANASs2WLoaraMl1o0O241wSYlSHjgHM9hVAEFr6bKSemzAAeclpnAAH/2Q=="},"width":100,"height":100}},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.11&w=77 8w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 30px) 30px, 100vw"}},"layout":"constrained","width":30,"height":30}}},"subtitle":"자료 구조에 락을 추가하여 쓰레드 사용에 안전한 구조를 만드는 방법에 대해 공부해봅니다.","title":"[운영체제][OSTEP] 락 기반의 병행 자료 구조"}],"structuredBody":{"blocks":[],"links":[],"value":{"schema":"dast","document":{"type":"root","children":[{"type":"heading","level":2,"children":[{"type":"span","value":"🚪 들어가며"}]},{"type":"paragraph","children":[{"type":"span","value":"\"락\"만으로는 병행 프로그램을 제대로 작성할 수 없음\n➡️ 쓰레드가 계속 진행하기 전에 어떤 "},{"type":"span","marks":["highlight"],"value":"조건"},{"type":"span","value":"이 참인지를 검사해야 하는 경우가 많이 있음."}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"join()"},{"type":"span","value":": 부모 쓰레드가 작업을 시작하기 전에 자식 쓰레드가 작업을 끝냈는지 검사"}]},{"code":"volatile int done = 0;\n\nvoid *child(void *arg) {\n  printf(\"child\\n\");\n  done = 1;\n  return NULL;\n}\n\nint main(int argc, char *argv[]) {\n  printf(\"parent: begin\\n\");\n  pthread_t c;\n  Pthread_create(&c, NULL, child, NULL); // 자식 생성하기\n  while (done == 0); // 회전\n  printf(\"parent: end\\n\");\n  return 0;\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"위 처럼 "},{"type":"span","marks":["highlight"],"value":"공유 변수"},{"type":"span","value":"를 사용할 수도 있지만 "},{"type":"span","marks":["highlight"],"value":"부모 쓰레드가 회전을 하면서 CPU 시간을 낭비"},{"type":"span","value":"하므로 비효율적임."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"1️⃣ 정의와 루틴들"}]},{"type":"paragraph","children":[{"type":"span","value":"🚦 "},{"type":"span","marks":["highlight"],"value":"컨디션 변수(conditional variable)"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"일종의 큐 자료 구조"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"어떤 실행의 상태(또는 어떤 "},{"type":"span","marks":["highlight"],"value":"조건"},{"type":"span","value":")가 원하는 것과 다를 때 조건이 참이 되기를 기다리며 쓰레드가 "},{"type":"span","marks":["highlight"],"value":"대기"},{"type":"span","value":"할 수 있는 큐"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"다른 쓰레드가 상태 변경 ➡️ 대기 중이던 쓰레드(하나 이상)를 깨움.(조건에 따라 "},{"type":"span","marks":["highlight"],"value":"시그널"},{"type":"span","value":" 전송)"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"✋ 컨디션 변수의 선언\n"},{"type":"span","marks":["code"],"value":"pthread_cond_t c;"}]},{"type":"paragraph","children":[{"type":"span","value":"컨디션 변수에는 두 개의 연산이 존재"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"wait()"},{"type":"span","value":": 쓰레드가 스스로를 잠재우기 위해 호출"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"signal()"},{"type":"span","value":": 다른 쓰레드가 무언가를 변경하여 잠자던 쓰레드를 깨우기 위해 호출"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"POSIX의 사용례는 다음과 같음."}]},{"code":"pthread_cond_wait(pthread_cond_t *c, pthread_mutex_t *m);\npthread_cond_signal(pthread_cond_t *c);","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"wait()"},{"type":"span","value":"에서 "},{"type":"span","marks":["code"],"value":"mutex"},{"type":"span","value":"를 매개변수로 사용한다는 것을 유의해야 함."}]},{"type":"paragraph","children":[{"type":"span","value":"⭐ "},{"type":"span","marks":["code"],"value":"wait()"},{"type":"span","value":"가 호출될 때 "},{"type":"span","marks":["code"],"value":"mutex"},{"type":"span","value":"는 잠겨있었다고 가정\n➡️ "},{"type":"span","marks":["code"],"value":"wait()"},{"type":"span","value":"의 역할은 락을 해제하고 호출한 쓰레드를 재우는 것\n➡️ 다른 쓰레드가 시그널을 보내 쓰레드가 깨어나면 "},{"type":"span","marks":["code"],"value":"wait()"},{"type":"span","value":"에서 "},{"type":"span","marks":["highlight"],"value":"리턴 전 락을 재획득해야 함."}]},{"type":"paragraph","children":[{"type":"span","value":"조건이 만족하여 깨어났더라도 락을 획득못하면 다시 sleep 상태로 들어감.\n➡️ 복잡한 과정을 거치는 이유: 쓰레드가 스스로 재우려고 할 때, "},{"type":"span","marks":["highlight"],"value":"경쟁 조건의 발생을 방지"},{"type":"span","value":"하기 위함."}]},{"type":"paragraph","children":[{"type":"span","value":"아래의 예시와 함께 이를 살펴보자."}]},{"code":"int done = 0;\npthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t c = PTHREAD_COND_INITIALIZER;\n\nvoid thr_exit() {\n  Pthread_mutex_lock(&m);\n  done = 1;\n  Pthread_cond_signal(&c);\n  Pthread_mutex_unlock(&m);\n}\n\nvoid *child(void *arg) {\n  printf(\"child\\n\");\n  thr_exit();\n  return NULL;\n}\n\nvoid thr_join() {\n  Pthread_mutex_lock(&m);\n  while (done == 0)\n    Pthread_cond_wait(&c, &m);\n  Pthread_mutex_unlock(&m);\n}\n\nint main(int argc, char *argv[]) {\n  printf(\"parent: begin\\n\");\n  pthread_t p;\n  Pthread_create(&p, NULL, child, NULL);\n  thr_join();\n  printf(\"parent: end\\n\");\n  return 0;\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"두 가지 경우를 살펴보자."}]},{"type":"paragraph","children":[{"type":"span","value":"[1] 부모 쓰레드가 자식 쓰레드 생성 후 "},{"type":"span","marks":["code"],"value":"thr_join()"},{"type":"span","value":"을 호출하고 자식 쓰레드의 종료를 대기"}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"부모 쓰레드가 락 획득"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"자식이 끝났는지 검사("},{"type":"span","marks":["code"],"value":"done == 1"},{"type":"span","value":")"}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"자식이 끝나지 않았으므로, "},{"type":"span","marks":["code"],"value":"wait()"},{"type":"span","value":"를 호출하여 스스로를 잠재움.(락 해제)"}]}]}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"자식 쓰레드가 \"child\" 메시지 출력"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"자식 쓰레드가 "},{"type":"span","marks":["code"],"value":"thr_exit()"},{"type":"span","value":"을 호출"}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"락을 획득한 후 상태 변수 "},{"type":"span","marks":["code"],"value":"done"},{"type":"span","value":"을 설정"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"시그널을 보내어 부모 쓰레드를 깨움."}]}]}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"부모 쓰레드가 호출했던 "},{"type":"span","marks":["code"],"value":"wait()"},{"type":"span","value":"에서 락을 획득한 채로 리턴"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"부모 쓰레드가 실행하여 락을 해제하고 \"parent: end\" 메시지 출력"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"[2] 자식 쓰레드가 생성되면서 즉시 실행되고 "},{"type":"span","marks":["code"],"value":"done"},{"type":"span","value":" 변수를 1로 설정 후 시그널 전송"}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"자식 쓰레드가 생성되면서 즉시 실행"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"done"},{"type":"span","value":" 변수를 1로 설정 후 시그널 전송"}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"자고있는 쓰레드가 없으므로 단순히 리턴"}]}]}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"부모 쓰레드가 실행하여 "},{"type":"span","marks":["code"],"value":"thr_join()"},{"type":"span","value":"을 호출"}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"done"},{"type":"span","value":" 변수가 1이므로 대기 없이 바로 리턴"}]}]}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"⭐ 위의 코드에서 알 수 있듯, 부모 쓰레드가 조건을 검사할 때 "},{"type":"span","marks":["code"],"value":"if"},{"type":"span","value":" 문이 아니라 "},{"type":"span","marks":["code"],"value":"while"},{"type":"span","value":" 문을 사용"}]},{"type":"paragraph","children":[{"type":"span","value":"🤔 done 이라는 "},{"type":"span","marks":["highlight"],"value":"상태 변수"},{"type":"span","value":"가 꼭 필요할까? ➡️ "},{"type":"span","marks":["highlight"],"value":"필요하다."}]},{"code":"void thr_exit() {\n  Pthread_mutex_lock(&m);\n  Pthread_cond_signal(&c);\n  Pthread_mutex_unlock(&m);\n}\n\nvoid thr_join() {\n  Pthread_mutex_lock(&m);\n  Pthread_cond_wait(&c, &m);\n  Pthread_mutex_unlock(&m);\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"위의 경우에서 자식 프로세스가 생성 즉시 실행되어 "},{"type":"span","marks":["code"],"value":"thr_exit()"},{"type":"span","value":"을 호출하면 시그널을 보내지만 깨워야 할 쓰레드가 없음.\n➡️ 부모 쓰레드가 실행되면 "},{"type":"span","marks":["code"],"value":"wait()"},{"type":"span","value":" 호출 시 어떤 쓰레드도 부모 쓰레드를 깨우지 않으므로 거기서 멈춤."}]},{"type":"paragraph","children":[{"type":"span","value":"따라서 잠자고, 깨우고, 락을 설정하는 것이 "},{"type":"span","marks":["code"],"value":"done"},{"type":"span","value":"이라는 상태 변수를 중심으로 구현되어 있음."}]},{"type":"paragraph","children":[{"type":"span","value":"🤔 시그널을 주거나 대기할 때 락을 획득할 필요가 없다면 어떤 문제가 생길까?"}]},{"code":"void thr_exit() {\n  done = 1;\n  Pthread_cond_signal(&c);\n}\n\nvoid thr_join() {\n  if (done == 0)\n    Pthread_cond_wait(&c);\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"위의 경우 "},{"type":"span","marks":["highlight"],"value":"경쟁 조건이 발생"},{"type":"span","value":"한다."}]},{"type":"paragraph","children":[{"type":"span","value":"부모 쓰레드가 "},{"type":"span","marks":["code"],"value":"thr_join()"},{"type":"span","value":"을 호출한 후 "},{"type":"span","marks":["code"],"value":"done"},{"type":"span","value":" 변수 값이 0인 것을 확인한 후 잠자려고 할 때, wait() 호출 직전 부모 쓰레드가 인터럽트에 걸려 자식 쓰레드가 실행되는 경우\n➡️ 자식 쓰레드가 상태 변수 "},{"type":"span","marks":["code"],"value":"done"},{"type":"span","value":"의 값을 1로 변경하고 시그널을 보내지만 대기 중인 쓰레드가 없으므로 부모 쓰레드가 다시 실행되면, "},{"type":"span","marks":["code"],"value":"wait()"},{"type":"span","value":"를 호출하고 잠자게 되지만 깨워줄 쓰레드가 없음."}]},{"type":"paragraph","children":[{"type":"span","value":"⭐ "},{"type":"span","marks":["highlight"],"value":"컨디션 변수를 사용"},{"type":"span","value":"할 때는 "},{"type":"span","marks":["highlight"],"value":"락을 획득한 후에 시그널을 보내는 것"},{"type":"span","value":"이 "},{"type":"span","marks":["highlight"],"value":"가장 간단하고 최선의 방법"}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"2️⃣ 생산자/소비자(유한 버퍼) 문제"}]},{"type":"paragraph","children":[{"type":"span","value":"Dijkstra가 처음 제시한 동기화 문제("},{"type":"span","marks":["highlight"],"value":"producer/consumer"},{"type":"span","value":")로, "},{"type":"span","marks":["highlight"],"value":"유한 버퍼(bounded 버퍼)"},{"type":"span","value":" 문제로도 알려져 있음.\n➡️ 락이나 컨디션 변수를 대신하여 사용할 수 있는 일반화된 세마포어를 발명하게 됨."}]},{"type":"paragraph","children":[{"type":"span","value":"여러 개의 생산자 쓰레드(데이터를 만들어 버퍼에 넣음)와 소비자 쓰레드(버퍼에서 데이터를 꺼내어 사용)가 있다고 하자.\n➡️ 예시로 멀티 쓰레드 웹 서버(생산자는 HTTP 요청을 작업 큐(유한 버퍼)에 넣고, 소비자는 이 큐에서 요청을 꺼내어 처리)가 있음.\n➡️ "},{"type":"span","marks":["code"],"value":"grep foo file.txt | wc -l"},{"type":"span","value":"과 같은 파이프(pipe) 명령으로 한 프로그램의 결과를 다른 프로그램에게 전달할 때도 유한 버퍼를 사용"}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"grep foo file.txt | wc -l"},{"type":"span","value":"에서 두 개의 프로세스가 병행 실행되는 예시를 살펴보자.\n➡️ "},{"type":"span","marks":["code"],"value":"grep"},{"type":"span","value":" 프로세스가 생산자, "},{"type":"span","marks":["code"],"value":"wc"},{"type":"span","value":" 프로세스가 소비자\n➡️ 둘 사이에는 커널 내부에 있는 유한 버퍼가 존재"}]},{"type":"paragraph","children":[{"type":"span","value":"🗃️ "},{"type":"span","marks":["highlight"],"value":"유한 버퍼는 공유 자원"},{"type":"span","value":"이다.\n➡️ 경쟁 조건의 발생 방지를 위한 "},{"type":"span","marks":["highlight"],"value":"동기화가 필요"}]},{"code":"int buffer;\nint count = 0; // 처음에는 비어있음\n\nvoid put(int value) {\n  assert(count == 0);\n  count = 1;\n  buffer = value;\n}\n\nint get() {\n  assert(count == 1);\n  count = 0;\n  return buffer;\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"비록 위의 코드에서는 1과 0으로 값 하나에 대한 저장을 표시하지만, 버퍼가 차 있는 지 확인하고 접근, 확인 후 비움 표시 등을 제대로 하고 있다.\n➡️ 버퍼의 count가 0(버퍼 비어있음)이면 데이터 삽입\n➡️ 버퍼의 count가 1(버퍼 가득 참)일 때만 버퍼에서 데이터 추출"}]},{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"put()"},{"type":"span","value":"과 "},{"type":"span","marks":["code"],"value":"get()"},{"type":"span","value":" 루틴에는 임계 영역이 있다.\n➡️ 하지만 락 추가만으로 제대로 동작하는 것은 아님.\n➡️ 🚦"},{"type":"span","marks":["highlight"],"value":"컨디션 변수"},{"type":"span","value":"가 필요"}]},{"type":"paragraph","children":[{"type":"span","value":"아래의 코드는 "},{"type":"span","marks":["code"],"value":"cond"},{"type":"span","value":" 컨디션 변수 하나와 그에 연결된 "},{"type":"span","marks":["code"],"value":"mutex"},{"type":"span","value":" 락을 사용한다."}]},{"code":"cond_t cond;\nmutex_t mutex;\n\nvoid *producer(void *arg) {\n  int i;\n  for (i = 0; i < loops; i++) {\n    Pthread_mutex_lock(&mutex);         // p1\n    if (count == 1)                     // p2\n      Pthread_cond_wait(&cond, &mutex); // p3\n    put(i);                             // p4\n    Pthread_cond_signal(&cond);         // p5\n    Pthread_mutex_unlock(&mutex);       // p6\n  }\n}\n\nvoid *consumer(void *arg) {\n  int i;\n  for (i = 0; i < loops; i++) {\n    Pthread_mutex_lock(&mutex);         // c1\n    if (count == 0)                     // c2\n      Pthread_cond_wait(&cond, &mutex); // c3\n    int tmp = get();                    // c4\n    Pthread_cond_signal(&cond);         // c5\n    Pthread_mutex_unlock(&mutex);       // c6\n    printf(\"%d\\n\", tmp);\n  }\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"생산자는 버퍼가 빌 때까지 기다리고(p1-p3), 소비자도 버퍼가 차기를 기다린다.(c1-c3)\n➡️ 🚫 하지만 두 개 이상의 같은 종류의 쓰레드가 있다면, 이 방법에서는 두 가지 문제가 발생한다."}]},{"type":"paragraph","children":[{"type":"span","value":"두 개의 소비자(Tc1, Tc2)와 한 개의 생산자(Tp)가 있다고 가정하자."}]},{"type":"paragraph","children":[{"type":"span","value":"[⚠️ 문제점1]"}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Tc1이 실행하여 락을 획득(c1)하고 버퍼를 소비할 수 있는지 검사(c2)"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"비어 있음을 확인 후 대기하며(c3) 락을 해제"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Tp가 실행하여 락을 획득(p1)하고 버퍼가 비었는지 확인(p2)"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"비어 있음을 확인하고 버퍼를 채운(p4) 후 버퍼가 가득 찼다는 시그널 전송(p5)"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"대기 중인 Tc1은 깨어나 ready queue로 이동하지만 아직 실행하지 않음."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"생산자가 계속 실행하지만 버퍼가 차 있으므로 대기 상태로 전이(p6, p1-p3)"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"⚠️ "},{"type":"span","marks":["highlight"],"value":"Tc2가 실행하여 버퍼 값을 소비(c1-c2, c4-c6)"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Tc1이 실행되어 대기에서 리턴하기 전 락 획득"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["code"],"value":"get()"},{"type":"span","value":"을 호출(c4)하지만 버퍼는 비어있음. ➡️ 의도한 대로 기능X"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"Tc1이 깨어나서 실행되기까지 사이에 유한 버퍼의 상태가 변경됨.\n➡️ "},{"type":"span","marks":["highlight"],"value":"시그널은 쓰레드를 깨우지만 쓰레드가 실제 실행되는 시점에도 그 상태가 유지된다는 보장X"}]},{"type":"paragraph","children":[{"type":"span","value":"💡 이런 식으로 시그널을 정의하는 것을 "},{"type":"span","marks":["highlight"],"value":"Mesa semantic"},{"type":"span","value":"이라고 함.\n➡️ 대부분의 시스템이 채용"}]},{"type":"paragraph","children":[{"type":"span","value":"💡 이와 대비되는 개념은 "},{"type":"span","marks":["highlight"],"value":"Hoare semantic"},{"type":"span","value":"이 있음.\n➡️ 구현하기는 더 어렵지만 깨어난 즉시 쓰레드가 실행되는 것을 보장"}]},{"type":"paragraph","children":[{"type":"span","value":"✅ 위의 문제는 "},{"type":"span","marks":["highlight"],"value":"대기 명령 전의 if 문을 while 문으로 바꾸어 해결"},{"type":"span","value":"할 수 있다.\n➡️ Tc1이 깨어나서(락을 획득한 상태) 즉시 공유 변수의 상태를 재확인하여 버퍼가 비어 있다면 대기 상태로 돌아감.\n➡️ 소비자 코드와 함께 생산자 코드에서도 "},{"type":"span","marks":["code"],"value":"if"},{"type":"span","value":" 문을 "},{"type":"span","marks":["code"],"value":"while"},{"type":"span","value":" 문으로 변경"}]},{"type":"paragraph","children":[{"type":"span","value":"아래는 수정된 코드이다."}]},{"code":"cond_t cond;\nmutex_t mutex;\n\nvoid *producer(void *arg) {\n  int i;\n  for (i = 0; i < loops; i++) {\n    Pthread_mutex_lock(&mutex);         \n    while (count == 1)                  // 변경\n      Pthread_cond_wait(&cond, &mutex); \n    put(i);                             \n    Pthread_cond_signal(&cond);         \n    Pthread_mutex_unlock(&mutex);       \n  }\n}\n\nvoid *consumer(void *arg) {\n  int i;\n  for (i = 0; i < loops; i++) {\n    Pthread_mutex_lock(&mutex);         \n    while (count == 0)                  // 변경\n      Pthread_cond_wait(&cond, &mutex); \n    int tmp = get();                    \n    Pthread_cond_signal(&cond);         \n    Pthread_mutex_unlock(&mutex);       \n    printf(\"%d\\n\", tmp);\n  }\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"Mesa semantic의 컨디션 변수에서 가장 기본적인 법칙: "},{"type":"span","marks":["highlight"],"value":"언제나 while 문을 사용"},{"type":"span","value":"\n➡️ 항상 검사하는 것이 안전"}]},{"type":"paragraph","children":[{"type":"span","value":"[⚠️ 문제점2]"}]},{"type":"paragraph","children":[{"type":"span","value":"이 문제는 Tc1과 Tc2가 먼저 실행한 후 둘 다 대기 상태에 있을 때 발생한다."}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"두 소비자 쓰레드는 대기하고 Tp가 실행되어 버퍼에 값을 넣고 Tc1을 깨우고 자신은 대기"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Tc1이 "},{"type":"span","marks":["code"],"value":"wait()"},{"type":"span","value":"에서 리턴을 받아 깨어나고 조건을 재확인"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"버퍼가 차있다는 것을 발견하고 값을 소비"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"이후 시그널을 전송하여 대기 중인 쓰레드 중 하나를 깨움."}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"이때 어떤 쓰레드를 깨워야 할까?"}]}]}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"⚠️ 소비자가 버퍼를 비웠으므로 당연히 Tp를 깨워야 하지만, Tc2를 깨운다면 문제가 발생함.\n➡️ Tc2가 깨어나면 버퍼가 비어 있다는 것을 확인한 후 대기 상태로 들어감.\n➡️ 버퍼에 값을 넣어야 하는 Tp와 다른 소비자인 Tc1 역시 대기 상태에 들어감.\n➡️ "},{"type":"span","marks":["highlight"],"value":"세 개의 쓰레드가 모두 대기 상태에 놓임."}]},{"type":"paragraph","children":[{"type":"span","value":"⭐ "},{"type":"span","marks":["highlight"],"value":"시그널을 보내는 것은 꼭 필요하지만 대상이 명확해야 함."},{"type":"span","value":"\n➡️ 소비자는 다른 소비자를 깨울 수 없고 생산자만 깨워야 하며, 반대로 생산자의 경우도 마찬가지임."}]},{"type":"paragraph","children":[{"type":"span","value":"✅ 위의 문제는 "},{"type":"span","marks":["highlight"],"value":"두 개의 컨디션 변수를 사용하여 시스템의 상태가 변경되었을 때 깨워야 하는 쓰레드에게만 시그널을 제대로 전달하여 해결"},{"type":"span","value":"할 수 있다."}]},{"type":"paragraph","children":[{"type":"span","value":"아래는 수정된 코드이다."}]},{"code":"cond_t empty fill;                       // 변경\nmutex_t mutex;\n\nvoid *producer(void *arg) {\n  int i;\n  for (i = 0; i < loops; i++) {\n    Pthread_mutex_lock(&mutex);         \n    while (count == 1)                     \n      Pthread_cond_wait(&empty, &mutex); // 변경\n    put(i);                             \n    Pthread_cond_signal(&fill);          // 변경\n    Pthread_mutex_unlock(&mutex);       \n  }\n}\n\nvoid *consumer(void *arg) {\n  int i;\n  for (i = 0; i < loops; i++) {\n    Pthread_mutex_lock(&mutex);         \n    while (count == 0)                    \n      Pthread_cond_wait(&fill, &mutex);  // 변경\n    int tmp = get();                    \n    Pthread_cond_signal(&empty);         // 변경\n    Pthread_mutex_unlock(&mutex);      \n    printf(\"%d\\n\", tmp);\n  }\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"생산자 쓰레드가 "},{"type":"span","marks":["code"],"value":"empty"},{"type":"span","value":" 조건 변수에서 대기하고 "},{"type":"span","marks":["code"],"value":"fill"},{"type":"span","value":"에 대해서 시그널을 발생"}]},{"type":"paragraph","children":[{"type":"span","value":"소비자 쓰레드는 "},{"type":"span","marks":["code"],"value":"fill"},{"type":"span","value":"에 대해서 대기하고 "},{"type":"span","marks":["code"],"value":"empty"},{"type":"span","value":"에 대해서 시그널을 발생"}]},{"type":"paragraph","children":[{"type":"span","value":"즉, 서로가 같은 종류의 쓰레드를 절대로 깨울 일이 없도록 만듦."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"최종적인 생산자/소비자 해법"}]},{"type":"paragraph","children":[{"type":"span","value":"이제 제대로 동작하는 생산자/소비자 해법을 얻었지만 아직까지는 보편적인 방법은 아님."}]},{"type":"paragraph","children":[{"type":"span","value":"다음을 통해 병행성을 증가시키고 더 효율적으로 만듦."}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"💡 "},{"type":"span","marks":["highlight"],"value":"버퍼 공간을 추가"}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"대기 상태 진입 전 여러 값들이 생산될 수 있도록 함."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"여러 개의 값이 대기 상태 전에 소비될 수 있도록 함."}]}]}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"하나의 생산자와 소비자의 경우, 버퍼가 커지면 쓰레드 간의 문맥 교환이 줄어들어 더 효율적"}]},{"type":"paragraph","children":[{"type":"span","value":"멀티 생산자 또는 멀티 소비자의 경우 생산과 소비가 병행될 수 있으므로 병행성이 좋아짐."}]},{"type":"paragraph","children":[{"type":"span","value":"아래과 같이 버퍼 구조와 "},{"type":"span","marks":["code"],"value":"put()"},{"type":"span","value":"과 "},{"type":"span","marks":["code"],"value":"get()"},{"type":"span","value":"을 변경하여 적용시킬 수 있다.\n이와 함께 생산자와 소비자가 대기 상태가 되는 지에 대한 여부를 결정하는 조건도 약간 변경한다."}]},{"code":"int buffer[MAX];\nint fill = 0;\nint use = 0;\nint count = 0;\n\nvoid put(int value) {\n  buffer[fill] = value;\n  fill = (fill + 1) % MAX;\n  count++;\n}\n\nint get() {\n  int tmp = buffer[use];\n  use = (use + 1) % MAX;\n  count−−;\n  return tmp;\n}","type":"code","language":"c"},{"code":"cond_t empty, fill;\nmutex_t mutex;\n\nvoid *producer(void *arg) {\n  int i;\n  for (i = 0; i < loops; i++) {\n    Pthread_mutex_lock(&mutex); \n    while (count == MAX) \n      Pthread_cond_wait(&empty, &mutex); \n    put(i); \n    Pthread_cond_signal(&fill);\n    Pthread_mutex_unlock(&mutex);\n  }\n}\n\nvoid *consumer(void *arg) {\n  int i;\n  for (i = 0; i < loops; i++) {\n    Pthread_mutex_lock(&mutex); \n    while (count == 0) \n      Pthread_cond_wait(&fill, &mutex); \n    int tmp = get(); \n    Pthread_cond_signal(&empty); \n    Pthread_mutex_unlock(&mutex); \n    printf(\"%d\\n\", tmp);\n  }\n}","type":"code","language":"c"},{"type":"paragraph","children":[{"type":"span","value":"✅ 생산자는 모든 버퍼가 현재 가득 차있다면 대기 상태에 들어간다."}]},{"type":"paragraph","children":[{"type":"span","value":"✅ 소비자도 모든 버퍼가 비어 있다면 대기에 들어간다."}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"3️⃣ 컨디션 변수 사용 시 주의점"}]},{"type":"paragraph","children":[{"type":"span","value":""}]},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"📚 참고 문헌"}]},{"type":"paragraph","children":[{"url":"https://pages.cs.wisc.edu/~remzi/OSTEP/threads-cv.pdf","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"Operating Systems: Three Easy Pieces ― 30: Condition Variables"}]}]},{"type":"paragraph","children":[{"url":"https://pages.cs.wisc.edu/~remzi/OSTEP/Korean/30_threads-cv.pdf","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"운영체제 아주 쉬운 세 가지 이야기 ― 33: 컨디션 변수"}]}]}]}}}}},"pageContext":{"id":"199240150","locale":"ko-KR"}},"staticQueryHashes":["1034768456","1118752904","2342916782","2757196681","3415878905","3879866231","4195094990"]}