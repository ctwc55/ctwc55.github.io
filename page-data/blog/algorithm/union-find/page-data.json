{
    "componentChunkName": "component---src-templates-article-jsx",
    "path": "/blog/algorithm/union-find",
    "result": {"data":{"datoCmsMiscTextString":{"locale":"ko-KR","updatedAtText":"업데이트됨","nextReadText":"관련있는 게시물"},"datoCmsBlogPost":{"locale":"ko-KR","originalId":"138698010","title":"유니온 파인드(Union-Find)","seo":{"seoTitle":"유니온 파인드(Union-Find)","seoDescription":"유니온 파인드 알고리즘에 대해 공부해봅니다.","seoImage":{"seoImageUrl":"https://www.datocms-assets.com/66479/1687362440-pexels-magda-ehlers-1300975.jpg?auto=format"}},"subtitle":"유니온 파인드 알고리즘에 대해 공부해봅니다.","coverImage":{"coverImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1687362440-pexels-magda-ehlers-1300975.jpg?auto=format&w=860","srcSet":"https://www.datocms-assets.com/66479/1687362440-pexels-magda-ehlers-1300975.jpg?auto=format&dpr=0.25&w=860 215w,\nhttps://www.datocms-assets.com/66479/1687362440-pexels-magda-ehlers-1300975.jpg?auto=format&dpr=0.5&w=860 430w,\nhttps://www.datocms-assets.com/66479/1687362440-pexels-magda-ehlers-1300975.jpg?auto=format&w=860 860w","sizes":"(min-width: 860px) 860px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgVCg4NDhAVDRQNDh8ODhEYFxUZGCIVFhUaKysjGh0oHRYWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OFRAQHC8dHSgvLy8vLy87Oy8vLy8vLy8vLy8vLy81Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIAAwAGAMBIgACEQEDEQH/xAAXAAADAQAAAAAAAAAAAAAAAAAAAgQD/8QAHhAAAgICAgMAAAAAAAAAAAAAAgMABAERBTMUISL/xAAXAQADAQAAAAAAAAAAAAAAAAAEBQYA/8QAHBEAAQMFAAAAAAAAAAAAAAAAAQASQQMEE1Fh/9oADAMBAAIRAxEAPwCVrUAedyIbVUbOdxmAJP1maJo1zd9BJyg0QmpuiYSA7j2WfcJYjjavk9cIW8aWy8X/2Q=="},"width":860,"height":430}},"meta":{"updatedAt":"2023-06-22T02:25:39.978+09:00","firstPublishedAt":"2023-06-22T00:53:51.046+09:00"},"categoryLink":{"title":"알고리즘 공부","id":"4743071"},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorPictureData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 60px) 60px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgWEQ8LDhgYDhUNDhgNDw8NFxUdGBYfFhUaHysjGikoHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OHBANHDUcIig7NS81NS81MjUvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAFAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAABQYHAv/EAB4QAAICAgMBAQAAAAAAAAAAAAABAgMFBgQRQXEi/8QAFQEBAQAAAAAAAAAAAAAAAAAABAP/xAAaEQACAwEBAAAAAAAAAAAAAAAAAQIDEhMR/9oADAMBAAIRAxEAPwDT8/1LHSK/r67scevSfz99VXBkm/Cva/zKle/pCc/JoRXWsFujxvygcLI1pAXqQTmjONm2RzpceyCwmwxpsbbADWJdBFbeCfe2wXoAGpIL6z//2Q=="},"width":60,"height":60}}},"relatedPosts":[],"structuredBody":{"blocks":[],"links":[],"value":{"schema":"dast","document":{"type":"root","children":[{"type":"heading","level":2,"children":[{"type":"span","value":"🔍 유니온 파인드(Union-Find)"}]},{"type":"paragraph","children":[{"type":"span","value":"유니온 파인드는 그래프 알고리즘 중 하나로 "},{"type":"span","marks":["highlight"],"value":"두 노드 A와 B가 있을 때 A와 B가 같은 그래프에 속하는 지를 판단"},{"type":"span","value":"하는 알고리즘입니다. 서로소 집합, 분리 집합 또는 상호 배타적 집합(Disjoint-set)이라고도 불립니다."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"무엇을 할 수 있나?"}]},{"type":"paragraph","children":[{"type":"span","value":"유니온 파인드 알고리즘을 익히고 난다면 다음과 같은 일들을 해낼 수 있습니다."}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"[기본] 두 노드가 같은 그래프에 속해 있는 지 판단"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"[응용] 그래프가 회로(사이클)을 형성하는 지 판단"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"[응용] 최소 신장 트리(MST)를 구하는 크루스칼 알고리즘(Kruskal Algorithm)에 활용"}]}]}]},{"type":"heading","level":3,"children":[{"type":"span","value":"어떻게 구현할 수 있나?"}]},{"type":"paragraph","children":[{"type":"span","value":"유니온 파인드 알고리즘은 다른 이름인 \"분리 집합\"에서도 알 수 있듯이 "},{"type":"span","marks":["highlight"],"value":"서로 연결되지 않은 각각의 그래프를 \"분리\"하여 표현"},{"type":"span","value":"함으로써 추후 두 노드가 같은 그래프를 구성하는 지를 알 수 있습니다. "},{"type":"span","marks":["highlight"],"value":"각각의 분리된 그래프(집합)는 그래프를 대표하는 노드로 표현"},{"type":"span","value":"할 수 있는데, "},{"type":"span","marks":["highlight"],"value":"배열"},{"type":"span","value":"을 통해 이를 구현할 수 있습니다. 또한 유니온 파인드 알고리즘은 크게 아래의 두 부분으로 나누어 구현합니다."}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"유니온: 임의의 두 노드 A와 B를 같은 그래프(집합)에 포함시킵니다."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"파인드: 임의의 노드 A가 속한 그래프(집합)의 대표 노드를 찾습니다."}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"알고리즘의 흐름은 다음과 같습니다."}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"대표 노드를 나타내는 "},{"type":"span","marks":["highlight"],"value":"배열의 값을 자기 자신(인덱스 = 값)으로 초기화"},{"type":"span","value":"합니다."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"동일한 그래프에 포함시키고자 하는 임의의 두 노드 A와 B에 대해 각각 위의 "},{"type":"span","marks":["highlight"],"value":"파인드 연산"},{"type":"span","value":"을 거쳐 각각의 노드가 속한 그래프의 대표 노드를 찾습니다. (초기의 경우 각각 A와 B)"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"대표 노드가 같은 경우는 이미 동일한 그래프에 포함"},{"type":"span","value":"되어 있는 것이므로 별다른 연산을 하지 않습니다."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"대표 노드가 다른 경우"},{"type":"span","value":"에는 "},{"type":"span","marks":["highlight"],"value":"유니온 연산"},{"type":"span","value":"을 통해 두 노드가 속한 그래프의 대표 노드를 동일한 값으로 바꿉니다."}]}]}]},{"type":"heading","level":3,"children":[{"type":"span","value":"트리의 치우침 문제 해결"}]},{"type":"paragraph","children":[{"type":"span","value":"간혹 별다른 처리 없이 유니온 파인드 알고리즘을 작동시키면 아래와 같이 트리가 형성될 수 있습니다."}]},{"code":"A\n \\\n  B\n   \\\n    C\n     \\\n      ...","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"이렇게 트리의 치우침 문제가 발생하는 경우 추후 "},{"type":"span","marks":["highlight"],"value":"대표 노드의 탐색 연산 등에서 알고리즘의 효율이 저하"},{"type":"span","value":"될 수 있습니다. 따라서 이를 해결하기 위해서 간단한 규칙을 추가합니다. 노드들을 정수로 표현할 때, "},{"type":"span","marks":["highlight"],"value":"대표 노드는 그 그래프(집합)를 구성하는 노드 중 가장 작은 값의 노드"},{"type":"span","value":"로 하는 것입니다."}]},{"code":"   1      5\n / | \\    |\n2  3  4   6","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"이러한 규칙을 토대로 유니온 연산과 파인드 연산을 수행할 때 부모 노드(대표 노드)를 지속적으로 갱신하며 트리의 치우침 문제를 해결할 수 있습니다. (자세한 내용은 아래의 코드를 참조해주세요.)"}]},{"type":"heading","level":3,"children":[{"type":"span","value":"그래프의 회로(사이클) 형성 판단"}]},{"type":"paragraph","children":[{"type":"span","value":"유니온 파인드 알고리즘을 사용하면 어떠한 그래프가 회로(사이클)을 형성하는 지 쉽게 파악할 수 있습니다. 예를 들어 다음과 같은 그래프가 있다고 가정해봅시다."}]},{"code":"  1\n / \\\n2   3\n \\ /\n  4","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"위와 같이 그래프가 회로를 형성할 때 다음과 같은 과정을 통해 회로의 존재 여부를 파악할 수 있습니다."}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"노드1과 노드2를 union ➡️ 서로 대표 노드가 다르므로(각각 노드1, 노드2) union 가능"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"노드1과 노드3을 union ➡️ 서로 대표 노드가 다르므로(각각 노드1, 노드3) union 가능"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"노드2와 노드4를 union ➡️ 서로 대표 노드가 다르므로(각각 노드1, 노드4) union 가능"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["strong","highlight"],"value":"노드3과 노드4를 union ➡️ 두 노드의 대표 노드가 같으므로(각각 노드1, 노드1) 사이클 발생!"}]}]}]},{"type":"heading","level":2,"children":[{"type":"span","value":"⌨️ C++ 구현 코드"}]},{"code":"#include <bits/stdc++.h>\n#define MAXN 100\n\nusing namespace std;\n\nint parents[MAXN];\n\nint find_parents(int x){\n  if(parents[x] == x) return x;\n\n  //부모 노드를 갱신하면서 찾기\n  return parents[x] = find_parents(parents[x]);\n}\n\nvoid union_nodes(int a, int b){\n  a = find_parents(a);\n  b = find_parents(b);\n\n  //두 노드의 부모(대표) 노드가 같다면 이미 한 그룹\n  if(a == b) return;\n\n  if(a < b) parents[b] = a;\n  else parents[a] = b;\n}\n\nint main()\n{\n  //초기화 - 나의 부모 노드를 자기 자신으로 설정\n  for(int i=0;i<MAXN;i++) parents[i] = i;\n\n  union_nodes(2, 3);\n  union_nodes(2, 4);\n  union_nodes(3, 5);\n  union_nodes(6, 7);\n  union_nodes(1, 2);\n\n  //추가적인 작업(필요에 따라) - 대표 노드 갱신해주기\n  //ex) 3, 4노드의 대표 노드가 2였는데, 2노드의 대표 노드가 1노드가 된 경우\n  //    (2, 3, 4) -> (1, 2, 3, 4)\n  //    3, 4노드의 대표 노드를 1로 바꿔주는 방식\n  for(int i=0;i<MAXN;i++) parents[i] = find_parents(i);\n}","type":"code","language":"cpp","highlight":[0]},{"type":"paragraph","children":[{"type":"span","value":""}]}]}}}}},"pageContext":{"id":"138698010","locale":"ko-KR"}},
    "staticQueryHashes": ["1034768456","1118752904","2342916782","2757196681","3415878905","3879866231","4195094990"]}