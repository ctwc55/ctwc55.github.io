{"componentChunkName":"component---src-templates-article-jsx","path":"/blog/algorithm/network-flow","result":{"data":{"datoCmsMiscTextString":{"locale":"ko-KR","updatedAtText":"업데이트됨","nextReadText":"관련있는 게시물"},"datoCmsBlogPost":{"locale":"ko-KR","originalId":"182554439","title":"네트워크 플로우(Network Flow)","seo":{"seoTitle":"네트워크 플로우(Network Flow)","seoDescription":"네트워크 플로우의 개념과 포드 풀커슨 알고리즘을 통해 최대 유량 문제를 해결해봅니다.","seoImage":{"seoImageUrl":"https://www.datocms-assets.com/66479/1691046253-pexels-photo-collections-213950.jpg?auto=format"}},"subtitle":"네트워크 플로우의 개념과 에드몬드-카프 알고리즘을 통해 최대 유량 문제를 해결해봅니다.","coverImage":{"coverImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1691046253-pexels-photo-collections-213950.jpg?auto=format&w=860","srcSet":"https://www.datocms-assets.com/66479/1691046253-pexels-photo-collections-213950.jpg?auto=format&dpr=0.25&w=860 215w,\nhttps://www.datocms-assets.com/66479/1691046253-pexels-photo-collections-213950.jpg?auto=format&dpr=0.5&w=860 430w,\nhttps://www.datocms-assets.com/66479/1691046253-pexels-photo-collections-213950.jpg?auto=format&w=860 860w","sizes":"(min-width: 860px) 860px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgLCgoLDhgVDQ0WDhcVFhUYGB8eGBYVFhUdHysjGh0oHSEWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OHA0NHC8cFhwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIAAwAGAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAHAQUGAP/EAB8QAAEEAgIDAAAAAAAAAAAAAAIAAQMEEUEhQgUSFv/EABQBAQAAAAAAAAAAAAAAAAAAAAP/xAAXEQEBAQEAAAAAAAAAAAAAAAACIQAB/9oADAMBAAIRAxEAPwAwqPYK1GWNpOsXZ/mGDHVYjx4C5jxtIoxAXgOR6pyJiTuO6tiViL2ba5WxwRi5YHahF0XMXN//2Q=="},"width":860,"height":430}},"meta":{"updatedAt":"2023-08-05T16:18:40.018+09:00","firstPublishedAt":"2023-08-03T16:10:54.400+09:00"},"categoryLink":{"title":"알고리즘 공부","id":"4743071"},"author":{"authorName":"손승열(Son Seungyeol)","picture":{"authorPictureData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77","srcSet":"https://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.2&w=77 15w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.39&w=77 30w,\nhttps://www.datocms-assets.com/66479/1649735652-kakaotalk_20220412_124457267.jpg?auto=format&dpr=0.78&w=77 60w","sizes":"(min-width: 60px) 60px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgWEQ8LDhgYDhUNDhgNDw8NFxUdGBYfFhUaHysjGikoHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OHBANHDUcIig7NS81NS81MjUvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABgAFAMBIgACEQEDEQH/xAAYAAEAAwEAAAAAAAAAAAAAAAAABQYHAv/EAB4QAAICAgMBAQAAAAAAAAAAAAABAgMFBgQRQXEi/8QAFQEBAQAAAAAAAAAAAAAAAAAABAP/xAAaEQACAwEBAAAAAAAAAAAAAAAAAQIDEhMR/9oADAMBAAIRAxEAPwDT8/1LHSK/r67scevSfz99VXBkm/Cva/zKle/pCc/JoRXWsFujxvygcLI1pAXqQTmjONm2RzpceyCwmwxpsbbADWJdBFbeCfe2wXoAGpIL6z//2Q=="},"width":60,"height":60}}},"relatedPosts":[],"structuredBody":{"blocks":[],"links":[],"value":{"schema":"dast","document":{"type":"root","children":[{"type":"heading","level":2,"children":[{"type":"span","value":"🔍 네트워크 플로우(Network Flow)"}]},{"type":"paragraph","children":[{"type":"span","value":"네트워크 플로우는 "},{"type":"span","marks":["highlight"],"value":"한 노드에서 다른 노드로 흘러갈 수 있는 최대 흐름량"},{"type":"span","value":"을 구하는 알고리즘으로 이러한 알고리즘이 적용되는 문제를 "},{"type":"span","marks":["highlight"],"value":"최대 유량 문제"},{"type":"span","value":"라고도 합니다."}]},{"type":"paragraph","children":[{"type":"span","value":"위 알고리즘에서 다루는(입력으로 들어오는) 자료구조는 "},{"type":"span","marks":["highlight"],"value":"유향 가중치 그래프"},{"type":"span","value":"로, 이와 함께 "},{"type":"span","marks":["highlight"],"value":"source 노드"},{"type":"span","value":"와 "},{"type":"span","marks":["highlight"],"value":"sink 노드 정보"},{"type":"span","value":"를 알고 있어야 합니다. 두 노드를 조금 더 살펴보면 다음과 같습니다."}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Source 노드: 진입 간선이 없는(진입 차수 = 0) 노드"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"Sink 노드: 진출 간선이 없는(진출 차수 = 0) 노드"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"예를 들어, 다음과 같은 그래프의 경우"}]},{"type":"paragraph","children":[{"type":"span","value":"\r"}]},{"code":"          ┌───┐   6   ┌───┐\n          │ 2 │ ────→ │ 3 │\n     5    └───┘       └───┘    5\n       ↗    ↑           │    ↘\n┌───┐       │           │      ┌───┐\n│ 1 │     3 │         8 │      │ 6 │\n└───┘       │           │      └───┘\n       ↘    │           ↓    ↗\n     4    ┌───┐       ┌───┐    2\n          │ 4 │ ────→ │ 5 │\n          └───┘   1   └───┘","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"노드 1이 source 노드가 되고 노드 6이 sink 노드가 됩니다."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"최대 유량 문제 조금 더 살펴보기"}]},{"type":"paragraph","children":[{"type":"span","value":"최대 유량 문제에서 우리의 일은 "},{"type":"span","marks":["highlight"],"value":"source 노드로부터 sink 노드로까지 최대한의 유량을 흘려 보내는 것"},{"type":"span","value":"입니다."}]},{"type":"paragraph","children":[{"type":"span","value":"최대 유량 문제의 그래프에서 "},{"type":"span","marks":["highlight"],"value":"간선들의 가중치는 해당 간선에 최대로 흐를 수 있는 용량"},{"type":"span","value":"을 나타내며, "},{"type":"span","marks":["highlight"],"value":"각 중간 노드로 들어오는 유량과 나가는 유량의 크기는 같아"},{"type":"span","value":"야 합니다."}]},{"type":"paragraph","children":[{"type":"span","value":"위의 예시에서는 최대 유량의 크기는 7이며 아래는 흐름의 예시입니다."}]},{"code":"          ┌───┐  6/6  ┌───┐\n          │ 2 │ ────→ │ 3 │\n   3/5    └───┘       └───┘    5/5\n       ↗    ↑           │    ↘\n┌───┐       │           │      ┌───┐\n│ 1 │   3/3 │       1/8 │      │ 6 │\n└───┘       │           │      └───┘\n       ↘    │           ↓    ↗\n   4/4    ┌───┐       ┌───┐    2/2\n          │ 4 │ ────→ │ 5 │\n          └───┘  1/1  └───┘","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"간선마다 표시된 v/k의 의미는 용량 k의 간선에 유량이 v만큼 존재한다는 의미입니다."}]},{"type":"paragraph","children":[{"type":"span","value":"위의 예시를 통해 우리는 source 노드에서 흘려보낸 유량의 총합(3 +4)과 sink 노드로 흘러들어온 유량의 총합(5 + 2)은 같다는 사실을 알 수 있습니다."}]},{"type":"paragraph","children":[{"type":"span","value":"이러한 최대 유량 문제를 해결하기 위한 알고리즘들은 다음과 같습니다."}]},{"type":"list","style":"bulleted","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"포드-풀커슨 알고리즘(Ford-Fulkerson Algorithm)"},{"type":"span","value":": 해결에 "},{"type":"span","marks":["highlight"],"value":"DFS"},{"type":"span","value":"를 활용"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"에드몬드-카프 알고리즘(Edmonds-Karp Algorithm)"},{"type":"span","value":": 해결에 "},{"type":"span","marks":["highlight"],"value":"BFS"},{"type":"span","value":"를 활용"}]}]}]},{"type":"paragraph","children":[{"type":"span","value":"이 글에서는 일반적으로 효율이 더 좋다고 알려진 에드몬드-카프 알고리즘에 대해 살펴보겠습니다."}]},{"type":"heading","level":3,"children":[{"type":"span","value":"에드몬드-카프 알고리즘"}]},{"type":"paragraph","children":[{"type":"span","value":"에드몬드-카프 알고리즘은 빈 흐름에서 시작하여 단계를 거쳐나가며 source 노드에서 sink 노드로 흐르는 유량을 증가시키는 경로를 찾아나갑니다."}]},{"type":"paragraph","children":[{"type":"span","value":"이때, 유량을 더 이상 증가시킬 수 없다면 최대 유량을 발견한 것입니다."}]},{"type":"paragraph","children":[{"type":"span","value":"알고리즘이 진행되면 갱신되는 그래프 간선의 가중치는 "},{"type":"span","marks":["highlight"],"value":"해당 간선에 추가적으로 흐를 수 있는 유량"},{"type":"span","value":"을 의미합니다.\n➡️ 초기 값은 해당 간선에 흐를 수 있는 흐름의 최대 용량"}]},{"type":"paragraph","children":[{"type":"span","value":"에드몬드-카프 알고리즘은 입력받은 유향 가중치 그래프에 추가적으로 "},{"type":"span","marks":["highlight"],"value":"각각의 간선에 대한 반대 방향 간선을 추가하고 0으로 초기화"},{"type":"span","value":"합니다.\n➡️ 나중에 이 역간선의 가중치 값만큼 흘려보낸 유량을 취소할 수 있음.\n➡️ 간선을 통해 "},{"type":"span","marks":["highlight"],"value":"흘려보낸 유량의 크기를 역간선에 음의 값으로 표현"},{"type":"span","value":"하여 추후 가능한 모든 경로를 탐색하는데 활용"}]},{"type":"paragraph","children":[{"type":"span","value":"위의 예시와 함께 이를 도식화하면 다음과 같습니다."}]},{"code":"                  6\n          ┌───┐ ────→ ┌───┐\n          │ 2 │       │ 3 │\n          └───┘ ←──── └───┘    \n    5 ↗↙ 0  ↑│    0     ↑│  0 ↖↘ 5\n┌───┐       ││          ││      ┌───┐\n│ 1 │     3 ││ 0      0 ││ 8    │ 6 │\n└───┘       ││          ││      └───┘\n    0 ↖↘ 4  │↓    1     │↓  2 ↗↙ 0\n          ┌───┐ ────→ ┌───┐    \n          │ 4 │       │ 5 │\n          └───┘ ←──── └───┘\n                  0","type":"code"},{"type":"paragraph","children":[{"type":"span","value":"에드몬드-카프 알고리즘은 다음과 같은 과정을 반복합니다."}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","marks":["highlight"],"value":"BFS"},{"type":"span","value":"를 통해 "},{"type":"span","marks":["highlight"],"value":"source 노드에서 sink 노드"},{"type":"span","value":"로 이어지는 경로("},{"type":"span","marks":["highlight"],"value":"경로 내 모든 간선의 잔여 용량 > 0"},{"type":"span","value":")를 찾는다."}]},{"type":"list","style":"numbered","children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"이러한 경로가 여러 개 존재하는 경우 아무거나 하나를 선택한다."}]}]}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"경로가 선택되었다면, "},{"type":"span","marks":["highlight"],"value":"해당 경로를 구성하는 간선의 잔여 용량 중 최소 값 x만큼 유량이 증가"},{"type":"span","value":"한다."}]},{"type":"paragraph","children":[{"type":"span","value":"➡️ 즉, "},{"type":"span","marks":["highlight"],"value":"해당 경로의 간선들은 각각 x만큼 유량이 증가"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"방금 유량이 증가한 경로의 "},{"type":"span","marks":["highlight"],"value":"역간선(처음에 0으로 초기화한)들의 유량을 x만큼 감소"},{"type":"span","value":"시킨다."}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"span","value":"방금의 경로는 용량이 가득 찬 간선(가중치 = 0)인 간선이 발생했으므로, "},{"type":"span","marks":["highlight"],"value":"1로 돌아가 이러한 경로가 없을 때까지 과정을 반복"},{"type":"span","value":"한다."}]}]}]},{"type":"heading","level":2,"children":[{"type":"span","value":"⌨️ C++ 구현 코드"}]},{"code":"#include <bits/stdc++.h>\n#define MAXN 100\n#define INF 1000000000\n\nusing namespace std;\n\nint N, M;\nint source, sink;\nint capacity[MAXN][MAXN], flow[MAXN][MAXN], before[MAXN];\nvector< vector<int> > edges(MAXN);\n\nint find_max_flow(){\n    int ans = 0, min_capacity;\n    queue<int> bfs;\n\n    while(1){\n        bfs.push(source);\n        for(int i=1;i<=N;i++) before[i] = -1;\n\n        while(!bfs.empty()){\n            int node = bfs.front();\n            for(int i=0;i<(int)edges[node].size();i++){\n                int next = edges[node][i];\n                if(capacity[node][next] - flow[node][next] > 0 && before[next] == -1){\n                    bfs.push(next);\n                    before[next] = node;\n                    if(next == sink) break;\n                }\n            }\n            bfs.pop();\n        }\n        while(bfs.size()) bfs.pop();\n        if(before[sink] == -1) break;\n\n        min_capacity = INF;\n        for(int i=sink;i!=source;i=before[i]) { \n            min_capacity = min(min_capacity, capacity[before[i]][i] - flow[before[i]][i]);\n        }\n        for(int i=sink;i!=source;i=before[i]){\n            flow[before[i]][i] += min_capacity;\n            flow[i][before[i]] -= min_capacity;\n        }\n        ans += min_capacity;\n    }\n\n    return ans;\n}\n\nint main()\n{\n    int a, b, c;\n\n    scanf(\"%d %d\", &N, &M);\n    for(int i=0;i<M;i++){\n        scanf(\"%d %d %d\", &a, &b, &c);\n\n        edges[a].push_back(b);\n        edges[b].push_back(a);\n        capacity[a][b] = c;\n    }\n    scanf(\"%d %d\", &source, &sink);\n\n    printf(\"%d\\n\", find_max_flow());\n}","type":"code","language":"cpp"},{"type":"thematicBreak"},{"type":"heading","level":2,"children":[{"type":"span","value":"📚 참고 문헌"}]},{"type":"paragraph","children":[{"url":"https://cses.fi/book/book.pdf","meta":[{"id":"target","value":"_blank"}],"type":"link","children":[{"type":"span","value":"Competitive Programmer’s Handbook ― Chapter 20: Flows and cuts"}]}]}]}}}}},"pageContext":{"id":"182554439","locale":"ko-KR"}},"staticQueryHashes":["1034768456","1118752904","2342916782","2757196681","3415878905","3879866231","4195094990"]}